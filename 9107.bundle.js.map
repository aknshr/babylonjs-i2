{"version":3,"file":"9107.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractSoundSource.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/streamingSound.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/streamingSoundInstance.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/webAudio/webAudioStreamingSound.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractSound.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractSoundInstance.ts?"],"sourcesContent":["import type { Nullable } from \"../../types\";\nimport { AudioNodeType } from \"./abstractAudioNode\";\nimport type { IAbstractAudioOutNodeOptions } from \"./abstractAudioOutNode\";\nimport { AbstractAudioOutNode } from \"./abstractAudioOutNode\";\nimport type { PrimaryAudioBus } from \"./audioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { AbstractSpatialAudio, ISpatialAudioOptions } from \"./subProperties/abstractSpatialAudio\";\nimport type { AbstractStereoAudio, IStereoAudioOptions } from \"./subProperties/abstractStereoAudio\";\n\n/**\n * Options for creating a sound source.\n */\nexport interface ISoundSourceOptions extends IAbstractAudioOutNodeOptions, ISpatialAudioOptions, IStereoAudioOptions {\n    /**\n     * The output bus for the sound source. Defaults to `null`.\n     * - If not set or `null`, and `outBusAutoDefault` is `true`, then the sound source is automatically connected to the audio engine's default main bus.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    outBus: Nullable<PrimaryAudioBus>;\n\n    /**\n     * Whether the sound's `outBus` should default to the audio engine's main bus. Defaults to `true` for all sound sources except microphones.\n     */\n    outBusAutoDefault: boolean;\n}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSoundSource extends AbstractAudioOutNode {\n    private readonly _spatialAutoUpdate: boolean = true;\n    private readonly _spatialMinUpdateTime: number = 0;\n    private _outBus: Nullable<PrimaryAudioBus> = null;\n    private _spatial: Nullable<AbstractSpatialAudio> = null;\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<ISoundSourceOptions>, nodeType: AudioNodeType = AudioNodeType.HAS_OUTPUTS) {\n        super(name, engine, nodeType);\n\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n    }\n\n    /**\n     * The output bus for the sound.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    public get outBus(): Nullable<PrimaryAudioBus> {\n        return this._outBus;\n    }\n\n    public set outBus(outBus: Nullable<PrimaryAudioBus>) {\n        if (this._outBus === outBus) {\n            return;\n        }\n\n        if (this._outBus) {\n            if (this._onOutBusDisposed) {\n                this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);\n                this._onOutBusDisposed = null;\n            }\n            if (!this._disconnect(this._outBus)) {\n                throw new Error(\"Disconnect failed\");\n            }\n        }\n\n        this._outBus = outBus;\n\n        if (this._outBus) {\n            this._onOutBusDisposed = () => {\n                this._outBus = null;\n            };\n            this._outBus.onDisposeObservable.add(this._onOutBusDisposed);\n            if (!this._connect(this._outBus)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n    }\n\n    /**\n     * The spatial audio features.\n     */\n    public get spatial(): AbstractSpatialAudio {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n\n    /**\n     * The stereo features of the sound.\n     */\n    public abstract stereo: AbstractStereoAudio;\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this._spatial?.dispose();\n        this._spatial = null;\n\n        if (this._outBus && this._onOutBusDisposed) {\n            this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);\n            this._onOutBusDisposed = null;\n        }\n        this._outBus = null;\n    }\n\n    protected abstract _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio;\n\n    protected _initSpatialProperty(): AbstractSpatialAudio {\n        return (this._spatial = this._createSpatialProperty(this._spatialAutoUpdate, this._spatialMinUpdateTime));\n    }\n\n    private _onOutBusDisposed: Nullable<() => void> = null;\n\n    /** @internal */\n    public get _isSpatial(): boolean {\n        return this._spatial !== null;\n    }\n\n    public set _isSpatial(value: boolean) {\n        if (value && !this._spatial) {\n            this._initSpatialProperty();\n        } else if (!value && this._spatial) {\n            this._spatial.dispose();\n            this._spatial = null;\n        }\n    }\n}\n","import { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _StreamingSoundInstance } from \"./streamingSoundInstance\";\n\n/** @internal */\nexport interface IStreamingSoundOptionsBase {\n    /**\n     * The number of instances to preload. Defaults to 1.\n     * */\n    preloadCount: number;\n}\n\n/**\n * Options for creating a streaming sound.\n */\nexport interface IStreamingSoundOptions extends IAbstractSoundOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Options for playing a streaming sound.\n */\nexport interface IStreamingSoundPlayOptions extends IAbstractSoundPlayOptions {}\n\n/**\n * Options stored in a streaming sound.\n * @internal\n */\nexport interface IStreamingSoundStoredOptions extends IAbstractSoundStoredOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Abstract class representing a streaming sound.\n *\n * A streaming sound has a sound buffer that is loaded into memory in chunks as it is played. This allows it to be played\n * more quickly than a static sound, but it also means that it cannot have loop points or playback rate changes.\n *\n * Due to the way streaming sounds are typically implemented, there can be a significant delay when attempting to play\n * a streaming sound for the first time. To prevent this delay, it is recommended to preload instances of the sound\n * using the {@link IStreamingSoundStoredOptions.preloadCount} options, or the {@link preloadInstanceAsync} and\n * {@link preloadInstancesAsync} methods before calling the `play` method.\n *\n * Streaming sounds are created by the {@link CreateStreamingSoundAsync} function.\n */\nexport abstract class StreamingSound extends AbstractSound {\n    private _preloadedInstances = new Array<_StreamingSoundInstance>();\n\n    protected abstract override readonly _options: IStreamingSoundStoredOptions;\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IStreamingSoundOptions>) {\n        super(name, engine, options);\n    }\n\n    /**\n     * The number of instances to preload. Defaults to `1`.\n     */\n    public get preloadCount(): number {\n        return this._options.preloadCount ?? 1;\n    }\n\n    /**\n     * Returns the number of instances that have been preloaded.\n     */\n    public get preloadCompletedCount(): number {\n        return this._preloadedInstances.length;\n    }\n\n    /**\n     * Preloads an instance of the sound.\n     * @returns A promise that resolves when the instance is preloaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public preloadInstanceAsync(): Promise<void> {\n        const instance = this._createInstance();\n\n        this._addPreloadedInstance(instance);\n\n        return instance.preloadedPromise;\n    }\n\n    /**\n     * Preloads the given number of instances of the sound.\n     * @param count - The number of instances to preload.\n     * @returns A promise that resolves when all instances are preloaded.\n     */\n    public async preloadInstancesAsync(count: number): Promise<void> {\n        for (let i = 0; i < count; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.preloadInstanceAsync();\n        }\n\n        await Promise.all(this._preloadedInstances.map(async (instance) => await instance.preloadedPromise));\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        let instance: _StreamingSoundInstance;\n\n        if (this.preloadCompletedCount > 0) {\n            instance = this._preloadedInstances[0];\n            instance.startOffset = this.startOffset;\n            this._removePreloadedInstance(instance);\n        } else {\n            instance = this._createInstance();\n        }\n\n        const onInstanceStateChanged = () => {\n            if (instance.state === SoundState.Started) {\n                this._stopExcessInstances();\n                instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);\n            }\n        };\n        instance.onStateChangedObservable.add(onInstanceStateChanged);\n\n        options.startOffset ??= this.startOffset;\n        options.loop ??= this.loop;\n        options.volume ??= 1;\n\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n    }\n\n    /**\n     * Stops the sound.\n     */\n    public stop(): void {\n        this._setState(SoundState.Stopped);\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop();\n        }\n    }\n\n    protected abstract override _createInstance(): _StreamingSoundInstance;\n\n    private _addPreloadedInstance(instance: _StreamingSoundInstance): void {\n        if (!this._preloadedInstances.includes(instance)) {\n            this._preloadedInstances.push(instance);\n        }\n    }\n\n    private _removePreloadedInstance(instance: _StreamingSoundInstance): void {\n        const index = this._preloadedInstances.indexOf(instance);\n        if (index !== -1) {\n            this._preloadedInstances.splice(index, 1);\n        }\n    }\n}\n","import { Observable } from \"../../Misc/observable\";\nimport type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStreamingSoundOptionsBase, StreamingSound } from \"./streamingSound\";\n\n/**\n * Options for creating streaming sound instance.\n * @internal\n */\nexport interface IStreamingSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStreamingSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StreamingSoundInstance extends _AbstractSoundInstance {\n    private _rejectPreloadedProimse: (reason?: any) => void;\n    private _resolvePreloadedPromise: () => void;\n\n    protected abstract override readonly _options: IStreamingSoundInstanceOptions;\n\n    /** @internal */\n    public readonly onReadyObservable = new Observable<_StreamingSoundInstance>();\n\n    /** @internal */\n    public readonly preloadedPromise = new Promise<void>((resolve, reject) => {\n        this._rejectPreloadedProimse = reject;\n        this._resolvePreloadedPromise = resolve;\n    });\n\n    protected constructor(sound: StreamingSound) {\n        super(sound);\n\n        this.onErrorObservable.add(this._rejectPreloadedProimse);\n        this.onReadyObservable.add(this._resolvePreloadedPromise);\n    }\n\n    /** @internal */\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.onErrorObservable.clear();\n        this.onReadyObservable.clear();\n\n        this._resolvePreloadedPromise();\n    }\n}\n","import { Logger } from \"../../Misc/logger\";\nimport { Tools } from \"../../Misc/tools\";\nimport type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type {} from \"../abstractAudio/abstractSound\";\nimport type { IStreamingSoundOptions, IStreamingSoundPlayOptions, IStreamingSoundStoredOptions } from \"../abstractAudio/streamingSound\";\nimport { StreamingSound } from \"../abstractAudio/streamingSound\";\nimport { _StreamingSoundInstance } from \"../abstractAudio/streamingSoundInstance\";\nimport { _HasSpatialAudioOptions, type AbstractSpatialAudio } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StreamingSoundSourceType = HTMLMediaElement | string | string[];\n\n/** @internal */\nexport class _WebAudioStreamingSound extends StreamingSound implements IWebAudioSuperNode {\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public _source: StreamingSoundSourceType;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStreamingSoundOptions>) {\n        super(name, engine, options);\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            loop: options.loop ?? false,\n            maxInstances: options.maxInstances ?? Infinity,\n            preloadCount: options.preloadCount ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStreamingSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _initAsync(source: StreamingSoundSourceType, options: Partial<IStreamingSoundOptions>): Promise<void> {\n        const audioContext = this.engine._audioContext;\n\n        if (!(audioContext instanceof AudioContext)) {\n            throw new Error(\"Unsupported audio context type.\");\n        }\n\n        this._audioContext = audioContext;\n        this._source = source;\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.initAsync(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (this.preloadCount) {\n            await this.preloadInstancesAsync(this.preloadCount);\n        }\n\n        if (options.autoplay) {\n            this.play(options);\n        }\n\n        this.engine._addSound(this);\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeSound(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSound\";\n    }\n\n    protected _createInstance(): _WebAudioStreamingSoundInstance {\n        return new _WebAudioStreamingSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio {\n        return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);\n    }\n\n    public _getOptions(): IStreamingSoundStoredOptions {\n        return this._options;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStreamingSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nclass _WebAudioStreamingSoundInstance extends _StreamingSoundInstance implements IWebAudioOutNode {\n    private _currentTimeChangedWhilePaused = false;\n    private _enginePlayTime: number = Infinity;\n    private _enginePauseTime: number = 0;\n    private _isReady: boolean = false;\n    private _isReadyPromise: Promise<HTMLMediaElement> = new Promise((resolve, reject) => {\n        this._resolveIsReadyPromise = resolve;\n        this._rejectIsReadyPromise = reject;\n    });\n    private _mediaElement: HTMLMediaElement;\n    private _sourceNode: Nullable<MediaElementAudioSourceNode>;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected override _sound: _WebAudioStreamingSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStreamingSound, options: IStreamingSoundStoredOptions) {\n        super(sound);\n\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n\n        if (typeof sound._source === \"string\") {\n            this._initFromUrl(sound._source);\n        } else if (Array.isArray(sound._source)) {\n            this._initFromUrls(sound._source);\n        } else if (sound._source instanceof HTMLMediaElement) {\n            this._initFromMediaElement(sound._source);\n        } else {\n            throw new Error(`Invalid streaming sound source (${sound._source}).`);\n        }\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            this._mediaElement.pause();\n            this._state = SoundState.Stopped;\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play({ startOffset: value });\n        } else if (this._state === SoundState.Paused) {\n            this._currentTimeChangedWhilePaused = true;\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._sourceNode?.disconnect(this._volumeNode);\n        this._sourceNode = null;\n\n        this._mediaElement.removeEventListener(\"error\", this._onError);\n        this._mediaElement.removeEventListener(\"ended\", this._onEnded);\n        this._mediaElement.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n\n        for (const source of Array.from(this._mediaElement.children)) {\n            this._mediaElement.removeChild(source);\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        this.engine.userGestureObservable.removeCallback(this._onUserGesture);\n    }\n\n    /** @internal */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        this._mediaElement.loop = this._options.loop;\n\n        let startOffset = options.startOffset;\n\n        if (this._currentTimeChangedWhilePaused) {\n            startOffset = this._options.startOffset;\n            this._currentTimeChangedWhilePaused = false;\n        } else if (this._state === SoundState.Paused) {\n            startOffset = this.currentTime + this._options.startOffset;\n        }\n\n        if (startOffset && startOffset > 0) {\n            this._mediaElement.currentTime = startOffset;\n        }\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._play();\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state !== SoundState.Starting && this._state !== SoundState.Started) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        this._mediaElement.pause();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        } else if (this._currentTimeChangedWhilePaused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public override stop(): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        this._stop();\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSoundInstance\";\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initFromMediaElement(mediaElement: HTMLMediaElement): void {\n        Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);\n\n        mediaElement.controls = false;\n        mediaElement.loop = this._options.loop;\n        mediaElement.preload = \"auto\";\n\n        mediaElement.addEventListener(\"canplaythrough\", this._onCanPlayThrough, { once: true });\n        mediaElement.addEventListener(\"ended\", this._onEnded, { once: true });\n        mediaElement.addEventListener(\"error\", this._onError, { once: true });\n\n        mediaElement.load();\n\n        this._sourceNode = new MediaElementAudioSourceNode(this._sound._audioContext, { mediaElement: mediaElement });\n        this._sourceNode.connect(this._volumeNode);\n\n        if (!this._connect(this._sound)) {\n            throw new Error(\"Connect failed\");\n        }\n\n        this._mediaElement = mediaElement;\n    }\n\n    private _initFromUrl(url: string): void {\n        const audio = new Audio(_CleanUrl(url));\n        this._initFromMediaElement(audio);\n    }\n\n    private _initFromUrls(urls: string[]): void {\n        const audio = new Audio();\n\n        for (const url of urls) {\n            const source = document.createElement(\"source\");\n            source.src = _CleanUrl(url);\n            audio.appendChild(source);\n        }\n\n        this._initFromMediaElement(audio);\n    }\n\n    private _onCanPlayThrough: () => void = () => {\n        this._isReady = true;\n        this._resolveIsReadyPromise(this._mediaElement);\n        this.onReadyObservable.notifyObservers(this);\n    };\n\n    private _onEnded: () => void = () => {\n        this.onEndedObservable.notifyObservers(this);\n        this.dispose();\n    };\n\n    private _onError: (reason: any) => void = (reason: any) => {\n        this._setState(SoundState.FailedToStart);\n        this.onErrorObservable.notifyObservers(reason);\n        this._rejectIsReadyPromise(reason);\n        this.dispose();\n    };\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n\n    private _onUserGesture = () => {\n        this.play();\n    };\n\n    private _play(): void {\n        this._setState(SoundState.Starting);\n\n        if (!this._isReady) {\n            this._playWhenReady();\n            return;\n        }\n\n        if (this._state !== SoundState.Starting) {\n            return;\n        }\n\n        if (this.engine.state === \"running\") {\n            const result = this._mediaElement.play();\n\n            this._enginePlayTime = this.engine.currentTime;\n            this._setState(SoundState.Started);\n\n            // It's possible that the play() method fails on Safari, even if the audio engine's state is \"running\".\n            // This occurs when the audio context is paused by the system and resumed automatically by the audio engine\n            // without a user interaction (e.g. when the Vision Pro exits and reenters immersive mode).\n            // eslint-disable-next-line github/no-then\n            result.catch(() => {\n                this._setState(SoundState.FailedToStart);\n\n                if (this._options.loop) {\n                    this.engine.userGestureObservable.addOnce(this._onUserGesture);\n                }\n            });\n        } else if (this._options.loop) {\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        } else {\n            this.stop();\n            this._setState(SoundState.FailedToStart);\n        }\n    }\n\n    private _playWhenReady(): void {\n        this._isReadyPromise\n            // eslint-disable-next-line github/no-then\n            .then(() => {\n                this._play();\n            })\n            // eslint-disable-next-line github/no-then\n            .catch(() => {\n                Logger.Error(\"Streaming sound instance failed to play\");\n                this._setState(SoundState.FailedToStart);\n            });\n    }\n\n    private _rejectIsReadyPromise: (reason?: any) => void;\n    private _resolveIsReadyPromise: (mediaElement: HTMLMediaElement) => void;\n\n    private _stop(): void {\n        this._mediaElement.pause();\n        this._setState(SoundState.Stopped);\n        this._onEnded();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n}\n","import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport { AudioNodeType } from \"./abstractAudioNode\";\nimport type { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport { AbstractSoundSource, type ISoundSourceOptions } from \"./abstractSoundSource\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IVolumeAudioOptions } from \"./subNodes/volumeAudioSubNode\";\n\n/** @internal */\nexport interface IAbstractSoundOptionsBase {\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    autoplay: boolean;\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    maxInstances: number;\n}\n\n/** @internal */\nexport interface IAbstractSoundPlayOptionsBase {\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    loop: boolean;\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    startOffset: number;\n}\n\n/**\n * Options for creating a sound.\n */\nexport interface IAbstractSoundOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptions, ISoundSourceOptions {}\n\n/**\n * Options for playing a sound.\n */\nexport interface IAbstractSoundPlayOptions extends IAbstractSoundPlayOptionsBase, IVolumeAudioOptions {}\n\n/**\n * Options stored in a sound.\n * @internal\n */\nexport interface IAbstractSoundStoredOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptionsBase {}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSound extends AbstractSoundSource {\n    private _newestInstance: Nullable<_AbstractSoundInstance> = null;\n    private _privateInstances = new Set<_AbstractSoundInstance>();\n    private _state: SoundState = SoundState.Stopped;\n\n    protected _instances: ReadonlySet<_AbstractSoundInstance> = this._privateInstances;\n    protected abstract readonly _options: IAbstractSoundStoredOptions;\n\n    /**\n     * Observable for when the sound stops playing.\n     */\n    public readonly onEndedObservable = new Observable<AbstractSound>();\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IAbstractSoundOptions>) {\n        super(name, engine, options, AudioNodeType.HAS_INPUTS_AND_OUTPUTS); // Inputs are for instances.\n    }\n\n    /**\n     * The number of active instances of the sound that are currently playing.\n     */\n    public get activeInstancesCount(): number {\n        return this._instances.size;\n    }\n\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    public get autoplay(): boolean {\n        return this._options.autoplay;\n    }\n\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    public get currentTime(): number {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n\n    public set currentTime(value: number) {\n        this.startOffset = value;\n\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    public get loop(): boolean {\n        return this._options.loop;\n    }\n\n    public set loop(value: boolean) {\n        this._options.loop = value;\n    }\n\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    public get maxInstances(): number {\n        return this._options.maxInstances;\n    }\n\n    public set maxInstances(value: number) {\n        this._options.maxInstances = value;\n    }\n\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    public get startOffset(): number {\n        return this._options.startOffset;\n    }\n\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /**\n     * The state of the sound.\n     */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._newestInstance = null;\n\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public abstract play(options?: Partial<IAbstractSoundPlayOptions>): void;\n\n    /**\n     * Pauses the sound.\n     */\n    public pause(): void {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n\n        this._state = SoundState.Paused;\n    }\n\n    /**\n     * Resumes the sound.\n     */\n    public resume(): void {\n        if (this._state !== SoundState.Paused) {\n            return;\n        }\n\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n\n        this._state = SoundState.Started;\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     */\n    public abstract stop(): void;\n\n    protected _beforePlay(instance: _AbstractSoundInstance): void {\n        if (this.state === SoundState.Paused && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n\n    protected _afterPlay(instance: _AbstractSoundInstance): void {\n        this._state = instance.state;\n    }\n\n    protected _getNewestInstance(): Nullable<_AbstractSoundInstance> {\n        if (this._instances.size === 0) {\n            return null;\n        }\n\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n\n        return this._newestInstance;\n    }\n\n    protected _setState(state: SoundState): void {\n        this._state = state;\n    }\n\n    protected abstract _createInstance(): _AbstractSoundInstance;\n\n    protected _stopExcessInstances(): void {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === SoundState.Started).length - this.maxInstances;\n            const it = this._instances.values();\n\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n\n    private _onInstanceEnded: (instance: _AbstractSoundInstance) => void = (instance) => {\n        if (this._newestInstance === instance) {\n            this._newestInstance = null;\n        }\n\n        this._privateInstances.delete(instance);\n\n        if (this._instances.size === 0) {\n            this._state = SoundState.Stopped;\n            this.onEndedObservable.notifyObservers(this);\n        }\n\n        instance.dispose();\n    };\n}\n","import { Observable } from \"../../Misc/observable\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { AbstractSound, IAbstractSoundPlayOptions, IAbstractSoundPlayOptionsBase } from \"./abstractSound\";\n\n/**\n * Options for creating a sound instance.\n * @internal\n * */\nexport interface IAbstractSoundInstanceOptions extends IAbstractSoundPlayOptionsBase {}\n\n/** @internal */\nexport abstract class _AbstractSoundInstance extends AbstractAudioNode {\n    protected _sound: AbstractSound;\n    protected _state: SoundState = SoundState.Stopped;\n\n    /** Observable triggered when the sound instance's playback ends */\n    public readonly onEndedObservable = new Observable<_AbstractSoundInstance>();\n\n    /** Observable triggered if the sound instance encounters an error and can not be played */\n    public readonly onErrorObservable = new Observable<any>();\n\n    /** Observable triggered when the sound instance's state changes */\n    public readonly onStateChangedObservable = new Observable<_AbstractSoundInstance>();\n\n    protected abstract readonly _options: IAbstractSoundInstanceOptions;\n\n    protected constructor(sound: AbstractSound) {\n        super(sound.engine, AudioNodeType.HAS_OUTPUTS);\n\n        this._sound = sound;\n    }\n\n    public abstract currentTime: number;\n\n    public abstract readonly startTime: number;\n\n    /** The playback state of the sound instance */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n\n    public abstract play(options: Partial<IAbstractSoundPlayOptions>): void;\n    public abstract pause(): void;\n    public abstract resume(): void;\n    public abstract stop(): void;\n\n    protected _setState(value: SoundState) {\n        if (this._state === value) {\n            return;\n        }\n\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n\n        if (this._state === SoundState.Stopped) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n    }\n}\n"],"names":["AbstractSoundSource","name","engine","options","nodeType","super","_spatialAutoUpdate","_spatialMinUpdateTime","_outBus","_spatial","_onOutBusDisposed","spatialAutoUpdate","this","spatialMinUpdateTime","outBus","onDisposeObservable","removeCallback","_disconnect","Error","add","_connect","spatial","_initSpatialProperty","dispose","_createSpatialProperty","_isSpatial","value","StreamingSound","_preloadedInstances","Array","preloadCount","_options","preloadCompletedCount","length","preloadInstanceAsync","instance","_createInstance","_addPreloadedInstance","preloadedPromise","preloadInstancesAsync","count","i","Promise","all","map","async","play","state","resume","startOffset","_removePreloadedInstance","onInstanceStateChanged","_stopExcessInstances","onStateChangedObservable","loop","volume","_beforePlay","_afterPlay","stop","_setState","_instances","from","includes","push","index","indexOf","splice","_StreamingSoundInstance","sound","onReadyObservable","resolve","reject","_rejectPreloadedProimse","_resolvePreloadedPromise","onErrorObservable","clear","_WebAudioStreamingSound","_stereo","autoplay","maxInstances","Infinity","_subGraph","_SubGraph","_initAsync","source","audioContext","_audioContext","AudioContext","_source","outBusAutoDefault","isReadyPromise","defaultMainBus","initAsync","_addSound","_inNode","_outNode","stereo","_removeSound","getClassName","_WebAudioStreamingSoundInstance","node","connect","disconnect","autoUpdate","minUpdateTime","_getOptions","_downstreamNodes","_owner","_upstreamNodes","_currentTimeChangedWhilePaused","_enginePlayTime","_enginePauseTime","_isReady","_isReadyPromise","_resolveIsReadyPromise","_rejectIsReadyPromise","_onCanPlayThrough","_mediaElement","notifyObservers","_onEnded","onEndedObservable","_onError","reason","_onEngineStateChanged","stateChangedObservable","_onUserGesture","_volumeNode","GainNode","_initFromUrl","isArray","_initFromUrls","HTMLMediaElement","_initFromMediaElement","currentTime","_state","timeSinceLastStart","restart","pause","startTime","_sourceNode","removeEventListener","children","removeChild","userGestureObservable","undefined","gain","_play","_stop","mediaElement","SetCorsBehavior","currentSrc","controls","preload","addEventListener","once","load","MediaElementAudioSourceNode","_sound","url","audio","Audio","urls","document","createElement","src","appendChild","result","catch","addOnce","_playWhenReady","then","AbstractSound","_newestInstance","_privateInstances","Set","_onInstanceEnded","delete","size","activeInstancesCount","_getNewestInstance","it","values","next","done","numberOfInstancesToStop","filter","_AbstractSoundInstance"],"ignoreList":[],"sourceRoot":""}