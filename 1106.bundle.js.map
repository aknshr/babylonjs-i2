{"version":3,"file":"1106.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/utils.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphSignalConnection.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphExecutionBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/flowGraphBlockFactory.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphParser.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/KHR_interactivity/interactivityGraphParser.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/KHR_interactivity.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/serialization.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphDataConnection.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphExecutionBlockWithOutSignal.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphConnection.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphEventBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphAsyncExecutionBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphAssetsContext.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphLogger.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphContext.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphSceneEventCoordinator.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraph.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphCoordinator.ts?"],"sourcesContent":["import type { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport type { Node } from \"../node\";\r\nimport type { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport type { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\nimport { FlowGraphTypes } from \"./flowGraphRichTypes\";\r\n\r\n/**\r\n * @internal\r\n * Returns if mesh1 is a descendant of mesh2\r\n * @param mesh1\r\n * @param mesh2\r\n * @returns\r\n */\r\nexport function _IsDescendantOf(mesh1: Node, mesh2: Node): boolean {\r\n    return !!(mesh1.parent && (mesh1.parent === mesh2 || _IsDescendantOf(mesh1.parent, mesh2)));\r\n}\r\n\r\nexport type FlowGraphNumber = number | FlowGraphInteger;\r\nexport type FlowGraphVector = Vector2 | Vector3 | Vector4 | Quaternion;\r\nexport type FlowGraphMatrix = Matrix | FlowGraphMatrix2D | FlowGraphMatrix3D;\r\nexport type FlowGraphMathOperationType = FlowGraphNumber | FlowGraphVector | FlowGraphMatrix | boolean;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport function _GetClassNameOf(v: any) {\r\n    if (v.getClassName) {\r\n        return v.getClassName();\r\n    }\r\n    return;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Check if two classname are the same and are vector or quaternion classes.\r\n * @param className the first class name\r\n * @param className2 the second class name\r\n * @returns whether the two class names are the same and are vector or quaternion classes.\r\n */\r\nexport function _AreSameVectorOrQuaternionClass(className: string, className2: string) {\r\n    return (\r\n        className === className2 &&\r\n        (className === FlowGraphTypes.Vector2 || className === FlowGraphTypes.Vector3 || className === FlowGraphTypes.Vector4 || className === FlowGraphTypes.Quaternion)\r\n    );\r\n}\r\n\r\n/**\r\n * @internal\r\n * Check if two classname are the same and are matrix classes.\r\n * @param className the first class name\r\n * @param className2 the second class name\r\n * @returns whether the two class names are the same and are matrix classes.\r\n */\r\nexport function _AreSameMatrixClass(className: string, className2: string) {\r\n    return className === className2 && (className === FlowGraphTypes.Matrix || className === FlowGraphTypes.Matrix2D || className === FlowGraphTypes.Matrix3D);\r\n}\r\n\r\n/**\r\n * @internal\r\n * Check if two classname are the same and are integer classes.\r\n * @param className the first class name\r\n * @param className2 the second class name\r\n * @returns whether the two class names are the same and are integer classes.\r\n */\r\nexport function _AreSameIntegerClass(className: string, className2: string) {\r\n    return className === \"FlowGraphInteger\" && className2 === \"FlowGraphInteger\";\r\n}\r\n\r\n/**\r\n * Check if an object has a numeric value.\r\n * @param a the object to check if it is a number.\r\n * @param validIfNaN whether to consider NaN as a valid number.\r\n * @returns whether a is a FlowGraphNumber (Integer or number).\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function isNumeric(a: FlowGraphMathOperationType, validIfNaN?: boolean): a is FlowGraphNumber {\r\n    const isNumeric = typeof a === \"number\" || typeof (a as FlowGraphInteger)?.value === \"number\";\r\n    if (isNumeric && !validIfNaN) {\r\n        return !isNaN(getNumericValue(a as FlowGraphNumber));\r\n    }\r\n    return isNumeric;\r\n}\r\n\r\n/**\r\n * Get the numeric value of a FlowGraphNumber.\r\n * @param a the object to get the numeric value from.\r\n * @returns the numeric value.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getNumericValue(a: FlowGraphNumber): number {\r\n    return typeof a === \"number\" ? a : a.value;\r\n}\r\n","import type { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport { FlowGraphAction } from \"./flowGraphLogger\";\r\n\r\n/**\r\n * Represents a connection point for a signal.\r\n * When an output point is activated, it will activate the connected input point.\r\n * When an input point is activated, it will execute the block it belongs to.\r\n */\r\nexport class FlowGraphSignalConnection extends FlowGraphConnection<FlowGraphExecutionBlock, FlowGraphSignalConnection> {\r\n    /**\r\n     * Optional payload. Can be used, for example, when an error is thrown to pass additional information.\r\n     */\r\n    public payload: any;\r\n\r\n    /**\r\n     * The priority of the signal. Signals with higher priority will be executed first.\r\n     * Set priority before adding the connection as sorting happens only when the connection is added.\r\n     */\r\n    public priority: number = 0;\r\n\r\n    public override _isSingularConnection(): boolean {\r\n        return false;\r\n    }\r\n\r\n    public override connectTo(point: FlowGraphSignalConnection): void {\r\n        super.connectTo(point);\r\n        // sort according to priority to handle execution order\r\n        this._connectedPoint.sort((a, b) => b.priority - a.priority);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _activateSignal(context: FlowGraphContext): void {\r\n        context.logger?.addLogItem({\r\n            action: FlowGraphAction.ActivateSignal,\r\n            className: this._ownerBlock.getClassName(),\r\n            uniqueId: this._ownerBlock.uniqueId,\r\n            payload: {\r\n                connectionType: this.connectionType,\r\n                name: this.name,\r\n            },\r\n        });\r\n        if (this.connectionType === FlowGraphConnectionType.Input) {\r\n            context._notifyExecuteNode(this._ownerBlock);\r\n            this._ownerBlock._execute(context, this);\r\n            context._increaseExecutionId();\r\n        } else {\r\n            for (const connectedPoint of this._connectedPoint) {\r\n                connectedPoint._activateSignal(context);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nRegisterClass(\"FlowGraphSignalConnection\", FlowGraphSignalConnection);\r\n","import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * A block that executes some action. Always has an input signal (which is not used by event blocks).\r\n * Can have one or more output signals.\r\n */\r\nexport abstract class FlowGraphExecutionBlock extends FlowGraphBlock {\r\n    /**\r\n     * Input connection: The input signal of the block.\r\n     */\r\n    public readonly in: FlowGraphSignalConnection;\r\n\r\n    /**\r\n     * An output connection that can be used to signal an error, if the block defines it.\r\n     */\r\n    public readonly error: FlowGraphSignalConnection;\r\n    /**\r\n     * Input connections that activate the block.\r\n     */\r\n    public signalInputs: FlowGraphSignalConnection[];\r\n    /**\r\n     * Output connections that can activate downstream blocks.\r\n     */\r\n    public signalOutputs: FlowGraphSignalConnection[];\r\n\r\n    /**\r\n     * The priority of the block. Higher priority blocks will be executed first.\r\n     * Note that priority cannot be change AFTER the block was added as sorting happens when the block is added to the execution queue.\r\n     */\r\n    public readonly priority: number = 0;\r\n\r\n    protected constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.signalInputs = [];\r\n        this.signalOutputs = [];\r\n        this.in = this._registerSignalInput(\"in\");\r\n        this.error = this._registerSignalOutput(\"error\");\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Executes the flow graph execution block.\r\n     */\r\n    public abstract _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void;\r\n\r\n    protected _registerSignalInput(name: string): FlowGraphSignalConnection {\r\n        const input = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Input, this);\r\n        this.signalInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    protected _registerSignalOutput(name: string): FlowGraphSignalConnection {\r\n        const output = new FlowGraphSignalConnection(name, FlowGraphConnectionType.Output, this);\r\n        this.signalOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    protected _unregisterSignalInput(name: string): void {\r\n        const index = this.signalInputs.findIndex((input) => input.name === name);\r\n        if (index !== -1) {\r\n            this.signalInputs[index].dispose();\r\n            this.signalInputs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected _unregisterSignalOutput(name: string): void {\r\n        const index = this.signalOutputs.findIndex((output) => output.name === name);\r\n        if (index !== -1) {\r\n            this.signalOutputs[index].dispose();\r\n            this.signalOutputs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    protected _reportError(context: FlowGraphContext, error: Error | string) {\r\n        this.error.payload = typeof error === \"string\" ? new Error(error) : error;\r\n        this.error._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * Given a name of a signal input, return that input if it exists\r\n     * @param name the name of the input\r\n     * @returns if the input exists, the input. Otherwise, undefined.\r\n     */\r\n    public getSignalInput(name: string): FlowGraphSignalConnection | undefined {\r\n        return this.signalInputs.find((input) => input.name === name);\r\n    }\r\n\r\n    /**\r\n     * Given a name of a signal output, return that input if it exists\r\n     * @param name the name of the input\r\n     * @returns if the input exists, the input. Otherwise, undefined.\r\n     */\r\n    public getSignalOutput(name: string): FlowGraphSignalConnection | undefined {\r\n        return this.signalOutputs.find((output) => output.name === name);\r\n    }\r\n\r\n    /**\r\n     * Serializes this block\r\n     * @param serializationObject the object to serialize in\r\n     */\r\n    public override serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.signalInputs = [];\r\n        serializationObject.signalOutputs = [];\r\n        for (const input of this.signalInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.signalInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.signalOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.signalOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes from an object\r\n     * @param serializationObject the object to deserialize from\r\n     */\r\n    public override deserialize(serializationObject: any) {\r\n        for (let i = 0; i < serializationObject.signalInputs.length; i++) {\r\n            const signalInput = this.getSignalInput(serializationObject.signalInputs[i].name);\r\n            if (signalInput) {\r\n                signalInput.deserialize(serializationObject.signalInputs[i]);\r\n            } else {\r\n                throw new Error(\"Could not find signal input with name \" + serializationObject.signalInputs[i].name + \" in block \" + serializationObject.className);\r\n            }\r\n        }\r\n        for (let i = 0; i < serializationObject.signalOutputs.length; i++) {\r\n            const signalOutput = this.getSignalOutput(serializationObject.signalOutputs[i].name);\r\n            if (signalOutput) {\r\n                signalOutput.deserialize(serializationObject.signalOutputs[i]);\r\n            } else {\r\n                throw new Error(\"Could not find signal output with name \" + serializationObject.signalOutputs[i].name + \" in block \" + serializationObject.className);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FlowGraphExecutionBlock\";\r\n    }\r\n}\r\n","import type { FlowGraphBlock } from \"../flowGraphBlock\";\nimport { FlowGraphBlockNames } from \"./flowGraphBlockNames\";\n\n/**\n * Any external module that wishes to add a new block to the flow graph can add to this object using the helper function.\n */\nconst CustomBlocks: Record<string, () => Promise<typeof FlowGraphBlock>> = {};\n\n/**\n * If you want to add a new block to the block factory, you should use this function.\n * Please be sure to choose a unique name and define the responsible module.\n * @param module the name of the module that is responsible for the block\n * @param blockName the name of the block. This should be unique.\n * @param factory an async factory function to generate the block\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function addToBlockFactory(module: string, blockName: string, factory: () => Promise<typeof FlowGraphBlock>): void {\n    CustomBlocks[`${module}/${blockName}`] = factory;\n}\n\n/**\n * a function to get a factory function for a block.\n * @param blockName the block name to initialize. If the block comes from an external module, the name should be in the format \"module/blockName\"\n * @returns an async factory function that will return the block class when called.\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function blockFactory(blockName: FlowGraphBlockNames | string): () => Promise<typeof FlowGraphBlock> {\n    switch (blockName) {\n        case FlowGraphBlockNames.PlayAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPlayAnimationBlock\")).FlowGraphPlayAnimationBlock;\n        case FlowGraphBlockNames.StopAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphStopAnimationBlock\")).FlowGraphStopAnimationBlock;\n        case FlowGraphBlockNames.PauseAnimation:\n            return async () => (await import(\"./Execution/Animation/flowGraphPauseAnimationBlock\")).FlowGraphPauseAnimationBlock;\n        case FlowGraphBlockNames.ValueInterpolation:\n            return async () => (await import(\"./Execution/Animation/flowGraphInterpolationBlock\")).FlowGraphInterpolationBlock;\n        case FlowGraphBlockNames.SceneReadyEvent:\n            return async () => (await import(\"./Event/flowGraphSceneReadyEventBlock\")).FlowGraphSceneReadyEventBlock;\n        case FlowGraphBlockNames.SceneTickEvent:\n            return async () => (await import(\"./Event/flowGraphSceneTickEventBlock\")).FlowGraphSceneTickEventBlock;\n        case FlowGraphBlockNames.SendCustomEvent:\n            return async () => (await import(\"./Event/flowGraphSendCustomEventBlock\")).FlowGraphSendCustomEventBlock;\n        case FlowGraphBlockNames.ReceiveCustomEvent:\n            return async () => (await import(\"./Event/flowGraphReceiveCustomEventBlock\")).FlowGraphReceiveCustomEventBlock;\n        case FlowGraphBlockNames.MeshPickEvent:\n            return async () => (await import(\"./Event/flowGraphMeshPickEventBlock\")).FlowGraphMeshPickEventBlock;\n        case FlowGraphBlockNames.E:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEBlock;\n        case FlowGraphBlockNames.PI:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPiBlock;\n        case FlowGraphBlockNames.Inf:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphInfBlock;\n        case FlowGraphBlockNames.NaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNaNBlock;\n        case FlowGraphBlockNames.Random:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRandomBlock;\n        case FlowGraphBlockNames.Add:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAddBlock;\n        case FlowGraphBlockNames.Subtract:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSubtractBlock;\n        case FlowGraphBlockNames.Multiply:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMultiplyBlock;\n        case FlowGraphBlockNames.Divide:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDivideBlock;\n        case FlowGraphBlockNames.Abs:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAbsBlock;\n        case FlowGraphBlockNames.Sign:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSignBlock;\n        case FlowGraphBlockNames.Trunc:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTruncBlock;\n        case FlowGraphBlockNames.Floor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFloorBlock;\n        case FlowGraphBlockNames.Ceil:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCeilBlock;\n        case FlowGraphBlockNames.Round:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRoundBlock;\n        case FlowGraphBlockNames.Fraction:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphFractionBlock;\n        case FlowGraphBlockNames.Negation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphNegationBlock;\n        case FlowGraphBlockNames.Modulo:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphModuloBlock;\n        case FlowGraphBlockNames.Min:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMinBlock;\n        case FlowGraphBlockNames.Max:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMaxBlock;\n        case FlowGraphBlockNames.Clamp:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphClampBlock;\n        case FlowGraphBlockNames.Saturate:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSaturateBlock;\n        case FlowGraphBlockNames.MathInterpolation:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphMathInterpolationBlock;\n        case FlowGraphBlockNames.Equality:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphEqualityBlock;\n        case FlowGraphBlockNames.LessThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanBlock;\n        case FlowGraphBlockNames.LessThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLessThanOrEqualBlock;\n        case FlowGraphBlockNames.GreaterThan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanBlock;\n        case FlowGraphBlockNames.GreaterThanOrEqual:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphGreaterThanOrEqualBlock;\n        case FlowGraphBlockNames.IsNaN:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsNanBlock;\n        case FlowGraphBlockNames.IsInfinity:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphIsInfinityBlock;\n        case FlowGraphBlockNames.DegToRad:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphDegToRadBlock;\n        case FlowGraphBlockNames.RadToDeg:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphRadToDegBlock;\n        case FlowGraphBlockNames.Sin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinBlock;\n        case FlowGraphBlockNames.Cos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCosBlock;\n        case FlowGraphBlockNames.Tan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanBlock;\n        case FlowGraphBlockNames.Asin:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinBlock;\n        case FlowGraphBlockNames.Acos:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcosBlock;\n        case FlowGraphBlockNames.Atan:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanBlock;\n        case FlowGraphBlockNames.Atan2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtan2Block;\n        case FlowGraphBlockNames.Sinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSinhBlock;\n        case FlowGraphBlockNames.Cosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCoshBlock;\n        case FlowGraphBlockNames.Tanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTanhBlock;\n        case FlowGraphBlockNames.Asinh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAsinhBlock;\n        case FlowGraphBlockNames.Acosh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAcoshBlock;\n        case FlowGraphBlockNames.Atanh:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphAtanhBlock;\n        case FlowGraphBlockNames.Exponential:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphExpBlock;\n        case FlowGraphBlockNames.Log:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLogBlock;\n        case FlowGraphBlockNames.Log2:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog2Block;\n        case FlowGraphBlockNames.Log10:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLog10Block;\n        case FlowGraphBlockNames.SquareRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphSquareRootBlock;\n        case FlowGraphBlockNames.Power:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphPowerBlock;\n        case FlowGraphBlockNames.CubeRoot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphCubeRootBlock;\n        case FlowGraphBlockNames.BitwiseAnd:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseAndBlock;\n        case FlowGraphBlockNames.BitwiseOr:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseOrBlock;\n        case FlowGraphBlockNames.BitwiseNot:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseNotBlock;\n        case FlowGraphBlockNames.BitwiseXor:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseXorBlock;\n        case FlowGraphBlockNames.BitwiseLeftShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseLeftShiftBlock;\n        case FlowGraphBlockNames.BitwiseRightShift:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphBitwiseRightShiftBlock;\n        case FlowGraphBlockNames.Length:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphLengthBlock;\n        case FlowGraphBlockNames.Normalize:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphNormalizeBlock;\n        case FlowGraphBlockNames.Dot:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphDotBlock;\n        case FlowGraphBlockNames.Cross:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphCrossBlock;\n        case FlowGraphBlockNames.Rotate2D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate2DBlock;\n        case FlowGraphBlockNames.Rotate3D:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphRotate3DBlock;\n        case FlowGraphBlockNames.Transpose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphTransposeBlock;\n        case FlowGraphBlockNames.Determinant:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphDeterminantBlock;\n        case FlowGraphBlockNames.InvertMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphInvertMatrixBlock;\n        case FlowGraphBlockNames.MatrixMultiplication:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixMultiplicationBlock;\n        case FlowGraphBlockNames.Branch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphBranchBlock\")).FlowGraphBranchBlock;\n        case FlowGraphBlockNames.SetDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSetDelayBlock\")).FlowGraphSetDelayBlock;\n        case FlowGraphBlockNames.CancelDelay:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCancelDelayBlock\")).FlowGraphCancelDelayBlock;\n        case FlowGraphBlockNames.CallCounter:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphCounterBlock\")).FlowGraphCallCounterBlock;\n        case FlowGraphBlockNames.Debounce:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDebounceBlock\")).FlowGraphDebounceBlock;\n        case FlowGraphBlockNames.Throttle:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphThrottleBlock\")).FlowGraphThrottleBlock;\n        case FlowGraphBlockNames.DoN:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphDoNBlock\")).FlowGraphDoNBlock;\n        case FlowGraphBlockNames.FlipFlop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphFlipFlopBlock\")).FlowGraphFlipFlopBlock;\n        case FlowGraphBlockNames.ForLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphForLoopBlock\")).FlowGraphForLoopBlock;\n        case FlowGraphBlockNames.MultiGate:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphMultiGateBlock\")).FlowGraphMultiGateBlock;\n        case FlowGraphBlockNames.Sequence:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSequenceBlock\")).FlowGraphSequenceBlock;\n        case FlowGraphBlockNames.Switch:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphSwitchBlock\")).FlowGraphSwitchBlock;\n        case FlowGraphBlockNames.WaitAll:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWaitAllBlock\")).FlowGraphWaitAllBlock;\n        case FlowGraphBlockNames.WhileLoop:\n            return async () => (await import(\"./Execution/ControlFlow/flowGraphWhileLoopBlock\")).FlowGraphWhileLoopBlock;\n        case FlowGraphBlockNames.ConsoleLog:\n            return async () => (await import(\"./Execution/flowGraphConsoleLogBlock\")).FlowGraphConsoleLogBlock;\n        case FlowGraphBlockNames.Conditional:\n            return async () => (await import(\"./Data/flowGraphConditionalDataBlock\")).FlowGraphConditionalDataBlock;\n        case FlowGraphBlockNames.Constant:\n            return async () => (await import(\"./Data/flowGraphConstantBlock\")).FlowGraphConstantBlock;\n        case FlowGraphBlockNames.TransformCoordinatesSystem:\n            return async () => (await import(\"./Data/flowGraphTransformCoordinatesSystemBlock\")).FlowGraphTransformCoordinatesSystemBlock;\n        case FlowGraphBlockNames.GetAsset:\n            return async () => (await import(\"./Data/flowGraphGetAssetBlock\")).FlowGraphGetAssetBlock;\n        case FlowGraphBlockNames.GetProperty:\n            return async () => (await import(\"./Data/flowGraphGetPropertyBlock\")).FlowGraphGetPropertyBlock;\n        case FlowGraphBlockNames.SetProperty:\n            return async () => (await import(\"./Execution/flowGraphSetPropertyBlock\")).FlowGraphSetPropertyBlock;\n        case FlowGraphBlockNames.GetVariable:\n            return async () => (await import(\"./Data/flowGraphGetVariableBlock\")).FlowGraphGetVariableBlock;\n        case FlowGraphBlockNames.SetVariable:\n            return async () => (await import(\"./Execution/flowGraphSetVariableBlock\")).FlowGraphSetVariableBlock;\n        case FlowGraphBlockNames.JsonPointerParser:\n            return async () => (await import(\"./Data/Transformers/flowGraphJsonPointerParserBlock\")).FlowGraphJsonPointerParserBlock;\n        case FlowGraphBlockNames.LeadingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphLeadingZerosBlock;\n        case FlowGraphBlockNames.TrailingZeros:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphTrailingZerosBlock;\n        case FlowGraphBlockNames.OneBitsCounter:\n            return async () => (await import(\"./Data/Math/flowGraphMathBlocks\")).FlowGraphOneBitsCounterBlock;\n        case FlowGraphBlockNames.CombineVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector2Block;\n        case FlowGraphBlockNames.CombineVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector3Block;\n        case FlowGraphBlockNames.CombineVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineVector4Block;\n        case FlowGraphBlockNames.CombineMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphCombineMatrixBlock;\n        case FlowGraphBlockNames.ExtractVector2:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector2Block;\n        case FlowGraphBlockNames.ExtractVector3:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector3Block;\n        case FlowGraphBlockNames.ExtractVector4:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractVector4Block;\n        case FlowGraphBlockNames.ExtractMatrix:\n            return async () => (await import(\"./Data/Math/flowGraphMathCombineExtractBlocks\")).FlowGraphExtractMatrixBlock;\n        case FlowGraphBlockNames.TransformVector:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformBlock;\n        case FlowGraphBlockNames.TransformCoordinates:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphTransformCoordinatesBlock;\n        case FlowGraphBlockNames.Conjugate:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphConjugateBlock;\n        case FlowGraphBlockNames.AngleBetween:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAngleBetweenBlock;\n        case FlowGraphBlockNames.QuaternionFromAxisAngle:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromAxisAngleBlock;\n        case FlowGraphBlockNames.AxisAngleFromQuaternion:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphAxisAngleFromQuaternionBlock;\n        case FlowGraphBlockNames.QuaternionFromDirections:\n            return async () => (await import(\"./Data/Math/flowGraphVectorMathBlocks\")).FlowGraphQuaternionFromDirectionsBlock;\n        case FlowGraphBlockNames.MatrixDecompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixDecomposeBlock;\n        case FlowGraphBlockNames.MatrixCompose:\n            return async () => (await import(\"./Data/Math/flowGraphMatrixMathBlocks\")).FlowGraphMatrixComposeBlock;\n        case FlowGraphBlockNames.BooleanToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToFloat;\n        case FlowGraphBlockNames.BooleanToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphBooleanToInt;\n        case FlowGraphBlockNames.FloatToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToBoolean;\n        case FlowGraphBlockNames.IntToBoolean:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToBoolean;\n        case FlowGraphBlockNames.IntToFloat:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphIntToFloat;\n        case FlowGraphBlockNames.FloatToInt:\n            return async () => (await import(\"./Data/Transformers/flowGraphTypeToTypeBlocks\")).FlowGraphFloatToInt;\n        case FlowGraphBlockNames.Easing:\n            return async () => (await import(\"./Execution/Animation/flowGraphEasingBlock\")).FlowGraphEasingBlock;\n        case FlowGraphBlockNames.BezierCurveEasing:\n            return async () => (await import(\"./Execution/Animation/flowGraphBezierCurveEasingBlock\")).FlowGraphBezierCurveEasingBlock;\n        case FlowGraphBlockNames.PointerOverEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOverEventBlock\")).FlowGraphPointerOverEventBlock;\n        case FlowGraphBlockNames.PointerOutEvent:\n            return async () => (await import(\"./Event/flowGraphPointerOutEventBlock\")).FlowGraphPointerOutEventBlock;\n        case FlowGraphBlockNames.Context:\n            return async () => (await import(\"./Data/Utils/flowGraphContextBlock\")).FlowGraphContextBlock;\n        case FlowGraphBlockNames.ArrayIndex:\n            return async () => (await import(\"./Data/Utils/flowGraphArrayIndexBlock\")).FlowGraphArrayIndexBlock;\n        case FlowGraphBlockNames.CodeExecution:\n            return async () => (await import(\"./Data/Utils/flowGraphCodeExecutionBlock\")).FlowGraphCodeExecutionBlock;\n        case FlowGraphBlockNames.IndexOf:\n            return async () => (await import(\"./Data/Utils/flowGraphIndexOfBlock\")).FlowGraphIndexOfBlock;\n        case FlowGraphBlockNames.FunctionReference:\n            return async () => (await import(\"./Data/Utils/flowGraphFunctionReferenceBlock\")).FlowGraphFunctionReferenceBlock;\n        case FlowGraphBlockNames.DataSwitch:\n            return async () => (await import(\"./Data/flowGraphDataSwitchBlock\")).FlowGraphDataSwitchBlock;\n        default:\n            // check if the block is a custom block\n            if (CustomBlocks[blockName]) {\n                return CustomBlocks[blockName];\n            }\n            throw new Error(`Unknown block name ${blockName}`);\n    }\n}\n","import type { IAssetContainer } from \"core/IAssetContainer\";\nimport { blockFactory } from \"./Blocks/flowGraphBlockFactory\";\nimport type { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\nimport type { FlowGraph, IFlowGraphParseOptions } from \"./flowGraph\";\nimport type { FlowGraphBlock, IFlowGraphBlockParseOptions } from \"./flowGraphBlock\";\nimport type { FlowGraphContext, IFlowGraphContextParseOptions } from \"./flowGraphContext\";\nimport type { IFlowGraphCoordinatorParseOptions } from \"./flowGraphCoordinator\";\nimport { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\nimport { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\nimport { defaultValueParseFunction, needsPathConverter } from \"./serialization\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"./typeDefinitions\";\nimport type { Node } from \"core/node\";\nimport { getRichTypeByFlowGraphType, RichType } from \"./flowGraphRichTypes\";\nimport type { FlowGraphConnection } from \"./flowGraphConnection\";\n\n/**\n * Given a list of blocks, find an output data connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetDataOutConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphDataConnection<any> {\n    for (const block of blocks) {\n        for (const dataOut of block.dataOutputs) {\n            if (dataOut.uniqueId === uniqueId) {\n                return dataOut;\n            }\n        }\n    }\n    throw new Error(\"Could not find data out connection with unique id \" + uniqueId);\n}\n\n/**\n * Given a list of blocks, find an input signal connection that has a specific unique id\n * @param blocks a list of flow graph blocks\n * @param uniqueId the unique id of a connection\n * @returns the connection that has this unique id. throws an error if none was found\n */\nexport function GetSignalInConnectionByUniqueId(blocks: FlowGraphBlock[], uniqueId: string): FlowGraphSignalConnection {\n    for (const block of blocks) {\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalIn of block.signalInputs) {\n                if (signalIn.uniqueId === uniqueId) {\n                    return signalIn;\n                }\n            }\n        }\n    }\n    throw new Error(\"Could not find signal in connection with unique id \" + uniqueId);\n}\n\n/**\n * Parses a serialized coordinator.\n * @param serializedObject the object to parse\n * @param options the options to use when parsing\n * @returns the parsed coordinator\n */\nexport async function ParseCoordinatorAsync(serializedObject: any, options: IFlowGraphCoordinatorParseOptions) {\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    const coordinator = new FlowGraphCoordinator({ scene: options.scene });\n\n    if (serializedObject.dispatchEventsSynchronously) {\n        coordinator.dispatchEventsSynchronously = serializedObject.dispatchEventsSynchronously;\n    }\n\n    await options.scene.whenReadyAsync();\n    // if custom default values are defined, set them in the global context\n    if (serializedObject._defaultValues) {\n        for (const key in serializedObject._defaultValues) {\n            // key is the FlowGraphType, value is the default value\n            const value = serializedObject._defaultValues[key];\n            getRichTypeByFlowGraphType(key).defaultValue = value;\n        }\n    }\n    // async-parse the flow graphs. This can be done in parallel\n    await Promise.all(\n        serializedObject._flowGraphs?.map(\n            async (serializedGraph: any) => await ParseFlowGraphAsync(serializedGraph, { coordinator, valueParseFunction, pathConverter: options.pathConverter })\n        )\n    );\n    return coordinator;\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @returns the parsed graph\n */\nexport async function ParseFlowGraphAsync(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions): Promise<FlowGraph> {\n    // get all classes types needed for the blocks using the block factory\n    const resolvedClasses = await Promise.all(\n        serializationObject.allBlocks.map(async (serializedBlock) => {\n            const classFactory = blockFactory(serializedBlock.className as FlowGraphBlockNames);\n            return await classFactory();\n        })\n    );\n    // async will be used when we start using the block async factory\n    return ParseFlowGraph(serializationObject, options, resolvedClasses);\n}\n\n/**\n * Parses a graph from a given serialization object\n * @param serializationObject the object where the values are written\n * @param options options for parsing the graph\n * @param resolvedClasses the resolved classes for the blocks\n * @returns the parsed graph\n */\nexport function ParseFlowGraph(serializationObject: ISerializedFlowGraph, options: IFlowGraphParseOptions, resolvedClasses: (typeof FlowGraphBlock)[]) {\n    const graph = options.coordinator.createGraph();\n    const blocks: FlowGraphBlock[] = [];\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    // Parse all blocks\n    // for (const serializedBlock of serializationObject.allBlocks) {\n    for (let i = 0; i < serializationObject.allBlocks.length; i++) {\n        const serializedBlock = serializationObject.allBlocks[i];\n        const block = ParseFlowGraphBlockWithClassType(\n            serializedBlock,\n            { scene: options.coordinator.config.scene, pathConverter: options.pathConverter, assetsContainer: options.coordinator.config.scene, valueParseFunction },\n            resolvedClasses[i]\n        );\n        blocks.push(block);\n        if (block instanceof FlowGraphEventBlock) {\n            graph.addEventBlock(block);\n        }\n    }\n    // After parsing all blocks, connect them\n    for (const block of blocks) {\n        for (const dataIn of block.dataInputs) {\n            for (const serializedConnection of dataIn.connectedPointIds) {\n                const connection = GetDataOutConnectionByUniqueId(blocks, serializedConnection);\n                dataIn.connectTo(connection);\n            }\n        }\n        if (block instanceof FlowGraphExecutionBlock) {\n            for (const signalOut of block.signalOutputs) {\n                for (const serializedConnection of signalOut.connectedPointIds) {\n                    const connection = GetSignalInConnectionByUniqueId(blocks, serializedConnection);\n                    signalOut.connectTo(connection);\n                }\n            }\n        }\n    }\n    for (const serializedContext of serializationObject.executionContexts) {\n        ParseFlowGraphContext(serializedContext, { graph, valueParseFunction }, serializationObject.rightHanded);\n    }\n    return graph;\n}\n\n/**\n * Parses a context\n * @param serializationObject the object containing the context serialization values\n * @param options the options for parsing the context\n * @param rightHanded whether the serialized data is right handed\n * @returns\n */\nexport function ParseFlowGraphContext(serializationObject: ISerializedFlowGraphContext, options: IFlowGraphContextParseOptions, rightHanded?: boolean): FlowGraphContext {\n    const result = options.graph.createContext();\n    if (serializationObject.enableLogging) {\n        result.enableLogging = true;\n    }\n    result.treatDataAsRightHanded = rightHanded || false;\n    const valueParseFunction = options.valueParseFunction ?? defaultValueParseFunction;\n    result.uniqueId = serializationObject.uniqueId;\n    const scene = result.getScene();\n    // check if assets context is available\n    if (serializationObject._assetsContext) {\n        const ac = serializationObject._assetsContext;\n        const assetsContext: IAssetContainer = {\n            meshes: ac.meshes?.map((m: string) => scene.getMeshById(m)),\n            lights: ac.lights?.map((l: string) => scene.getLightByName(l)),\n            cameras: ac.cameras?.map((c: string) => scene.getCameraByName(c)),\n            materials: ac.materials?.map((m: string) => scene.getMaterialById(m)),\n            textures: ac.textures?.map((t: string) => scene.getTextureByName(t)),\n            animations: ac.animations?.map((a: string) => scene.animations.find((anim) => anim.name === a)),\n            skeletons: ac.skeletons?.map((s: string) => scene.getSkeletonByName(s)),\n            particleSystems: ac.particleSystems?.map((ps: string) => scene.getParticleSystemById(ps)),\n            animationGroups: ac.animationGroups?.map((ag: string) => scene.getAnimationGroupByName(ag)),\n            transformNodes: ac.transformNodes?.map((tn: string) => scene.getTransformNodeById(tn)),\n            rootNodes: [],\n            multiMaterials: [],\n            morphTargetManagers: [],\n            geometries: [],\n            actionManagers: [],\n            environmentTexture: null,\n            postProcesses: [],\n            sounds: null,\n            effectLayers: [],\n            layers: [],\n            reflectionProbes: [],\n            lensFlareSystems: [],\n            proceduralTextures: [],\n            getNodes: function (): Array<Node> {\n                throw new Error(\"Function not implemented.\");\n            },\n        };\n        result.assetsContext = assetsContext;\n    }\n    for (const key in serializationObject._userVariables) {\n        const value = valueParseFunction(key, serializationObject._userVariables, result.assetsContext, scene);\n        result.userVariables[key] = value;\n    }\n    for (const key in serializationObject._connectionValues) {\n        const value = valueParseFunction(key, serializationObject._connectionValues, result.assetsContext, scene);\n        result._setConnectionValueByKey(key, value);\n    }\n\n    return result;\n}\n\n/**\n * Parses a block from a serialization object\n * This function is async due to the factory method that is used to create the block's class. If you load the class externally use ParseBlockWithClassType\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @returns the parsed block\n */\nexport async function ParseBlockAsync(serializationObject: ISerializedFlowGraphBlock, parseOptions: IFlowGraphBlockParseOptions): Promise<FlowGraphBlock> {\n    const classFactory = blockFactory(serializationObject.className as FlowGraphBlockNames);\n    const classType = await classFactory();\n    return ParseFlowGraphBlockWithClassType(serializationObject, parseOptions, classType);\n}\n\n/**\n * Parses a block from a serialization object\n * @param serializationObject the object to parse from\n * @param parseOptions options for parsing the block\n * @param classType the class type of the block. This is used when the class is not loaded asynchronously\n * @returns the parsed block\n */\nexport function ParseFlowGraphBlockWithClassType(\n    serializationObject: ISerializedFlowGraphBlock,\n    parseOptions: IFlowGraphBlockParseOptions,\n    classType: typeof FlowGraphBlock\n): FlowGraphBlock {\n    const parsedConfig: any = {};\n    const valueParseFunction = parseOptions.valueParseFunction ?? defaultValueParseFunction;\n    if (serializationObject.config) {\n        for (const key in serializationObject.config) {\n            parsedConfig[key] = valueParseFunction(key, serializationObject.config, parseOptions.assetsContainer || parseOptions.scene, parseOptions.scene);\n        }\n    }\n    if (needsPathConverter(serializationObject.className)) {\n        if (!parseOptions.pathConverter) {\n            throw new Error(\"Path converter is required for this block\");\n        }\n        parsedConfig.pathConverter = parseOptions.pathConverter;\n    }\n    const obj = new classType(parsedConfig);\n    obj.uniqueId = serializationObject.uniqueId;\n    for (let i = 0; i < serializationObject.dataInputs.length; i++) {\n        const dataInput = obj.getDataInput(serializationObject.dataInputs[i].name);\n        if (dataInput) {\n            dataInput.deserialize(serializationObject.dataInputs[i]);\n        } else {\n            throw new Error(\"Could not find data input with name \" + serializationObject.dataInputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    for (let i = 0; i < serializationObject.dataOutputs.length; i++) {\n        const dataOutput = obj.getDataOutput(serializationObject.dataOutputs[i].name);\n        if (dataOutput) {\n            dataOutput.deserialize(serializationObject.dataOutputs[i]);\n        } else {\n            throw new Error(\"Could not find data output with name \" + serializationObject.dataOutputs[i].name + \" in block \" + serializationObject.className);\n        }\n    }\n    obj.metadata = serializationObject.metadata;\n    obj.deserialize && obj.deserialize(serializationObject);\n    return obj;\n}\n\n/**\n * Parses a connection from an object\n * @param serializationObject the object to parse from.\n * @param ownerBlock the block that owns the connection.\n * @param classType the class type of the connection.\n * @returns the parsed connection.\n */\nexport function ParseGraphConnectionWithClassType<BlockT extends FlowGraphBlock>(serializationObject: any = {}, ownerBlock: BlockT, classType: typeof FlowGraphConnection) {\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a data connection from a serialized object.\n * @param serializationObject the object to parse from\n * @param ownerBlock the block that owns the connection\n * @param classType the class type of the data connection\n * @returns the parsed connection\n */\nexport function ParseGraphDataConnection(serializationObject: any, ownerBlock: FlowGraphBlock, classType: typeof FlowGraphDataConnection): FlowGraphDataConnection<any> {\n    const richType = ParseRichType(serializationObject.richType);\n    const defaultValue = serializationObject.defaultValue;\n    const connection = new classType(serializationObject.name, serializationObject._connectionType, ownerBlock, richType, defaultValue, !!serializationObject._optional);\n    connection.deserialize(serializationObject);\n    return connection;\n}\n\n/**\n * Parses a rich type from a serialization object.\n * @param serializationObject a serialization object\n * @returns the parsed rich type\n */\nfunction ParseRichType(serializationObject: any): RichType<any> {\n    return new RichType(serializationObject.typeName, serializationObject.defaultValue);\n}\n","import type { IKHRInteractivity_Graph, IKHRInteractivity_Node, IKHRInteractivity_OutputSocketReference, IKHRInteractivity_Variable } from \"babylonjs-gltf2interface\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport type { IGLTFToFlowGraphMapping } from \"./declarationMapper\";\nimport { getMappingForDeclaration, getMappingForFullOperationName } from \"./declarationMapper\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraph, ISerializedFlowGraphBlock, ISerializedFlowGraphConnection, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport { RandomGUID } from \"core/Misc/guid\";\nimport type { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { FlowGraphConnectionType } from \"core/FlowGraph/flowGraphConnection\";\nimport { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport interface InteractivityEvent {\n    eventId: string;\n    eventData?: {\n        eventData: boolean;\n        id: string;\n        type: string;\n        value?: any;\n    }[];\n}\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport const gltfTypeToBabylonType: {\n    [key: string]: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" };\n} = {\n    float: { length: 1, flowGraphType: FlowGraphTypes.Number, elementType: \"number\" },\n    bool: { length: 1, flowGraphType: FlowGraphTypes.Boolean, elementType: \"boolean\" },\n    float2: { length: 2, flowGraphType: FlowGraphTypes.Vector2, elementType: \"number\" },\n    float3: { length: 3, flowGraphType: FlowGraphTypes.Vector3, elementType: \"number\" },\n    float4: { length: 4, flowGraphType: FlowGraphTypes.Vector4, elementType: \"number\" },\n    float4x4: { length: 16, flowGraphType: FlowGraphTypes.Matrix, elementType: \"number\" },\n    float2x2: { length: 4, flowGraphType: FlowGraphTypes.Matrix2D, elementType: \"number\" },\n    float3x3: { length: 9, flowGraphType: FlowGraphTypes.Matrix3D, elementType: \"number\" },\n    int: { length: 1, flowGraphType: FlowGraphTypes.Integer, elementType: \"number\" },\n};\n\nexport class InteractivityGraphToFlowGraphParser {\n    /**\n     * Note - the graph should be rejected if the same type is defined twice.\n     * We currently don't validate that.\n     */\n    private _types: { length: number; flowGraphType: FlowGraphTypes; elementType: \"number\" | \"boolean\" }[] = [];\n    private _mappings: { flowGraphMapping: IGLTFToFlowGraphMapping; fullOperationName: string }[] = [];\n    private _staticVariables: { type: FlowGraphTypes; value: any[] }[] = [];\n    private _events: InteractivityEvent[] = [];\n    private _internalEventsCounter: number = 0;\n    private _nodes: { blocks: ISerializedFlowGraphBlock[]; fullOperationName: string }[] = [];\n\n    constructor(\n        private _interactivityGraph: IKHRInteractivity_Graph,\n        private _gltf: IGLTF,\n        public _animationTargetFps: number = 60\n    ) {\n        // start with types\n        this._parseTypes();\n        // continue with declarations\n        this._parseDeclarations();\n        this._parseVariables();\n        this._parseEvents();\n        this._parseNodes();\n    }\n\n    public get arrays() {\n        return {\n            types: this._types,\n            mappings: this._mappings,\n            staticVariables: this._staticVariables,\n            events: this._events,\n            nodes: this._nodes,\n        };\n    }\n\n    private _parseTypes() {\n        if (!this._interactivityGraph.types) {\n            return;\n        }\n        for (const type of this._interactivityGraph.types) {\n            this._types.push(gltfTypeToBabylonType[type.signature]);\n        }\n    }\n\n    private _parseDeclarations() {\n        if (!this._interactivityGraph.declarations) {\n            return;\n        }\n        for (const declaration of this._interactivityGraph.declarations) {\n            // make sure we have the mapping for this operation\n            const mapping = getMappingForDeclaration(declaration);\n            // mapping is defined, because we generate an empty mapping if it's not found\n            if (!mapping) {\n                Logger.Error([\"No mapping found for declaration\", declaration]);\n                throw new Error(\"Error parsing declarations\");\n            }\n            this._mappings.push({\n                flowGraphMapping: mapping,\n                fullOperationName: declaration.extension ? declaration.op + \":\" + declaration.extension : declaration.op,\n            });\n        }\n    }\n\n    private _parseVariables() {\n        if (!this._interactivityGraph.variables) {\n            return;\n        }\n        for (const variable of this._interactivityGraph.variables) {\n            const parsed = this._parseVariable(variable);\n            // set the default values here\n            this._staticVariables.push(parsed);\n        }\n    }\n\n    private _parseVariable(variable: IKHRInteractivity_Variable, dataTransform?: (value: any, parser: InteractivityGraphToFlowGraphParser) => any) {\n        const type = this._types[variable.type];\n        if (!type) {\n            Logger.Error([\"No type found for variable\", variable]);\n            throw new Error(\"Error parsing variables\");\n        }\n        if (variable.value) {\n            if (variable.value.length !== type.length) {\n                Logger.Error([\"Invalid value length for variable\", variable, type]);\n                throw new Error(\"Error parsing variables\");\n            }\n        }\n        const value = variable.value || [];\n        if (!value.length) {\n            switch (type.flowGraphType) {\n                case FlowGraphTypes.Boolean:\n                    value.push(false);\n                    break;\n                case FlowGraphTypes.Integer:\n                    value.push(0);\n                    break;\n                case FlowGraphTypes.Number:\n                    value.push(NaN);\n                    break;\n                case FlowGraphTypes.Vector2:\n                    value.push(NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector3:\n                    value.push(NaN, NaN, NaN);\n                    break;\n                case FlowGraphTypes.Vector4:\n                case FlowGraphTypes.Matrix2D:\n                case FlowGraphTypes.Quaternion:\n                    value.fill(NaN, 0, 4);\n                    break;\n                case FlowGraphTypes.Matrix:\n                    value.fill(NaN, 0, 16);\n                    break;\n                case FlowGraphTypes.Matrix3D:\n                    value.fill(NaN, 0, 9);\n                    break;\n                default:\n                    break;\n            }\n        }\n        // in case of NaN, Infinity, we need to parse the string to the object itself\n        if (type.elementType === \"number\" && typeof value[0] === \"string\") {\n            value[0] = parseFloat(value[0]);\n        }\n        return { type: type.flowGraphType, value: dataTransform ? dataTransform(value, this) : value };\n    }\n\n    private _parseEvents() {\n        if (!this._interactivityGraph.events) {\n            return;\n        }\n        for (const event of this._interactivityGraph.events) {\n            const converted: InteractivityEvent = {\n                eventId: event.id || \"internalEvent_\" + this._internalEventsCounter++,\n            };\n            if (event.values) {\n                converted.eventData = Object.keys(event.values).map((key) => {\n                    const eventValue = event.values?.[key];\n                    if (!eventValue) {\n                        Logger.Error([\"No value found for event key\", key]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const type = this._types[eventValue.type];\n                    if (!type) {\n                        Logger.Error([\"No type found for event value\", eventValue]);\n                        throw new Error(\"Error parsing events\");\n                    }\n                    const value = typeof eventValue.value !== \"undefined\" ? this._parseVariable(eventValue) : undefined;\n                    return {\n                        id: key,\n                        type: type.flowGraphType,\n                        eventData: true,\n                        value,\n                    };\n                });\n            }\n            this._events.push(converted);\n        }\n    }\n\n    private _parseNodes() {\n        if (!this._interactivityGraph.nodes) {\n            return;\n        }\n        for (const node of this._interactivityGraph.nodes) {\n            // some validation\n            if (typeof node.declaration !== \"number\") {\n                Logger.Error([\"No declaration found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            const mapping = this._mappings[node.declaration];\n            if (!mapping) {\n                Logger.Error([\"No mapping found for node\", node]);\n                throw new Error(\"Error parsing nodes\");\n            }\n            if (mapping.flowGraphMapping.validation) {\n                const validationResult = mapping.flowGraphMapping.validation(node, this._interactivityGraph, this._gltf);\n                if (!validationResult.valid) {\n                    throw new Error(`Error validating interactivity node ${this._interactivityGraph.declarations?.[node.declaration].op} - ${validationResult.error}`);\n                }\n            }\n            const blocks: ISerializedFlowGraphBlock[] = [];\n            // create block(s) for this node using the mapping\n            for (const blockType of mapping.flowGraphMapping.blocks) {\n                const block = this._getEmptyBlock(blockType, mapping.fullOperationName);\n                this._parseNodeConfiguration(node, block, mapping.flowGraphMapping, blockType);\n                blocks.push(block);\n            }\n            this._nodes.push({ blocks, fullOperationName: mapping.fullOperationName });\n        }\n    }\n\n    private _getEmptyBlock(className: string, type: string): ISerializedFlowGraphBlock {\n        return {\n            uniqueId: RandomGUID(),\n            className,\n            dataInputs: [],\n            dataOutputs: [],\n            signalInputs: [],\n            signalOutputs: [],\n            config: {},\n            type,\n            metadata: {},\n        };\n    }\n\n    private _parseNodeConfiguration(node: IKHRInteractivity_Node, block: ISerializedFlowGraphBlock, nodeMapping: IGLTFToFlowGraphMapping, blockType: FlowGraphBlockNames | string) {\n        const gltfConfiguration = node.configuration;\n        if (gltfConfiguration) {\n            for (const key in gltfConfiguration) {\n                const gltfProperty = gltfConfiguration[key];\n                if (!gltfProperty) {\n                    throw new Error(\"Error parsing node configuration\");\n                }\n\n                const propertyMapping = nodeMapping.configuration?.[key];\n                const belongsToBlock = propertyMapping && propertyMapping.toBlock ? propertyMapping.toBlock === blockType : nodeMapping.blocks.indexOf(blockType) === 0;\n                if (belongsToBlock) {\n                    let value = propertyMapping?.defaultValue;\n                    if (gltfProperty?.value) {\n                        value = gltfProperty.value;\n                    }\n\n                    if (!propertyMapping?.isArray) {\n                        if (value.length !== 1) {\n                            Logger.Warn(`Invalid non-array value length: ${value.length}`);\n                        }\n\n                        value = value[0];\n                    }\n\n                    if (propertyMapping?.dataTransformer) {\n                        value = propertyMapping.dataTransformer(value, this);\n                    }\n\n                    if (value !== undefined) {\n                        // Update the flow graph block config.\n                        block.config[propertyMapping?.name || key] = {\n                            value: value,\n                        };\n                    }\n                }\n            }\n        }\n    }\n\n    private _parseNodeConnections(context: ISerializedFlowGraphContext) {\n        for (let i = 0; i < this._nodes.length; i++) {\n            // get the corresponding gltf node\n            const gltfNode = this._interactivityGraph.nodes?.[i];\n            if (!gltfNode) {\n                // should never happen but let's still check\n                Logger.Error([\"No node found for interactivity node\", this._nodes[i]]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowGraphBlocks = this._nodes[i];\n            const outputMapper = this._mappings[gltfNode.declaration];\n            // validate\n            if (!outputMapper) {\n                Logger.Error([\"No mapping found for node\", gltfNode]);\n                throw new Error(\"Error parsing node connections\");\n            }\n            const flowsFromGLTF = gltfNode.flows || {};\n            const flowsKeys = Object.keys(flowsFromGLTF).sort(); // sorting as some operations require sorted keys\n            // connect the flows\n            for (const flowKey of flowsKeys) {\n                const flow = flowsFromGLTF[flowKey];\n                const flowMapping = outputMapper.flowGraphMapping.outputs?.flows?.[flowKey];\n                const socketOutName = flowMapping?.name || flowKey;\n                // create a serialized socket\n                const socketOut = this._createNewSocketConnection(socketOutName, true);\n                const block = (flowMapping && flowMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === flowMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.signalOutputs.push(socketOut);\n                // get the input node of this block\n                const inputNodeId = flow.node;\n                const nodeIn = this._nodes[inputNodeId];\n                if (!nodeIn) {\n                    Logger.Error([\"No node found for input node id\", inputNodeId]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                // get the mapper for the input node - in case it mapped to multiple blocks\n                const inputMapper = getMappingForFullOperationName(nodeIn.fullOperationName);\n                if (!inputMapper) {\n                    Logger.Error([\"No mapping found for input node\", nodeIn]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                let flowInMapping = inputMapper.inputs?.flows?.[flow.socket || \"in\"];\n                let arrayMapping = false;\n                if (!flowInMapping) {\n                    for (const key in inputMapper.inputs?.flows) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            flowInMapping = inputMapper.inputs?.flows?.[key];\n                        }\n                    }\n                }\n                const nodeInSocketName = flowInMapping ? (arrayMapping ? flowInMapping.name.replace(\"$1\", flow.socket || \"\") : flowInMapping.name) : flow.socket || \"in\";\n                const inputBlock = (flowInMapping && flowInMapping.toBlock && nodeIn.blocks.find((b) => b.className === flowInMapping.toBlock)) || nodeIn.blocks[0];\n                // in all of the flow graph input connections, find the one with the same name as the socket\n                let socketIn = inputBlock.signalInputs.find((s) => s.name === nodeInSocketName);\n                // if the socket doesn't exist, create the input socket for the connection\n                if (!socketIn) {\n                    socketIn = this._createNewSocketConnection(nodeInSocketName);\n                    inputBlock.signalInputs.push(socketIn);\n                }\n                // connect the sockets\n                socketIn.connectedPointIds.push(socketOut.uniqueId);\n                socketOut.connectedPointIds.push(socketIn.uniqueId);\n            }\n            // connect the values\n            const valuesFromGLTF = gltfNode.values || {};\n            const valuesKeys = Object.keys(valuesFromGLTF);\n            for (const valueKey of valuesKeys) {\n                const value = valuesFromGLTF[valueKey];\n                let valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[valueKey];\n                let arrayMapping = false;\n                if (!valueMapping) {\n                    for (const key in outputMapper.flowGraphMapping.inputs?.values) {\n                        if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                            arrayMapping = true;\n                            valueMapping = outputMapper.flowGraphMapping.inputs?.values?.[key];\n                        }\n                    }\n                }\n                const socketInName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", valueKey) : valueMapping.name) : valueKey;\n                // create a serialized socket\n                const socketIn = this._createNewSocketConnection(socketInName);\n                const block = (valueMapping && valueMapping.toBlock && flowGraphBlocks.blocks.find((b) => b.className === valueMapping.toBlock)) || flowGraphBlocks.blocks[0];\n                block.dataInputs.push(socketIn);\n                if ((value as IKHRInteractivity_Variable).value !== undefined) {\n                    const convertedValue = this._parseVariable(value as IKHRInteractivity_Variable, valueMapping && valueMapping.dataTransformer);\n                    context._connectionValues[socketIn.uniqueId] = convertedValue;\n                } else if (typeof (value as IKHRInteractivity_OutputSocketReference).node !== \"undefined\") {\n                    const nodeOutId = (value as IKHRInteractivity_OutputSocketReference).node;\n                    const nodeOutSocketName = (value as IKHRInteractivity_OutputSocketReference).socket || \"value\";\n                    const nodeOut = this._nodes[nodeOutId];\n                    if (!nodeOut) {\n                        Logger.Error([\"No node found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    const outputMapper = getMappingForFullOperationName(nodeOut.fullOperationName);\n                    if (!outputMapper) {\n                        Logger.Error([\"No mapping found for output socket reference\", value]);\n                        throw new Error(\"Error parsing node connections\");\n                    }\n                    let valueMapping = outputMapper.outputs?.values?.[nodeOutSocketName];\n                    let arrayMapping = false;\n                    // check if there is an array mapping defined\n                    if (!valueMapping) {\n                        // search for a value mapping that has an array mapping\n                        for (const key in outputMapper.outputs?.values) {\n                            if (key.startsWith(\"[\") && key.endsWith(\"]\")) {\n                                arrayMapping = true;\n                                valueMapping = outputMapper.outputs?.values?.[key];\n                            }\n                        }\n                    }\n                    const socketOutName = valueMapping ? (arrayMapping ? valueMapping.name.replace(\"$1\", nodeOutSocketName) : valueMapping?.name) : nodeOutSocketName;\n                    const outBlock = (valueMapping && valueMapping.toBlock && nodeOut.blocks.find((b) => b.className === valueMapping.toBlock)) || nodeOut.blocks[0];\n                    let socketOut = outBlock.dataOutputs.find((s) => s.name === socketOutName);\n                    // if the socket doesn't exist, create it\n                    if (!socketOut) {\n                        socketOut = this._createNewSocketConnection(socketOutName, true);\n                        outBlock.dataOutputs.push(socketOut);\n                    }\n                    // connect the sockets\n                    socketIn.connectedPointIds.push(socketOut.uniqueId);\n                    socketOut.connectedPointIds.push(socketIn.uniqueId);\n                } else {\n                    Logger.Error([\"Invalid value for value connection\", value]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n            }\n\n            // inter block connections\n            if (outputMapper.flowGraphMapping.interBlockConnectors) {\n                for (const connector of outputMapper.flowGraphMapping.interBlockConnectors) {\n                    const input = connector.input;\n                    const output = connector.output;\n                    const isVariable = connector.isVariable;\n                    this._connectFlowGraphNodes(input, output, flowGraphBlocks.blocks[connector.inputBlockIndex], flowGraphBlocks.blocks[connector.outputBlockIndex], isVariable);\n                }\n            }\n\n            if (outputMapper.flowGraphMapping.extraProcessor) {\n                const declaration = this._interactivityGraph.declarations?.[gltfNode.declaration];\n                if (!declaration) {\n                    Logger.Error([\"No declaration found for extra processor\", gltfNode]);\n                    throw new Error(\"Error parsing node connections\");\n                }\n                flowGraphBlocks.blocks = outputMapper.flowGraphMapping.extraProcessor(\n                    gltfNode,\n                    declaration,\n                    outputMapper.flowGraphMapping,\n                    this,\n                    flowGraphBlocks.blocks,\n                    context,\n                    this._gltf\n                );\n            }\n        }\n    }\n\n    private _createNewSocketConnection(name: string, isOutput?: boolean): ISerializedFlowGraphConnection {\n        return {\n            uniqueId: RandomGUID(),\n            name,\n            _connectionType: isOutput ? FlowGraphConnectionType.Output : FlowGraphConnectionType.Input,\n            connectedPointIds: [],\n        };\n    }\n\n    private _connectFlowGraphNodes(input: string, output: string, serializedInput: ISerializedFlowGraphBlock, serializedOutput: ISerializedFlowGraphBlock, isVariable?: boolean) {\n        const inputArray = isVariable ? serializedInput.dataInputs : serializedInput.signalInputs;\n        const outputArray = isVariable ? serializedOutput.dataOutputs : serializedOutput.signalOutputs;\n        const inputConnection = inputArray.find((s) => s.name === input) || this._createNewSocketConnection(input);\n        const outputConnection = outputArray.find((s) => s.name === output) || this._createNewSocketConnection(output, true);\n        // of not found add it to the array\n        if (!inputArray.find((s) => s.name === input)) {\n            inputArray.push(inputConnection);\n        }\n        if (!outputArray.find((s) => s.name === output)) {\n            outputArray.push(outputConnection);\n        }\n        // connect the sockets\n        inputConnection.connectedPointIds.push(outputConnection.uniqueId);\n        outputConnection.connectedPointIds.push(inputConnection.uniqueId);\n    }\n\n    public getVariableName(index: number) {\n        return \"staticVariable_\" + index;\n    }\n\n    public serializeToFlowGraph(): ISerializedFlowGraph {\n        const context: ISerializedFlowGraphContext = {\n            uniqueId: RandomGUID(),\n            _userVariables: {},\n            _connectionValues: {},\n        };\n        this._parseNodeConnections(context);\n        for (let i = 0; i < this._staticVariables.length; i++) {\n            const variable = this._staticVariables[i];\n            context._userVariables[this.getVariableName(i)] = variable;\n        }\n\n        const allBlocks = this._nodes.reduce((acc, val) => acc.concat(val.blocks), [] as ISerializedFlowGraphBlock[]);\n\n        return {\n            rightHanded: true,\n            allBlocks,\n            executionContexts: [context],\n        };\n    }\n}\n","/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { IKHRInteractivity } from \"babylonjs-gltf2interface\";\r\nimport type { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\nimport { ParseFlowGraphAsync } from \"core/FlowGraph/flowGraphParser\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\r\nimport { AddObjectAccessorToKey, GetPathToObjectConverter } from \"./objectModelMapping\";\r\nimport { InteractivityGraphToFlowGraphParser } from \"./KHR_interactivity/interactivityGraphParser\";\r\nimport { addToBlockFactory } from \"core/FlowGraph/Blocks/flowGraphBlockFactory\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IAnimation } from \"../glTFLoaderInterfaces\";\r\n\r\nconst NAME = \"KHR_interactivity\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_interactivity extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_interactivity\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * Loader extension for KHR_interactivity\r\n */\r\nexport class KHR_interactivity implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _pathConverter?: GLTFPathToObjectConverter<any, any, any>;\r\n\r\n    /**\r\n     * @internal\r\n     * @param _loader\r\n     */\r\n    constructor(private _loader: GLTFLoader) {\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        this._pathConverter = GetPathToObjectConverter(this._loader.gltf);\r\n        // avoid starting animations automatically.\r\n        _loader._skipStartAnimationStep = true;\r\n\r\n        // Update object model with new pointers\r\n\r\n        const scene = _loader.babylonScene;\r\n        if (scene) {\r\n            _AddInteractivityObjectModel(scene);\r\n        }\r\n    }\r\n\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        delete this._pathConverter;\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/no-misused-promises\r\n    public async onReady(): Promise<void> {\r\n        if (!this._loader.babylonScene || !this._pathConverter) {\r\n            return;\r\n        }\r\n        const scene = this._loader.babylonScene;\r\n        const interactivityDefinition = this._loader.gltf.extensions?.KHR_interactivity as IKHRInteractivity;\r\n        if (!interactivityDefinition) {\r\n            // This can technically throw, but it's not a critical error\r\n            return;\r\n        }\r\n\r\n        const coordinator = new FlowGraphCoordinator({ scene });\r\n        coordinator.dispatchEventsSynchronously = false; // glTF interactivity dispatches events asynchronously\r\n        const graphs = interactivityDefinition.graphs.map((graph) => {\r\n            const parser = new InteractivityGraphToFlowGraphParser(graph, this._loader.gltf, this._loader.parent.targetFps);\r\n            return parser.serializeToFlowGraph();\r\n        });\r\n        // parse each graph async\r\n        await Promise.all(graphs.map(async (graph) => await ParseFlowGraphAsync(graph, { coordinator, pathConverter: this._pathConverter })));\r\n\r\n        coordinator.start();\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * populates the object model with the interactivity extension\r\n */\r\nexport function _AddInteractivityObjectModel(scene: Scene) {\r\n    // Note - all of those are read-only, as per the specs!\r\n\r\n    // active camera rotation\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/rotation\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Quaternion(NaN, NaN, NaN, NaN);\r\n            }\r\n            const quat = Quaternion.FromRotationMatrix(scene.activeCamera.getWorldMatrix()).normalize();\r\n            if (!scene.useRightHandedSystem) {\r\n                quat.w *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n                quat.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return quat;\r\n        },\r\n        type: \"Quaternion\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n    // activeCamera position\r\n    AddObjectAccessorToKey(\"/extensions/KHR_interactivity/?/activeCamera/position\", {\r\n        get: () => {\r\n            if (!scene.activeCamera) {\r\n                return new Vector3(NaN, NaN, NaN);\r\n            }\r\n            const pos = scene.activeCamera.getWorldMatrix().getTranslation(); // not global position\r\n            if (!scene.useRightHandedSystem) {\r\n                pos.x *= -1; // glTF uses right-handed system, while babylon uses left-handed\r\n            }\r\n            return pos;\r\n        },\r\n        type: \"Vector3\",\r\n        getTarget: () => scene.activeCamera,\r\n    });\r\n\r\n    // /animations/{} pointers:\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/isPlaying\", {\r\n        get: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup?.isPlaying ?? false;\r\n        },\r\n        type: \"boolean\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/minTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.from ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/maxTime\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.to ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    // playhead\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/playhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n    //virtualPlayhead - TODO, do we support this property in our animations? getCurrentFrame  is the only method we have for this.\r\n    AddObjectAccessorToKey(\"/animations/{}/extensions/KHR_interactivity/virtualPlayhead\", {\r\n        get: (animation: IAnimation) => {\r\n            return (animation._babylonAnimationGroup?.getCurrentFrame() ?? 0) / 60; // fixed factor for duration-to-frames conversion\r\n        },\r\n        type: \"number\",\r\n        getTarget: (animation: IAnimation) => {\r\n            return animation._babylonAnimationGroup;\r\n        },\r\n    });\r\n}\r\n\r\n// Register flow graph blocks. Do it here so they are available when the extension is enabled.\r\naddToBlockFactory(NAME, \"FlowGraphGLTFDataProvider\", async () => {\r\n    return (await import(\"./KHR_interactivity/flowGraphGLTFDataProvider\")).FlowGraphGLTFDataProvider;\r\n});\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_interactivity(loader));\r\n","import type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { Matrix, Quaternion, Vector2, Vector3, Vector4 } from \"../Maths/math.vector\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraphBlockNames } from \"./Blocks/flowGraphBlockNames\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { FlowGraphTypes, getRichTypeByFlowGraphType } from \"./flowGraphRichTypes\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\n\r\nfunction IsMeshClassName(className: string) {\r\n    return (\r\n        className === \"Mesh\" ||\r\n        className === \"AbstractMesh\" ||\r\n        className === \"GroundMesh\" ||\r\n        className === \"InstanceMesh\" ||\r\n        className === \"LinesMesh\" ||\r\n        className === \"GoldbergMesh\" ||\r\n        className === \"GreasedLineMesh\" ||\r\n        className === \"TrailMesh\"\r\n    );\r\n}\r\n\r\nfunction IsVectorClassName(className: string) {\r\n    return (\r\n        className === FlowGraphTypes.Vector2 ||\r\n        className === FlowGraphTypes.Vector3 ||\r\n        className === FlowGraphTypes.Vector4 ||\r\n        className === FlowGraphTypes.Quaternion ||\r\n        className === FlowGraphTypes.Color3 ||\r\n        className === FlowGraphTypes.Color4\r\n    );\r\n}\r\n\r\nfunction IsMatrixClassName(className: string) {\r\n    return className === FlowGraphTypes.Matrix || className === FlowGraphTypes.Matrix2D || className === FlowGraphTypes.Matrix3D;\r\n}\r\n\r\nfunction IsAnimationGroupClassName(className: string) {\r\n    return className === \"AnimationGroup\";\r\n}\r\n\r\nfunction ParseVector(className: string, value: Array<number>, flipHandedness = false) {\r\n    if (className === FlowGraphTypes.Vector2) {\r\n        return Vector2.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector3) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n        }\r\n        return Vector3.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Vector4) {\r\n        return Vector4.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Quaternion) {\r\n        if (flipHandedness) {\r\n            value[2] *= -1;\r\n            value[3] *= -1;\r\n        }\r\n        return Quaternion.FromArray(value);\r\n    } else if (className === FlowGraphTypes.Color3) {\r\n        return new Color3(value[0], value[1], value[2]);\r\n    } else if (className === FlowGraphTypes.Color4) {\r\n        return new Color4(value[0], value[1], value[2], value[3]);\r\n    } else {\r\n        throw new Error(`Unknown vector class name ${className}`);\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that serializes values in a context object to a serialization object\r\n * @param key the key where the value should be stored in the serialization object\r\n * @param value the value to store\r\n * @param serializationObject the object where the value will be stored\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function defaultValueSerializationFunction(key: string, value: any, serializationObject: any) {\r\n    const className = value?.getClassName?.() ?? \"\";\r\n    if (IsVectorClassName(className) || IsMatrixClassName(className)) {\r\n        serializationObject[key] = {\r\n            value: value.asArray(),\r\n            className,\r\n        };\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        serializationObject[key] = {\r\n            value: value.value,\r\n            className,\r\n        };\r\n    } else {\r\n        if (className && (value.id || value.name)) {\r\n            serializationObject[key] = {\r\n                id: value.id,\r\n                name: value.name,\r\n                className,\r\n            };\r\n        } else {\r\n            // only if it is not an object\r\n            if (typeof value !== \"object\") {\r\n                serializationObject[key] = value;\r\n            } else {\r\n                throw new Error(`Could not serialize value ${value}`);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * The default function that parses values stored in a serialization object\r\n * @param key the key to the value that will be parsed\r\n * @param serializationObject the object that will be parsed\r\n * @param assetsContainer the assets container that will be used to find the objects\r\n * @param scene\r\n * @returns\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function defaultValueParseFunction(key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) {\r\n    const intermediateValue = serializationObject[key];\r\n    let finalValue;\r\n    const className = intermediateValue?.type ?? intermediateValue?.className;\r\n    if (IsMeshClassName(className)) {\r\n        let nodes: TransformNode[] = scene.meshes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        if (nodes.length === 0) {\r\n            nodes = scene.transformNodes.filter((m) => (intermediateValue.id ? m.id === intermediateValue.id : m.name === intermediateValue.name));\r\n        }\r\n        finalValue = intermediateValue.uniqueId ? nodes.find((m) => m.uniqueId === intermediateValue.uniqueId) : nodes[0];\r\n    } else if (IsVectorClassName(className)) {\r\n        finalValue = ParseVector(className, intermediateValue.value);\r\n    } else if (IsAnimationGroupClassName(className)) {\r\n        // do not use the scene.getAnimationGroupByName because it is possible that two AGs will have the same name\r\n        const ags = scene.animationGroups.filter((ag) => ag.name === intermediateValue.name);\r\n        // uniqueId changes on each load. this is used for the glTF loader, that uses serialization after the scene was loaded.\r\n        finalValue = ags.length === 1 ? ags[0] : ags.find((ag) => ag.uniqueId === intermediateValue.uniqueId);\r\n    } else if (className === FlowGraphTypes.Matrix) {\r\n        finalValue = Matrix.FromArray(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix2D) {\r\n        finalValue = new FlowGraphMatrix2D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Matrix3D) {\r\n        finalValue = new FlowGraphMatrix3D(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Integer) {\r\n        finalValue = FlowGraphInteger.FromValue(intermediateValue.value);\r\n    } else if (className === FlowGraphTypes.Number || className === FlowGraphTypes.String || className === FlowGraphTypes.Boolean) {\r\n        finalValue = intermediateValue.value[0];\r\n    } else if (intermediateValue && intermediateValue.value !== undefined) {\r\n        finalValue = intermediateValue.value;\r\n    } else {\r\n        if (Array.isArray(intermediateValue)) {\r\n            // configuration data of an event\r\n            finalValue = intermediateValue.reduce((acc, val) => {\r\n                if (!val.eventData) {\r\n                    return acc;\r\n                }\r\n                acc[val.id] = {\r\n                    type: getRichTypeByFlowGraphType(val.type),\r\n                };\r\n                if (typeof val.value !== \"undefined\") {\r\n                    acc[val.id].value = defaultValueParseFunction(\"value\", val, assetsContainer, scene);\r\n                }\r\n                return acc;\r\n            }, {});\r\n        } else {\r\n            finalValue = intermediateValue;\r\n        }\r\n    }\r\n    return finalValue;\r\n}\r\n\r\n/**\r\n * Given a name of a flow graph block class, return if this\r\n * class needs to be created with a path converter. Used in\r\n * parsing.\r\n * @param className the name of the flow graph block class\r\n * @returns a boolean indicating if the class needs a path converter\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function needsPathConverter(className: string) {\r\n    // I am not using the ClassName property here because it was causing a circular dependency\r\n    // that jest didn't like!\r\n    return className === FlowGraphBlockNames.JsonPointerParser;\r\n}\r\n","import type { Nullable } from \"core/types\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphConnection, FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { RichType } from \"./flowGraphRichTypes\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\n/**\r\n * Represents a connection point for data.\r\n * An unconnected input point can have a default value.\r\n * An output point will only have a value if it is connected to an input point. Furthermore,\r\n * if the point belongs to a \"function\" node, the node will run its function to update the value.\r\n */\r\nexport class FlowGraphDataConnection<T> extends FlowGraphConnection<FlowGraphBlock, FlowGraphDataConnection<T>> {\r\n    private _isDisabled: boolean = false;\r\n    /**\r\n     * This is used for debugging purposes! It is the last value that was set to this connection with ANY context.\r\n     * Do not use this value for anything else, as it might be wrong if used in a different context.\r\n     */\r\n    private _lastValue: Nullable<T> = null;\r\n\r\n    /**\r\n     * a data transformer function, if needed.\r\n     * This can be used, for example, to force seconds into milliseconds output, if it makes sense in your case.\r\n     */\r\n    public dataTransformer: Nullable<(value: T) => T> = null;\r\n\r\n    /**\r\n     * An observable that is triggered when the value of the connection changes.\r\n     */\r\n    public onValueChangedObservable = new Observable<T>();\r\n    /**\r\n     * Create a new data connection point.\r\n     * @param name the name of the connection\r\n     * @param connectionType the type of the connection\r\n     * @param ownerBlock the block that owns this connection\r\n     * @param richType the type of the data in this block\r\n     * @param _defaultValue the default value of the connection\r\n     * @param _optional if the connection is optional\r\n     */\r\n    public constructor(\r\n        name: string,\r\n        connectionType: FlowGraphConnectionType,\r\n        ownerBlock: FlowGraphBlock,\r\n        /**\r\n         * the type of the data in this block\r\n         */\r\n        public richType: RichType<T>,\r\n        /**\r\n         * [any] the default value of the connection\r\n         */\r\n        private _defaultValue: T = richType.defaultValue,\r\n        /**\r\n         * [false] if the connection is optional\r\n         */\r\n        private _optional: boolean = false\r\n    ) {\r\n        super(name, connectionType, ownerBlock);\r\n    }\r\n\r\n    /**\r\n     * Whether or not the connection is optional.\r\n     * Currently only used for UI control.\r\n     */\r\n    public get optional(): boolean {\r\n        return this._optional;\r\n    }\r\n\r\n    /**\r\n     * is this connection disabled\r\n     * If the connection is disabled you will not be able to connect anything to it.\r\n     */\r\n    public get isDisabled(): boolean {\r\n        return this._isDisabled;\r\n    }\r\n\r\n    public set isDisabled(value: boolean) {\r\n        if (this._isDisabled === value) {\r\n            return;\r\n        }\r\n        this._isDisabled = value;\r\n        if (this._isDisabled) {\r\n            this.disconnectFromAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * An output data block can connect to multiple input data blocks,\r\n     * but an input data block can only connect to one output data block.\r\n     * @returns true if the connection is singular\r\n     */\r\n    public override _isSingularConnection(): boolean {\r\n        return this.connectionType === FlowGraphConnectionType.Input;\r\n    }\r\n\r\n    /**\r\n     * Set the value of the connection in a specific context.\r\n     * @param value the value to set\r\n     * @param context the context to which the value is set\r\n     */\r\n    public setValue(value: T, context: FlowGraphContext): void {\r\n        // check if the value is different\r\n        if (context._getConnectionValue(this) === value) {\r\n            return;\r\n        }\r\n        context._setConnectionValue(this, value);\r\n        this.onValueChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Reset the value of the connection to the default value.\r\n     * @param context the context in which the value is reset\r\n     */\r\n    public resetToDefaultValue(context: FlowGraphContext): void {\r\n        context._setConnectionValue(this, this._defaultValue);\r\n    }\r\n\r\n    /**\r\n     * Connect this point to another point.\r\n     * @param point the point to connect to.\r\n     */\r\n    public override connectTo(point: FlowGraphDataConnection<T>): void {\r\n        if (this._isDisabled) {\r\n            return;\r\n        }\r\n        super.connectTo(point);\r\n    }\r\n\r\n    private _getValueOrDefault(context: FlowGraphContext): T {\r\n        const val = context._getConnectionValue(this) ?? this._defaultValue;\r\n        return this.dataTransformer ? this.dataTransformer(val) : val;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the connection in a specific context.\r\n     * @param context the context from which the value is retrieved\r\n     * @returns the value of the connection\r\n     */\r\n    public getValue(context: FlowGraphContext): T {\r\n        if (this.connectionType === FlowGraphConnectionType.Output) {\r\n            context._notifyExecuteNode(this._ownerBlock);\r\n            this._ownerBlock._updateOutputs(context);\r\n            const value = this._getValueOrDefault(context);\r\n            this._lastValue = value;\r\n            return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\r\n        }\r\n        const value = !this.isConnected() ? this._getValueOrDefault(context) : this._connectedPoint[0].getValue(context);\r\n        this._lastValue = value;\r\n        return this.richType.typeTransformer ? this.richType.typeTransformer(value) : value;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _getLastValue(): Nullable<T> {\r\n        return this._lastValue;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the object.\r\n     */\r\n    public override getClassName(): string {\r\n        return \"FlowGraphDataConnection\";\r\n    }\r\n\r\n    /**\r\n     * Serializes this object.\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    public override serialize(serializationObject: any = {}) {\r\n        super.serialize(serializationObject);\r\n        serializationObject.richType = {};\r\n        this.richType.serialize(serializationObject.richType);\r\n        serializationObject.optional = this._optional;\r\n        defaultValueSerializationFunction(\"defaultValue\", this._defaultValue, serializationObject);\r\n    }\r\n}\r\n\r\nRegisterClass(\"FlowGraphDataConnection\", FlowGraphDataConnection);\r\n","import { RandomGUID } from \"../Misc/guid\";\r\nimport { FlowGraphConnectionType } from \"./flowGraphConnection\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport type { RichType } from \"./flowGraphRichTypes\";\r\nimport type { ISerializedFlowGraphBlock, IObjectAccessor } from \"./typeDefinitions\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { FlowGraphAction } from \"./flowGraphLogger\";\r\n\r\n/**\r\n * Options for parsing a block.\r\n */\r\nexport interface IFlowGraphBlockParseOptions {\r\n    /**\r\n     * A function that parses a value from a serialization object.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     * @returns the parsed value\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The assets container to use when loading assets.\r\n     */\r\n    assetsContainer?: IAssetContainer;\r\n    /**\r\n     * The scene that the block is being parsed in.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n\r\n/**\r\n * Configuration for a block.\r\n */\r\nexport interface IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The name of the block.\r\n     */\r\n    name?: string;\r\n    [extraPropertyKey: string]: any;\r\n}\r\n\r\n/**\r\n * A block in a flow graph. The most basic form\r\n * of a block has inputs and outputs that contain\r\n * data.\r\n */\r\nexport class FlowGraphBlock {\r\n    /**\r\n     * A randomly generated GUID for each block.\r\n     */\r\n    public uniqueId = RandomGUID();\r\n    /**\r\n     * The name of the block.\r\n     */\r\n    public name: string;\r\n    /**\r\n     * The data inputs of the block.\r\n     */\r\n    public dataInputs: FlowGraphDataConnection<any>[];\r\n    /**\r\n     * The data outputs of the block.\r\n     */\r\n    public dataOutputs: FlowGraphDataConnection<any>[];\r\n\r\n    /**\r\n     * Metadata that can be used by the block.\r\n     */\r\n    public metadata: any;\r\n\r\n    /** Constructor is protected so only subclasses can be instantiated\r\n     * @param config optional configuration for this block\r\n     * @internal - do not use directly. Extend this class instead.\r\n     */\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        this.name = this.config?.name ?? this.getClassName();\r\n        this.dataInputs = [];\r\n        this.dataOutputs = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * This function is called when the block needs to update its output flows.\r\n     * @param _context the context in which it is running\r\n     */\r\n    public _updateOutputs(_context: FlowGraphContext): void {\r\n        // empty by default, overridden in data blocks\r\n    }\r\n\r\n    /**\r\n     * Registers a data input on the block.\r\n     * @param name the name of the input\r\n     * @param richType the type of the input\r\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\r\n     * @returns the created connection\r\n     */\r\n    public registerDataInput<T>(name: string, richType: RichType<T>, defaultValue?: T): FlowGraphDataConnection<T> {\r\n        const input = new FlowGraphDataConnection(name, FlowGraphConnectionType.Input, this, richType, defaultValue);\r\n        this.dataInputs.push(input);\r\n        return input;\r\n    }\r\n\r\n    /**\r\n     * Registers a data output on the block.\r\n     * @param name the name of the input\r\n     * @param richType the type of the input\r\n     * @param defaultValue optional default value of the input. If not set, the rich type's default value will be used.\r\n     * @returns the created connection\r\n     */\r\n    public registerDataOutput<T>(name: string, richType: RichType<T>, defaultValue?: T): FlowGraphDataConnection<T> {\r\n        const output = new FlowGraphDataConnection(name, FlowGraphConnectionType.Output, this, richType, defaultValue);\r\n        this.dataOutputs.push(output);\r\n        return output;\r\n    }\r\n\r\n    /**\r\n     * Given the name of a data input, returns the connection if it exists\r\n     * @param name the name of the input\r\n     * @returns the connection if it exists, undefined otherwise\r\n     */\r\n    public getDataInput(name: string): FlowGraphDataConnection<any> | undefined {\r\n        return this.dataInputs.find((i) => i.name === name);\r\n    }\r\n\r\n    /**\r\n     * Given the name of a data output, returns the connection if it exists\r\n     * @param name the name of the output\r\n     * @returns the connection if it exists, undefined otherwise\r\n     */\r\n    public getDataOutput(name: string): FlowGraphDataConnection<any> | undefined {\r\n        return this.dataOutputs.find((i) => i.name === name);\r\n    }\r\n\r\n    /**\r\n     * Serializes this block\r\n     * @param serializationObject the object to serialize to\r\n     * @param _valueSerializeFunction a function that serializes a specific value\r\n     */\r\n    public serialize(serializationObject: any = {}, _valueSerializeFunction: (key: string, value: any, serializationObject: any) => any = defaultValueSerializationFunction) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.config = {};\r\n        if (this.config) {\r\n            const config = this.config;\r\n            const keys = Object.keys(config);\r\n            for (const key of keys) {\r\n                _valueSerializeFunction(key, config[key], serializationObject.config);\r\n            }\r\n        }\r\n        serializationObject.dataInputs = [];\r\n        serializationObject.dataOutputs = [];\r\n        serializationObject.className = this.getClassName();\r\n        for (const input of this.dataInputs) {\r\n            const serializedInput: any = {};\r\n            input.serialize(serializedInput);\r\n            serializationObject.dataInputs.push(serializedInput);\r\n        }\r\n        for (const output of this.dataOutputs) {\r\n            const serializedOutput: any = {};\r\n            output.serialize(serializedOutput);\r\n            serializationObject.dataOutputs.push(serializedOutput);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Deserializes this block\r\n     * @param _serializationObject the object to deserialize from\r\n     */\r\n    public deserialize(_serializationObject: ISerializedFlowGraphBlock) {\r\n        // no-op by default\r\n    }\r\n\r\n    protected _log(context: FlowGraphContext, action: FlowGraphAction, payload?: any) {\r\n        context.logger?.addLogItem({\r\n            action,\r\n            payload,\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of this block\r\n     * @returns the class name\r\n     */\r\n    public getClassName() {\r\n        return \"FlowGraphBlock\";\r\n    }\r\n}\r\n","import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * An execution block that has an out signal. This signal is triggered when the synchronous execution of this block is done.\r\n * Most execution blocks will inherit from this, except for the ones that have multiple signals to be triggered.\r\n * (such as if blocks)\r\n */\r\nexport abstract class FlowGraphExecutionBlockWithOutSignal extends FlowGraphExecutionBlock {\r\n    /**\r\n     * Output connection: The signal that is synchronous triggered when the execution of this block is done.\r\n     * Note that is case of events or async you might want to use the `done` signal instead.\r\n     */\r\n    public readonly out: FlowGraphSignalConnection;\r\n\r\n    protected constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.out = this._registerSignalOutput(\"out\");\r\n    }\r\n}\r\n","import { RandomGUID } from \"../Misc/guid\";\r\n\r\n/**\r\n * The type of a connection point - input or output.\r\n */\r\nexport const enum FlowGraphConnectionType {\r\n    Input,\r\n    Output,\r\n}\r\n\r\n/**\r\n * An interface for a connectable point in the flow graph.\r\n */\r\nexport interface IConnectable {\r\n    /**\r\n     * A uniquely identifying string for the connection.\r\n     */\r\n    uniqueId: string;\r\n    /**\r\n     * An array of the points that this point is connected to.\r\n     */\r\n    _connectedPoint: Array<IConnectable>;\r\n    /**\r\n     * Returns if the connection can only be connected to one other point.\r\n     */\r\n    _isSingularConnection(): boolean;\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    _connectionType: FlowGraphConnectionType;\r\n    /**\r\n     * Connect this point to another point.\r\n     * @param point the point to connect to.\r\n     */\r\n    connectTo(point: IConnectable): void;\r\n}\r\n\r\n/**\r\n * The base connection class.\r\n */\r\nexport class FlowGraphConnection<BlockT, ConnectedToT extends IConnectable> implements IConnectable {\r\n    /** @internal */\r\n    public _connectedPoint: Array<ConnectedToT> = [];\r\n    /**\r\n     * A uniquely identifying string for the connection.\r\n     */\r\n    public uniqueId = RandomGUID();\r\n\r\n    /**\r\n     * The name of the connection.\r\n     */\r\n    public name: string;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _connectionType: FlowGraphConnectionType;\r\n\r\n    /**\r\n     * Used for parsing connections.\r\n     * @internal\r\n     */\r\n    // disable warning as this is used for parsing\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    public connectedPointIds: any[] = [];\r\n\r\n    public constructor(\r\n        name: string,\r\n        _connectionType: FlowGraphConnectionType,\r\n        /* @internal */ public _ownerBlock: BlockT\r\n    ) {\r\n        this.name = name;\r\n        this._connectionType = _connectionType;\r\n    }\r\n\r\n    /**\r\n     * The type of the connection\r\n     */\r\n    public get connectionType() {\r\n        return this._connectionType;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Override this to indicate if a point can connect to more than one point.\r\n     */\r\n    public _isSingularConnection(): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Returns if a point is connected to any other point.\r\n     * @returns boolean indicating if the point is connected.\r\n     */\r\n    public isConnected(): boolean {\r\n        return this._connectedPoint.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Connects two connections together.\r\n     * @param point the connection to connect to.\r\n     */\r\n    public connectTo(point: ConnectedToT): void {\r\n        if (this._connectionType === point._connectionType) {\r\n            throw new Error(`Cannot connect two points of type ${this.connectionType}`);\r\n        }\r\n        if ((this._isSingularConnection() && this._connectedPoint.length > 0) || (point._isSingularConnection() && point._connectedPoint.length > 0)) {\r\n            throw new Error(\"Max number of connections for point reached\");\r\n        }\r\n        this._connectedPoint.push(point);\r\n        point._connectedPoint.push(this);\r\n    }\r\n\r\n    /**\r\n     * Disconnects two connections.\r\n     * @param point the connection to disconnect from.\r\n     * @param removeFromLocal if true, the connection will be removed from the local connection list.\r\n     */\r\n    public disconnectFrom(point: ConnectedToT, removeFromLocal = true): void {\r\n        const indexLocal = this._connectedPoint.indexOf(point);\r\n        const indexConnected = point._connectedPoint.indexOf(this);\r\n        if (indexLocal === -1 || indexConnected === -1) {\r\n            return;\r\n        }\r\n        if (removeFromLocal) {\r\n            this._connectedPoint.splice(indexLocal, 1);\r\n        }\r\n        point._connectedPoint.splice(indexConnected, 1);\r\n    }\r\n\r\n    /**\r\n     * Disconnects all connected points.\r\n     */\r\n    public disconnectFromAll() {\r\n        for (const point of this._connectedPoint) {\r\n            this.disconnectFrom(point, false);\r\n        }\r\n        this._connectedPoint.length = 0;\r\n    }\r\n\r\n    public dispose() {\r\n        for (const point of this._connectedPoint) {\r\n            this.disconnectFrom(point);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Saves the connection to a JSON object.\r\n     * @param serializationObject the object to serialize to.\r\n     */\r\n    public serialize(serializationObject: any = {}) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject.name = this.name;\r\n        serializationObject._connectionType = this._connectionType;\r\n        serializationObject.connectedPointIds = [];\r\n        serializationObject.className = this.getClassName();\r\n        for (const point of this._connectedPoint) {\r\n            serializationObject.connectedPointIds.push(point.uniqueId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the connection.\r\n     */\r\n    public getClassName(): string {\r\n        return \"FGConnection\";\r\n    }\r\n\r\n    /**\r\n     * Deserialize from a object into this\r\n     * @param serializationObject the object to deserialize from.\r\n     */\r\n    deserialize(serializationObject: any) {\r\n        this.uniqueId = serializationObject.uniqueId;\r\n        this.name = serializationObject.name;\r\n        this._connectionType = serializationObject._connectionType;\r\n        this.connectedPointIds = serializationObject.connectedPointIds;\r\n    }\r\n}\r\n","import { FlowGraphAsyncExecutionBlock } from \"./flowGraphAsyncExecutionBlock\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\r\n\r\n/**\r\n * A type of block that listens to an event observable and activates\r\n * its output signal when the event is triggered.\r\n */\r\nexport abstract class FlowGraphEventBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * the priority of initialization of this block.\r\n     * For example, scene start should have a negative priority because it should be initialized last.\r\n     */\r\n    public initPriority: number = 0;\r\n\r\n    /**\r\n     * The type of the event\r\n     */\r\n    public readonly type: FlowGraphEventType = FlowGraphEventType.NoTrigger;\r\n    /**\r\n     * @internal\r\n     */\r\n    public _execute(context: FlowGraphContext): void {\r\n        context._notifyExecuteNode(this);\r\n        this.done._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * Execute the event. This function should be called by the flow graph when the event is triggered.\r\n     * @param context the context in which the event is executed\r\n     * @param payload the payload of the event\r\n     * @returns a boolean indicating if the event should stop propagation. if false, the event will stop propagating.\r\n     */\r\n    public abstract _executeEvent(context: FlowGraphContext, payload: any): boolean;\r\n}\r\n","import type { IFlowGraphBlockConfiguration } from \"./flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"./flowGraphExecutionBlockWithOutSignal\";\r\nimport type { FlowGraphSignalConnection } from \"./flowGraphSignalConnection\";\r\n\r\n/**\r\n * An async execution block can start tasks that will be executed asynchronously.\r\n * It should also be responsible for clearing it in _cancelPendingTasks.\r\n */\r\nexport abstract class FlowGraphAsyncExecutionBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Output connection: The signal that is triggered when the asynchronous execution of this block is done.\r\n     */\r\n    public done: FlowGraphSignalConnection;\r\n\r\n    protected _eventsSignalOutputs: { [eventName: string]: FlowGraphSignalConnection } = {};\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration, events?: string[]) {\r\n        super(config);\r\n        this.done = this._registerSignalOutput(\"done\");\r\n        if (events) {\r\n            for (const eventName of events) {\r\n                this._eventsSignalOutputs[eventName] = this._registerSignalOutput(eventName + \"Event\");\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     * This function can be overridden to start any\r\n     * pending tasks this node might have, such as\r\n     * timeouts and playing animations.\r\n     * @param context\r\n     */\r\n    public abstract _preparePendingTasks(context: FlowGraphContext): void;\r\n\r\n    /**\r\n     * @internal\r\n     * This function can be overridden to execute any\r\n     * logic that should be executed on every frame\r\n     * while the async task is pending.\r\n     * @param context the context in which it is running\r\n     */\r\n    public _executeOnTick(_context: FlowGraphContext): void {}\r\n\r\n    /**\r\n     * @internal\r\n     * @param context\r\n     */\r\n    public _startPendingTasks(context: FlowGraphContext) {\r\n        if (context._getExecutionVariable(this, \"_initialized\", false)) {\r\n            this._cancelPendingTasks(context);\r\n            this._resetAfterCanceled(context);\r\n        }\r\n\r\n        this._preparePendingTasks(context);\r\n        context._addPendingBlock(this);\r\n        this.out._activateSignal(context);\r\n        context._setExecutionVariable(this, \"_initialized\", true);\r\n    }\r\n\r\n    public _resetAfterCanceled(context: FlowGraphContext) {\r\n        context._deleteExecutionVariable(this, \"_initialized\");\r\n        context._removePendingBlock(this);\r\n    }\r\n\r\n    public abstract _cancelPendingTasks(context: FlowGraphContext): void;\r\n}\r\n","import type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { Animation } from \"core/Animations/animation\";\nimport type { Nullable } from \"core/types\";\nimport type { Mesh } from \"core/Meshes/mesh\";\nimport type { Material } from \"core/Materials/material\";\nimport type { Camera } from \"core/Cameras/camera\";\nimport type { Light } from \"core/Lights/light\";\nimport type { IAssetContainer } from \"core/IAssetContainer\";\n\n/**\n * The type of the assets that flow graph supports\n */\nexport const enum FlowGraphAssetType {\n    Animation = \"Animation\",\n    AnimationGroup = \"AnimationGroup\",\n    Mesh = \"Mesh\",\n    Material = \"Material\",\n    Camera = \"Camera\",\n    Light = \"Light\",\n    // Further asset types will be added here when needed.\n}\n\nexport type AssetType<T extends FlowGraphAssetType> = T extends FlowGraphAssetType.Animation\n    ? Animation\n    : T extends FlowGraphAssetType.AnimationGroup\n      ? AnimationGroup\n      : T extends FlowGraphAssetType.Mesh\n        ? Mesh\n        : T extends FlowGraphAssetType.Material\n          ? Material\n          : T extends FlowGraphAssetType.Camera\n            ? Camera\n            : T extends FlowGraphAssetType.Light\n              ? Light\n              : never;\n\n/**\n * Returns the asset with the given index and type from the assets context.\n * @param assetsContext The assets context to get the asset from\n * @param type The type of the asset\n * @param index The index of the asset\n * @param useIndexAsUniqueId If set to true, instead of the index in the array it will search for the unique id of the asset.\n * @returns The asset or null if not found\n */\nexport function GetFlowGraphAssetWithType<T extends FlowGraphAssetType>(\n    assetsContext: IAssetContainer,\n    type: T,\n    index: number,\n    useIndexAsUniqueId?: boolean\n): Nullable<AssetType<T>> {\n    switch (type) {\n        case FlowGraphAssetType.Animation:\n            return useIndexAsUniqueId\n                ? ((assetsContext.animations.find((a) => a.uniqueId === index) as AssetType<typeof type>) ?? null)\n                : ((assetsContext.animations[index] as AssetType<typeof type>) ?? null);\n        case FlowGraphAssetType.AnimationGroup:\n            return useIndexAsUniqueId\n                ? ((assetsContext.animationGroups.find((a) => a.uniqueId === index) as AssetType<typeof type>) ?? null)\n                : ((assetsContext.animationGroups[index] as AssetType<typeof type>) ?? null);\n        case FlowGraphAssetType.Mesh:\n            return useIndexAsUniqueId\n                ? ((assetsContext.meshes.find((a) => a.uniqueId === index) as AssetType<typeof type>) ?? null)\n                : ((assetsContext.meshes[index] as AssetType<typeof type>) ?? null);\n        case FlowGraphAssetType.Material:\n            return useIndexAsUniqueId\n                ? ((assetsContext.materials.find((a) => a.uniqueId === index) as AssetType<typeof type>) ?? null)\n                : ((assetsContext.materials[index] as AssetType<typeof type>) ?? null);\n        case FlowGraphAssetType.Camera:\n            return useIndexAsUniqueId\n                ? ((assetsContext.cameras.find((a) => a.uniqueId === index) as AssetType<typeof type>) ?? null)\n                : ((assetsContext.cameras[index] as AssetType<typeof type>) ?? null);\n        case FlowGraphAssetType.Light:\n            return useIndexAsUniqueId\n                ? ((assetsContext.lights.find((a) => a.uniqueId === index) as AssetType<typeof type>) ?? null)\n                : ((assetsContext.lights[index] as AssetType<typeof type>) ?? null);\n        default:\n            return null;\n    }\n}\n","import { Logger } from \"core/Misc/logger\";\n\nexport const enum FlowGraphAction {\n    ExecuteBlock = \"ExecuteBlock\",\n    ExecuteEvent = \"ExecuteEvent\",\n    TriggerConnection = \"TriggerConnection\",\n    ContextVariableSet = \"ContextVariableSet\",\n    GlobalVariableSet = \"GlobalVariableSet\",\n    GlobalVariableDelete = \"GlobalVariableDelete\",\n    GlobalVariableGet = \"GlobalVariableGet\",\n    AddConnection = \"AddConnection\",\n    GetConnectionValue = \"GetConnectionValue\",\n    SetConnectionValue = \"SetConnectionValue\",\n    ActivateSignal = \"ActivateSignal\",\n    ContextVariableGet = \"ContextVariableGet\",\n}\n\n/**\n * An item in the flow graph log.\n */\nexport interface IFlowGraphLogItem {\n    /**\n     * The time of the log item.\n     */\n    time?: number;\n    /**\n     * The class that triggered the log.\n     */\n    className: string;\n    /**\n     * The unique id of the block/module that triggered the log.\n     */\n    uniqueId: string;\n    /**\n     * The action that was logged.\n     */\n    action: FlowGraphAction;\n    /**\n     * The payload of the log\n     * This can be any data that is relevant to the action.\n     * For example, the value of a connection, the value of a variable, etc.\n     * This is optional.\n     */\n    payload?: any;\n}\n\n/**\n * This class will be responsible of logging the flow graph activity.\n * Note that using this class might reduce performance, as it will log every action, according to the configuration.\n * It attaches to a flow graph and uses meta-programming to replace the methods of the flow graph to add logging abilities.\n */\nexport class FlowGraphLogger {\n    /**\n     * Whether to log to the console.\n     */\n    public logToConsole: boolean = false;\n\n    /**\n     * The log cache of the flow graph.\n     * Each item is a logged item, in order of execution.\n     */\n    public log: IFlowGraphLogItem[] = [];\n\n    public addLogItem(item: IFlowGraphLogItem) {\n        if (!item.time) {\n            item.time = Date.now();\n        }\n        this.log.push(item);\n        if (this.logToConsole) {\n            const value = item.payload?.value;\n            if (typeof value === \"object\" && value.getClassName) {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(value.getClassName())}: ${value.toString()}`);\n            } else {\n                Logger.Log(`[FGLog] ${item.className}:${item.uniqueId.split(\"-\")[0]} ${item.action} - ${JSON.stringify(item.payload)}`);\n            }\n        }\n    }\n\n    public getItemsOfType(action: FlowGraphAction): IFlowGraphLogItem[] {\n        return this.log.filter((i) => i.action === action);\n    }\n}\n","import { serialize } from \"../Misc/decorators\";\r\nimport { RandomGUID } from \"../Misc/guid\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphAsyncExecutionBlock } from \"./flowGraphAsyncExecutionBlock\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport type { FlowGraph } from \"./flowGraph\";\r\nimport { defaultValueSerializationFunction } from \"./serialization\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { AssetType, FlowGraphAssetType } from \"./flowGraphAssetsContext\";\r\nimport { GetFlowGraphAssetWithType } from \"./flowGraphAssetsContext\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { FlowGraphAction, FlowGraphLogger } from \"./flowGraphLogger\";\r\nimport type { IFlowGraphOnTickEventPayload } from \"./Blocks/Event/flowGraphSceneTickEventBlock\";\r\n\r\n/**\r\n * Construction parameters for the context.\r\n */\r\nexport interface IFlowGraphContextConfiguration {\r\n    /**\r\n     * The scene that the flow graph context belongs to.\r\n     */\r\n    readonly scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph context.\r\n     */\r\n    readonly coordinator: FlowGraphCoordinator;\r\n\r\n    /**\r\n     * The assets context used by the flow graph context.\r\n     * If none is provided, a default one will be created.\r\n     */\r\n    readonly assetsContext?: IAssetContainer;\r\n}\r\n\r\n/**\r\n * Options for parsing a context.\r\n */\r\nexport interface IFlowGraphContextParseOptions {\r\n    /**\r\n     * A function that parses a value from a serialization object.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object containing the value\r\n     * @param scene the current scene\r\n     * @returns\r\n     */\r\n    readonly valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The graph that the context is being parsed in.\r\n     */\r\n    readonly graph: FlowGraph;\r\n}\r\n/**\r\n * The context represents the current state and execution of the flow graph.\r\n * It contains both user-defined variables, which are derived from\r\n * a more general variable definition, and execution variables that\r\n * are set by the blocks.\r\n */\r\nexport class FlowGraphContext {\r\n    /**\r\n     * A randomly generated GUID for each context.\r\n     */\r\n    @serialize()\r\n    public uniqueId = RandomGUID();\r\n    /**\r\n     * These are the variables defined by a user.\r\n     */\r\n    private _userVariables: { [key: string]: any } = {};\r\n    /**\r\n     * These are the variables set by the blocks.\r\n     */\r\n    private _executionVariables: { [key: string]: any } = {};\r\n\r\n    /**\r\n     * A context-specific global variables, available to all blocks in the context.\r\n     */\r\n    private _globalContextVariables: { [key: string]: any } = {};\r\n    /**\r\n     * These are the values for the data connection points\r\n     */\r\n    private _connectionValues: { [key: string]: any } = {};\r\n    /**\r\n     * These are the variables set by the graph.\r\n     */\r\n    private readonly _configuration: IFlowGraphContextConfiguration;\r\n    /**\r\n     * These are blocks that have currently pending tasks/listeners that need to be cleaned up.\r\n     */\r\n    private _pendingBlocks: FlowGraphAsyncExecutionBlock[] = [];\r\n    /**\r\n     * A monotonically increasing ID for each execution.\r\n     * Incremented for every block executed.\r\n     */\r\n    private _executionId = 0;\r\n    /**\r\n     * Observable that is triggered when a node is executed.\r\n     */\r\n    public onNodeExecutedObservable: Observable<FlowGraphBlock> = new Observable<FlowGraphBlock>();\r\n\r\n    /**\r\n     * The assets context used by the flow graph context.\r\n     * Note that it can be shared between flow graph contexts.\r\n     */\r\n    public assetsContext: IAssetContainer;\r\n\r\n    /**\r\n     * Whether to treat data as right-handed.\r\n     * This is used when serializing data from a right-handed system, while running the context in a left-handed system, for example in glTF parsing.\r\n     * Default is false.\r\n     */\r\n    public treatDataAsRightHanded = false;\r\n\r\n    private _enableLogging = false;\r\n\r\n    /**\r\n     * The logger used by the context to log actions.\r\n     */\r\n    public logger: Nullable<FlowGraphLogger>;\r\n\r\n    /**\r\n     * Enable logging on this context\r\n     */\r\n    public get enableLogging() {\r\n        return this._enableLogging;\r\n    }\r\n\r\n    public set enableLogging(value: boolean) {\r\n        if (this._enableLogging === value) {\r\n            return;\r\n        }\r\n        this._enableLogging = value;\r\n        if (this._enableLogging) {\r\n            this.logger = new FlowGraphLogger();\r\n            this.logger.logToConsole = true;\r\n        } else {\r\n            this.logger = null;\r\n        }\r\n    }\r\n\r\n    constructor(params: IFlowGraphContextConfiguration) {\r\n        this._configuration = params;\r\n        this.assetsContext = params.assetsContext ?? params.scene;\r\n    }\r\n\r\n    /**\r\n     * Check if a user-defined variable is defined.\r\n     * @param name the name of the variable\r\n     * @returns true if the variable is defined\r\n     */\r\n    public hasVariable(name: string) {\r\n        return name in this._userVariables;\r\n    }\r\n\r\n    /**\r\n     * Set a user-defined variable.\r\n     * @param name the name of the variable\r\n     * @param value the value of the variable\r\n     */\r\n    public setVariable(name: string, value: any) {\r\n        this._userVariables[name] = value;\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.ContextVariableSet,\r\n            payload: {\r\n                name,\r\n                value,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get an assets from the assets context based on its type and index in the array\r\n     * @param type The type of the asset\r\n     * @param index The index of the asset\r\n     * @returns The asset or null if not found\r\n     */\r\n    public getAsset<T extends FlowGraphAssetType>(type: T, index: number): Nullable<AssetType<T>> {\r\n        return GetFlowGraphAssetWithType(this.assetsContext, type, index);\r\n    }\r\n\r\n    /**\r\n     * Get a user-defined variable.\r\n     * @param name the name of the variable\r\n     * @returns the value of the variable\r\n     */\r\n    public getVariable(name: string): any {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.ContextVariableGet,\r\n            payload: {\r\n                name,\r\n                value: this._userVariables[name],\r\n            },\r\n        });\r\n        return this._userVariables[name];\r\n    }\r\n\r\n    /**\r\n     * Gets all user variables map\r\n     */\r\n    public get userVariables() {\r\n        return this._userVariables;\r\n    }\r\n\r\n    /**\r\n     * Get the scene that the context belongs to.\r\n     * @returns the scene\r\n     */\r\n    public getScene() {\r\n        return this._configuration.scene;\r\n    }\r\n\r\n    private _getUniqueIdPrefixedName(obj: FlowGraphBlock, name: string): string {\r\n        return `${obj.uniqueId}_${name}`;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param name name of the variable\r\n     * @param defaultValue default value to return if the variable is not defined\r\n     * @returns the variable value or the default value if the variable is not defined\r\n     */\r\n    public _getGlobalContextVariable<T>(name: string, defaultValue: T): T {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableGet,\r\n            payload: {\r\n                name,\r\n                defaultValue,\r\n                possibleValue: this._globalContextVariables[name],\r\n            },\r\n        });\r\n        if (this._hasGlobalContextVariable(name)) {\r\n            return this._globalContextVariables[name];\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global context variable\r\n     * @internal\r\n     * @param name the name of the variable\r\n     * @param value the value of the variable\r\n     */\r\n    public _setGlobalContextVariable<T>(name: string, value: T) {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableSet,\r\n            payload: { name, value },\r\n        });\r\n        this._globalContextVariables[name] = value;\r\n    }\r\n\r\n    /**\r\n     * Delete a global context variable\r\n     * @internal\r\n     * @param name the name of the variable\r\n     */\r\n    public _deleteGlobalContextVariable(name: string) {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GlobalVariableDelete,\r\n            payload: { name },\r\n        });\r\n        delete this._globalContextVariables[name];\r\n    }\r\n\r\n    /**\r\n     * Check if a global context variable is defined\r\n     * @internal\r\n     * @param name the name of the variable\r\n     * @returns true if the variable is defined\r\n     */\r\n    public _hasGlobalContextVariable(name: string) {\r\n        return name in this._globalContextVariables;\r\n    }\r\n\r\n    /**\r\n     * Set an internal execution variable\r\n     * @internal\r\n     * @param name\r\n     * @param value\r\n     */\r\n    public _setExecutionVariable(block: FlowGraphBlock, name: string, value: any) {\r\n        this._executionVariables[this._getUniqueIdPrefixedName(block, name)] = value;\r\n    }\r\n\r\n    /**\r\n     * Get an internal execution variable\r\n     * @internal\r\n     * @param name\r\n     * @returns\r\n     */\r\n    public _getExecutionVariable<T>(block: FlowGraphBlock, name: string, defaultValue: T): T {\r\n        if (this._hasExecutionVariable(block, name)) {\r\n            return this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\r\n        } else {\r\n            return defaultValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete an internal execution variable\r\n     * @internal\r\n     * @param block\r\n     * @param name\r\n     */\r\n    public _deleteExecutionVariable(block: FlowGraphBlock, name: string) {\r\n        delete this._executionVariables[this._getUniqueIdPrefixedName(block, name)];\r\n    }\r\n\r\n    /**\r\n     * Check if an internal execution variable is defined\r\n     * @internal\r\n     * @param block\r\n     * @param name\r\n     * @returns\r\n     */\r\n    public _hasExecutionVariable(block: FlowGraphBlock, name: string) {\r\n        return this._getUniqueIdPrefixedName(block, name) in this._executionVariables;\r\n    }\r\n\r\n    /**\r\n     * Check if a connection value is defined\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @returns\r\n     */\r\n    public _hasConnectionValue(connectionPoint: FlowGraphDataConnection<any>) {\r\n        return connectionPoint.uniqueId in this._connectionValues;\r\n    }\r\n\r\n    /**\r\n     * Set a connection value\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @param value\r\n     */\r\n    public _setConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>, value: T) {\r\n        this._connectionValues[connectionPoint.uniqueId] = value;\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.SetConnectionValue,\r\n            payload: {\r\n                connectionPointId: connectionPoint.uniqueId,\r\n                value,\r\n            },\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Set a connection value by key\r\n     * @internal\r\n     * @param key the key of the connection value\r\n     * @param value the value of the connection\r\n     */\r\n    public _setConnectionValueByKey<T>(key: string, value: T) {\r\n        this._connectionValues[key] = value;\r\n    }\r\n\r\n    /**\r\n     * Get a connection value\r\n     * @internal\r\n     * @param connectionPoint\r\n     * @returns\r\n     */\r\n    public _getConnectionValue<T>(connectionPoint: FlowGraphDataConnection<T>): T {\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: this.getClassName(),\r\n            uniqueId: this.uniqueId,\r\n            action: FlowGraphAction.GetConnectionValue,\r\n            payload: {\r\n                connectionPointId: connectionPoint.uniqueId,\r\n                value: this._connectionValues[connectionPoint.uniqueId],\r\n            },\r\n        });\r\n        return this._connectionValues[connectionPoint.uniqueId];\r\n    }\r\n\r\n    /**\r\n     * Get the configuration\r\n     * @internal\r\n     * @param name\r\n     * @param value\r\n     */\r\n    public get configuration() {\r\n        return this._configuration;\r\n    }\r\n\r\n    /**\r\n     * Check if there are any pending blocks in this context\r\n     * @returns true if there are pending blocks\r\n     */\r\n    public get hasPendingBlocks() {\r\n        return this._pendingBlocks.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Add a block to the list of blocks that have pending tasks.\r\n     * @internal\r\n     * @param block\r\n     */\r\n    public _addPendingBlock(block: FlowGraphAsyncExecutionBlock) {\r\n        // check if block is already in the array\r\n        if (this._pendingBlocks.includes(block)) {\r\n            return;\r\n        }\r\n        this._pendingBlocks.push(block);\r\n        // sort pending blocks by priority\r\n        this._pendingBlocks.sort((a, b) => a.priority - b.priority);\r\n    }\r\n\r\n    /**\r\n     * Remove a block from the list of blocks that have pending tasks.\r\n     * @internal\r\n     * @param block\r\n     */\r\n    public _removePendingBlock(block: FlowGraphAsyncExecutionBlock) {\r\n        const index = this._pendingBlocks.indexOf(block);\r\n        if (index !== -1) {\r\n            this._pendingBlocks.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear all pending blocks.\r\n     * @internal\r\n     */\r\n    public _clearPendingBlocks() {\r\n        for (const block of this._pendingBlocks) {\r\n            block._cancelPendingTasks(this);\r\n        }\r\n        this._pendingBlocks.length = 0;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Function that notifies the node executed observable\r\n     * @param node\r\n     */\r\n    public _notifyExecuteNode(node: FlowGraphBlock) {\r\n        this.onNodeExecutedObservable.notifyObservers(node);\r\n        this.logger?.addLogItem({\r\n            time: Date.now(),\r\n            className: node.getClassName(),\r\n            uniqueId: node.uniqueId,\r\n            action: FlowGraphAction.ExecuteBlock,\r\n        });\r\n    }\r\n\r\n    public _notifyOnTick(framePayload: IFlowGraphOnTickEventPayload) {\r\n        // set the values as global variables\r\n        this._setGlobalContextVariable(\"timeSinceStart\", framePayload.timeSinceStart);\r\n        this._setGlobalContextVariable(\"deltaTime\", framePayload.deltaTime);\r\n        // iterate the pending blocks and run each one's onFrame function\r\n        for (const block of this._pendingBlocks) {\r\n            block._executeOnTick?.(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _increaseExecutionId() {\r\n        this._executionId++;\r\n    }\r\n    /**\r\n     * A monotonically increasing ID for each execution.\r\n     * Incremented for every block executed.\r\n     */\r\n    public get executionId() {\r\n        return this._executionId;\r\n    }\r\n\r\n    /**\r\n     * Serializes a context\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializationFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializationFunction: (key: string, value: any, serializationObject: any) => void = defaultValueSerializationFunction) {\r\n        serializationObject.uniqueId = this.uniqueId;\r\n        serializationObject._userVariables = {};\r\n        for (const key in this._userVariables) {\r\n            valueSerializationFunction(key, this._userVariables[key], serializationObject._userVariables);\r\n        }\r\n        serializationObject._connectionValues = {};\r\n        for (const key in this._connectionValues) {\r\n            valueSerializationFunction(key, this._connectionValues[key], serializationObject._connectionValues);\r\n        }\r\n        // serialize assets context, if not scene\r\n        if (this.assetsContext !== this.getScene()) {\r\n            serializationObject._assetsContext = {\r\n                meshes: this.assetsContext.meshes.map((m) => m.id),\r\n                materials: this.assetsContext.materials.map((m) => m.id),\r\n                textures: this.assetsContext.textures.map((m) => m.name),\r\n                animations: this.assetsContext.animations.map((m) => m.name),\r\n                lights: this.assetsContext.lights.map((m) => m.id),\r\n                cameras: this.assetsContext.cameras.map((m) => m.id),\r\n                sounds: this.assetsContext.sounds?.map((m) => m.name),\r\n                skeletons: this.assetsContext.skeletons.map((m) => m.id),\r\n                particleSystems: this.assetsContext.particleSystems.map((m) => m.name),\r\n                geometries: this.assetsContext.geometries.map((m) => m.id),\r\n                multiMaterials: this.assetsContext.multiMaterials.map((m) => m.id),\r\n                transformNodes: this.assetsContext.transformNodes.map((m) => m.id),\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the class name of the object.\r\n     */\r\n    public getClassName() {\r\n        return \"FlowGraphContext\";\r\n    }\r\n}\r\n","import type { PointerInfo } from \"core/Events/pointerEvents\";\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { Observer } from \"core/Misc/observable\";\nimport { Observable } from \"core/Misc/observable\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\n\n/**\n * the interface of the object the scene event coordinator will trigger.\n */\nexport interface IFlowGraphEventTrigger {\n    /**\n     * The type of the event\n     */\n    type: FlowGraphEventType;\n    /**\n     * The data of the event\n     */\n    payload?: any;\n}\n\n/**\n * This class is responsible for coordinating the events that are triggered in the scene.\n * It registers all observers needed to track certain events and triggers the blocks that are listening to them.\n * Abstracting the events from the class will allow us to easily change the events that are being listened to, and trigger them in any order.\n */\nexport class FlowGraphSceneEventCoordinator {\n    /**\n     * @internal\n     */\n    public readonly _scene: Scene;\n\n    /**\n     * register to this observable to get flow graph event notifications.\n     */\n    public onEventTriggeredObservable: Observable<IFlowGraphEventTrigger> = new Observable();\n\n    /**\n     * Was scene-ready already triggered?\n     */\n    public sceneReadyTriggered: boolean = false;\n\n    private _sceneDisposeObserver: Nullable<Observer<Scene>>;\n    private _sceneReadyObserver: Nullable<Observer<Scene>>;\n    private _sceneOnBeforeRenderObserver: Nullable<Observer<Scene>>;\n    private _meshPickedObserver: Nullable<Observer<PointerInfo>>;\n    private _meshUnderPointerObserver: Nullable<Observer<{ mesh: Nullable<AbstractMesh>; pointerId: number }>>;\n    private _pointerUnderMeshState: { [pointerId: number]: Nullable<AbstractMesh> } = {};\n\n    private _startingTime: number = 0;\n\n    constructor(scene: Scene) {\n        this._scene = scene;\n        this._initialize();\n    }\n\n    private _initialize() {\n        this._sceneReadyObserver = this._scene.onReadyObservable.add(() => {\n            if (!this.sceneReadyTriggered) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\n                this.sceneReadyTriggered = true;\n            }\n        });\n\n        this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneDispose });\n        });\n        this._sceneOnBeforeRenderObserver = this._scene.onBeforeRenderObservable.add(() => {\n            const deltaTime = this._scene.getEngine().getDeltaTime() / 1000; // set in seconds\n            this.onEventTriggeredObservable.notifyObservers({\n                type: FlowGraphEventType.SceneBeforeRender,\n                payload: {\n                    timeSinceStart: this._startingTime,\n                    deltaTime,\n                },\n            });\n            this._startingTime += deltaTime;\n        });\n\n        this._meshPickedObserver = this._scene.onPointerObservable.add((pointerInfo) => {\n            this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.MeshPick, payload: pointerInfo });\n        }, PointerEventTypes.POINTERPICK); // should it be pointerdown?\n\n        this._meshUnderPointerObserver = this._scene.onMeshUnderPointerUpdatedObservable.add((data) => {\n            // check if the data has changed. Check the state of the last change and see if it is a mesh or null.\n            // if it is a mesh and the previous state was null, trigger over event. If it is null and the previous state was a mesh, trigger out event.\n            // if it is a mesh and the previous state was a mesh, trigger out from the old mesh and over the new mesh\n            // if it is null and the previous state was null, do nothing.\n            const pointerId = data.pointerId;\n            const mesh = data.mesh;\n            const previousState = this._pointerUnderMeshState[pointerId];\n            if (!previousState && mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh } });\n            } else if (previousState && !mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState } });\n            } else if (previousState && mesh && previousState !== mesh) {\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOut, payload: { pointerId, mesh: previousState, over: mesh } });\n                this.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.PointerOver, payload: { pointerId, mesh, out: previousState } });\n            }\n            this._pointerUnderMeshState[pointerId] = mesh;\n        }, PointerEventTypes.POINTERMOVE);\n    }\n\n    public dispose() {\n        this._sceneDisposeObserver?.remove();\n        this._sceneReadyObserver?.remove();\n        this._sceneOnBeforeRenderObserver?.remove();\n        this._meshPickedObserver?.remove();\n        this._meshUnderPointerObserver?.remove();\n        this.onEventTriggeredObservable.clear();\n    }\n}\n","import type { Observer } from \"../Misc/observable\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { FlowGraphEventBlock } from \"./flowGraphEventBlock\";\r\nimport { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport { FlowGraphExecutionBlock } from \"./flowGraphExecutionBlock\";\r\nimport type { FlowGraphCoordinator } from \"./flowGraphCoordinator\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { FlowGraphEventType } from \"./flowGraphEventType\";\r\nimport type { IFlowGraphEventTrigger } from \"./flowGraphSceneEventCoordinator\";\r\nimport { FlowGraphSceneEventCoordinator } from \"./flowGraphSceneEventCoordinator\";\r\nimport type { FlowGraphMeshPickEventBlock } from \"./Blocks/Event/flowGraphMeshPickEventBlock\";\r\nimport { _IsDescendantOf } from \"./utils\";\r\n\r\nexport const enum FlowGraphState {\r\n    /**\r\n     * The graph is stopped\r\n     */\r\n    Stopped,\r\n    /**\r\n     * The graph is running\r\n     */\r\n    Started,\r\n}\r\n\r\n/**\r\n * Parameters used to create a flow graph.\r\n */\r\nexport interface IFlowGraphParams {\r\n    /**\r\n     * The scene that the flow graph belongs to.\r\n     */\r\n    scene: Scene;\r\n    /**\r\n     * The event coordinator used by the flow graph.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n}\r\n\r\n/**\r\n * Options for parsing a flow graph.\r\n */\r\nexport interface IFlowGraphParseOptions {\r\n    /**\r\n     * A function that parses complex values in a scene.\r\n     * @param key the key of the value\r\n     * @param serializationObject the object to read the value from\r\n     * @param scene the scene to read the value from\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The flow graph coordinator.\r\n     */\r\n    coordinator: FlowGraphCoordinator;\r\n    /**\r\n     * A function that converts a path to an object accessor.\r\n     */\r\n    pathConverter?: IPathToObjectConverter<IObjectAccessor>;\r\n}\r\n/**\r\n * Class used to represent a flow graph.\r\n * A flow graph is a graph of blocks that can be used to create complex logic.\r\n * Blocks can be added to the graph and connected to each other.\r\n * The graph can then be started, which will init and start all of its event blocks.\r\n *\r\n * @experimental FlowGraph is still in development and is subject to change.\r\n */\r\nexport class FlowGraph {\r\n    /**\r\n     * An observable that is triggered when the state of the graph changes.\r\n     */\r\n    public onStateChangedObservable: Observable<FlowGraphState> = new Observable();\r\n    /** @internal */\r\n    public _eventBlocks: { [keyof in FlowGraphEventType]: FlowGraphEventBlock[] } = {\r\n        [FlowGraphEventType.SceneReady]: [],\r\n        [FlowGraphEventType.SceneDispose]: [],\r\n        [FlowGraphEventType.SceneBeforeRender]: [],\r\n        [FlowGraphEventType.MeshPick]: [],\r\n        [FlowGraphEventType.PointerDown]: [],\r\n        [FlowGraphEventType.PointerUp]: [],\r\n        [FlowGraphEventType.PointerMove]: [],\r\n        [FlowGraphEventType.PointerOver]: [],\r\n        [FlowGraphEventType.PointerOut]: [],\r\n        [FlowGraphEventType.SceneAfterRender]: [],\r\n        [FlowGraphEventType.NoTrigger]: [],\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    public readonly _scene: Scene;\r\n    private _coordinator: FlowGraphCoordinator;\r\n    private _executionContexts: FlowGraphContext[] = [];\r\n    private _sceneEventCoordinator: FlowGraphSceneEventCoordinator;\r\n    private _eventObserver: Nullable<Observer<IFlowGraphEventTrigger>>;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    private _state: FlowGraphState = FlowGraphState.Stopped;\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public get state() {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * The state of the graph\r\n     */\r\n    public set state(value: FlowGraphState) {\r\n        this._state = value;\r\n        this.onStateChangedObservable.notifyObservers(value);\r\n    }\r\n\r\n    /**\r\n     * Construct a Flow Graph\r\n     * @param params construction parameters. currently only the scene\r\n     */\r\n    public constructor(params: IFlowGraphParams) {\r\n        this._scene = params.scene;\r\n        this._sceneEventCoordinator = new FlowGraphSceneEventCoordinator(this._scene);\r\n        this._coordinator = params.coordinator;\r\n\r\n        this._eventObserver = this._sceneEventCoordinator.onEventTriggeredObservable.add((event) => {\r\n            for (const context of this._executionContexts) {\r\n                const order = this._getContextualOrder(event.type, context);\r\n                for (const block of order) {\r\n                    // iterate contexts\r\n                    if (!block._executeEvent(context, event.payload)) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            // custom behavior(s) of specific events\r\n            switch (event.type) {\r\n                case FlowGraphEventType.SceneReady:\r\n                    this._sceneEventCoordinator.sceneReadyTriggered = true;\r\n                    break;\r\n                case FlowGraphEventType.SceneBeforeRender:\r\n                    for (const context of this._executionContexts) {\r\n                        context._notifyOnTick(event.payload);\r\n                    }\r\n                    break;\r\n                case FlowGraphEventType.SceneDispose:\r\n                    this.dispose();\r\n                    break;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a context. A context represents one self contained execution for the graph, with its own variables.\r\n     * @returns the context, where you can get and set variables\r\n     */\r\n    public createContext() {\r\n        const context = new FlowGraphContext({ scene: this._scene, coordinator: this._coordinator });\r\n        this._executionContexts.push(context);\r\n        return context;\r\n    }\r\n\r\n    /**\r\n     * Returns the execution context at a given index\r\n     * @param index the index of the context\r\n     * @returns the execution context at that index\r\n     */\r\n    public getContext(index: number) {\r\n        return this._executionContexts[index];\r\n    }\r\n\r\n    /**\r\n     * Add an event block. When the graph is started, it will start listening to events\r\n     * from the block and execute the graph when they are triggered.\r\n     * @param block the event block to be added\r\n     */\r\n    public addEventBlock(block: FlowGraphEventBlock): void {\r\n        if (block.type === FlowGraphEventType.PointerOver || block.type === FlowGraphEventType.PointerOut) {\r\n            this._scene.constantlyUpdateMeshUnderPointer = true;\r\n        }\r\n\r\n        // don't add if NoTrigger, but still start the pending tasks\r\n        if (block.type !== FlowGraphEventType.NoTrigger) {\r\n            this._eventBlocks[block.type].push(block);\r\n        }\r\n        // if already started, sort and add to the pending\r\n        if (this.state === FlowGraphState.Started) {\r\n            for (const context of this._executionContexts) {\r\n                block._startPendingTasks(context);\r\n            }\r\n        } else {\r\n            this.onStateChangedObservable.addOnce((state) => {\r\n                if (state === FlowGraphState.Started) {\r\n                    for (const context of this._executionContexts) {\r\n                        block._startPendingTasks(context);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts the flow graph. Initializes the event blocks and starts listening to events.\r\n     */\r\n    public start() {\r\n        if (this.state === FlowGraphState.Started) {\r\n            return;\r\n        }\r\n        if (this._executionContexts.length === 0) {\r\n            this.createContext();\r\n        }\r\n        this.onStateChangedObservable.add((state) => {\r\n            if (state === FlowGraphState.Started) {\r\n                this._startPendingEvents();\r\n                // the only event we need to check is the scene ready event. If the scene is already ready when the graph starts, we should start the pending tasks.\r\n                if (this._scene.isReady(true)) {\r\n                    this._sceneEventCoordinator.onEventTriggeredObservable.notifyObservers({ type: FlowGraphEventType.SceneReady });\r\n                }\r\n            }\r\n        });\r\n        this.state = FlowGraphState.Started;\r\n    }\r\n\r\n    private _startPendingEvents() {\r\n        for (const context of this._executionContexts) {\r\n            for (const type in this._eventBlocks) {\r\n                const order = this._getContextualOrder(type as FlowGraphEventType, context);\r\n                for (const block of order) {\r\n                    block._startPendingTasks(context);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getContextualOrder(type: FlowGraphEventType, context: FlowGraphContext): FlowGraphEventBlock[] {\r\n        const order = this._eventBlocks[type].sort((a, b) => b.initPriority - a.initPriority);\r\n\r\n        if (type === FlowGraphEventType.MeshPick) {\r\n            const meshPickOrder = [] as FlowGraphEventBlock[];\r\n            for (const block1 of order) {\r\n                // If the block is a mesh pick, guarantee that picks of children meshes come before picks of parent meshes\r\n                const mesh1 = (block1 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                let i = 0;\r\n                for (; i < order.length; i++) {\r\n                    const block2 = order[i];\r\n                    const mesh2 = (block2 as FlowGraphMeshPickEventBlock).asset.getValue(context);\r\n                    if (mesh1 && mesh2 && _IsDescendantOf(mesh1, mesh2)) {\r\n                        break;\r\n                    }\r\n                }\r\n                meshPickOrder.splice(i, 0, block1);\r\n            }\r\n            return meshPickOrder;\r\n        }\r\n        return order;\r\n    }\r\n\r\n    /**\r\n     * Disposes of the flow graph. Cancels any pending tasks and removes all event listeners.\r\n     */\r\n    public dispose() {\r\n        if (this.state === FlowGraphState.Stopped) {\r\n            return;\r\n        }\r\n        this.state = FlowGraphState.Stopped;\r\n        for (const context of this._executionContexts) {\r\n            context._clearPendingBlocks();\r\n        }\r\n        this._executionContexts.length = 0;\r\n        for (const type in this._eventBlocks) {\r\n            this._eventBlocks[type as FlowGraphEventType].length = 0;\r\n        }\r\n        this._eventObserver?.remove();\r\n        this._sceneEventCoordinator.dispose();\r\n    }\r\n\r\n    /**\r\n     * Executes a function in all blocks of a flow graph, starting with the event blocks.\r\n     * @param visitor the function to execute.\r\n     */\r\n    public visitAllBlocks(visitor: (block: FlowGraphBlock) => void) {\r\n        const visitList: FlowGraphBlock[] = [];\r\n        const idsAddedToVisitList = new Set<string>();\r\n        for (const type in this._eventBlocks) {\r\n            for (const block of this._eventBlocks[type as FlowGraphEventType]) {\r\n                visitList.push(block);\r\n                idsAddedToVisitList.add(block.uniqueId);\r\n            }\r\n        }\r\n\r\n        while (visitList.length > 0) {\r\n            const block = visitList.pop()!;\r\n            visitor(block);\r\n\r\n            for (const dataIn of block.dataInputs) {\r\n                for (const connection of dataIn._connectedPoint) {\r\n                    if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                        visitList.push(connection._ownerBlock);\r\n                        idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                    }\r\n                }\r\n            }\r\n            if (block instanceof FlowGraphExecutionBlock) {\r\n                for (const signalOut of block.signalOutputs) {\r\n                    for (const connection of signalOut._connectedPoint) {\r\n                        if (!idsAddedToVisitList.has(connection._ownerBlock.uniqueId)) {\r\n                            visitList.push(connection._ownerBlock);\r\n                            idsAddedToVisitList.add(connection._ownerBlock.uniqueId);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes a graph\r\n     * @param serializationObject the object to write the values in\r\n     * @param valueSerializeFunction a function to serialize complex values\r\n     */\r\n    public serialize(serializationObject: any = {}, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject.allBlocks = [];\r\n        this.visitAllBlocks((block) => {\r\n            const serializedBlock: any = {};\r\n            block.serialize(serializedBlock);\r\n            serializationObject.allBlocks.push(serializedBlock);\r\n        });\r\n        serializationObject.executionContexts = [];\r\n        for (const context of this._executionContexts) {\r\n            const serializedContext: any = {};\r\n            context.serialize(serializedContext, valueSerializeFunction);\r\n            serializationObject.executionContexts.push(serializedContext);\r\n        }\r\n    }\r\n}\r\n","import type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Scene } from \"../scene\";\r\nimport { FlowGraph } from \"./flowGraph\";\r\nimport type { IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\n/**\r\n * Parameters used to create a flow graph engine.\r\n */\r\nexport interface IFlowGraphCoordinatorConfiguration {\r\n    /**\r\n     * The scene that the flow graph engine belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n\r\n/**\r\n * Parameters used to parse a flow graph coordinator.\r\n */\r\nexport interface IFlowGraphCoordinatorParseOptions {\r\n    /**\r\n     * A function that will be called to parse the value of a property.\r\n     * @param key the key of the property\r\n     * @param serializationObject the serialization object where the property is located\r\n     * @param scene the scene that the block is being parsed in\r\n     */\r\n    valueParseFunction?: (key: string, serializationObject: any, assetsContainer: IAssetContainer, scene: Scene) => any;\r\n    /**\r\n     * The path converter to use to convert the path to an object accessor.\r\n     */\r\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\r\n    /**\r\n     * The scene that the flow graph coordinator belongs to.\r\n     */\r\n    scene: Scene;\r\n}\r\n/**\r\n * This class holds all of the existing flow graphs and is responsible for creating new ones.\r\n * It also handles starting/stopping multiple graphs and communication between them through an Event Coordinator\r\n * This is the entry point for the flow graph system.\r\n * @experimental This class is still in development and is subject to change.\r\n */\r\nexport class FlowGraphCoordinator {\r\n    /**\r\n     * The maximum number of events per type.\r\n     * This is used to limit the number of events that can be created in a single scene.\r\n     * This is to prevent infinite loops.\r\n     */\r\n    public static MaxEventsPerType: number = 30;\r\n\r\n    /**\r\n     * The maximum number of execution of a specific event in a single frame.\r\n     */\r\n    public static MaxEventTypeExecutionPerFrame: number = 30;\r\n    /**\r\n     * @internal\r\n     * A list of all the coordinators per scene. Will be used by the inspector\r\n     */\r\n    public static readonly SceneCoordinators: Map<Scene, FlowGraphCoordinator[]> = new Map();\r\n\r\n    /**\r\n     * When set to true (default) custom events will be dispatched synchronously.\r\n     * This means that the events will be dispatched immediately when they are triggered.\r\n     */\r\n    public dispatchEventsSynchronously: boolean = true;\r\n\r\n    private readonly _flowGraphs: FlowGraph[] = [];\r\n\r\n    private _customEventsMap: Map<string, Observable<any>> = new Map();\r\n\r\n    private _eventExecutionCounter: Map<string, number> = new Map();\r\n\r\n    private _disposeObserver: Observer<Scene>;\r\n    private _onBeforeRenderObserver: Observer<Scene>;\r\n    private _executeOnNextFrame: { id: string; data?: any; uniqueId: number }[] = [];\r\n    private _eventUniqueId: number = 0;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public config: IFlowGraphCoordinatorConfiguration\r\n    ) {\r\n        // When the scene is disposed, dispose all graphs currently running on it.\r\n        this._disposeObserver = this.config.scene.onDisposeObservable.add(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._onBeforeRenderObserver = this.config.scene.onBeforeRenderObservable.add(() => {\r\n            // Reset the event execution counter at the beginning of each frame.\r\n            this._eventExecutionCounter.clear();\r\n            // duplicate the _executeOnNextFrame array to avoid modifying it while iterating over it\r\n            const executeOnNextFrame = this._executeOnNextFrame.slice(0);\r\n            if (executeOnNextFrame.length) {\r\n                // Execute the events that were triggered on the next frame.\r\n                for (const event of executeOnNextFrame) {\r\n                    this.notifyCustomEvent(event.id, event.data, false);\r\n                    // remove the event from the array\r\n                    const index = this._executeOnNextFrame.findIndex((e) => e.uniqueId === event.uniqueId);\r\n                    if (index !== -1) {\r\n                        this._executeOnNextFrame.splice(index, 1);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        // Add itself to the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        coordinators.push(this);\r\n    }\r\n\r\n    /**\r\n     * Creates a new flow graph and adds it to the list of existing flow graphs\r\n     * @returns a new flow graph\r\n     */\r\n    public createGraph(): FlowGraph {\r\n        const graph = new FlowGraph({ scene: this.config.scene, coordinator: this });\r\n        this._flowGraphs.push(graph);\r\n        return graph;\r\n    }\r\n\r\n    /**\r\n     * Removes a flow graph from the list of existing flow graphs and disposes it\r\n     * @param graph the graph to remove\r\n     */\r\n    public removeGraph(graph: FlowGraph) {\r\n        const index = this._flowGraphs.indexOf(graph);\r\n        if (index !== -1) {\r\n            graph.dispose();\r\n            this._flowGraphs.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Starts all graphs\r\n     */\r\n    public start() {\r\n        for (const graph of this._flowGraphs) {\r\n            graph.start();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes all graphs\r\n     */\r\n    public dispose() {\r\n        for (const graph of this._flowGraphs) {\r\n            graph.dispose();\r\n        }\r\n        this._flowGraphs.length = 0;\r\n        this._disposeObserver?.remove();\r\n        this._onBeforeRenderObserver?.remove();\r\n\r\n        // Remove itself from the SceneCoordinators list for the Inspector.\r\n        const coordinators = FlowGraphCoordinator.SceneCoordinators.get(this.config.scene) ?? [];\r\n        const index = coordinators.indexOf(this);\r\n        if (index !== -1) {\r\n            coordinators.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serializes this coordinator to a JSON object.\r\n     * @param serializationObject the object to serialize to\r\n     * @param valueSerializeFunction the function to use to serialize the value\r\n     */\r\n    public serialize(serializationObject: any, valueSerializeFunction?: (key: string, value: any, serializationObject: any) => void) {\r\n        serializationObject._flowGraphs = [];\r\n        for (const graph of this._flowGraphs) {\r\n            const serializedGraph = {};\r\n            graph.serialize(serializedGraph, valueSerializeFunction);\r\n            serializationObject._flowGraphs.push(serializedGraph);\r\n        }\r\n        serializationObject.dispatchEventsSynchronously = this.dispatchEventsSynchronously;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of flow graphs\r\n     */\r\n    public get flowGraphs() {\r\n        return this._flowGraphs;\r\n    }\r\n\r\n    /**\r\n     * Get an observable that will be notified when the event with the given id is fired.\r\n     * @param id the id of the event\r\n     * @returns the observable for the event\r\n     */\r\n    public getCustomEventObservable(id: string): Observable<any> {\r\n        let observable = this._customEventsMap.get(id);\r\n        if (!observable) {\r\n            // receive event is initialized before scene start, so no need to notify if triggered. but possible!\r\n            observable = new Observable<any>(/*undefined, true*/);\r\n            this._customEventsMap.set(id, observable);\r\n        }\r\n        return observable;\r\n    }\r\n\r\n    /**\r\n     * Notifies the observable for the given event id with the given data.\r\n     * @param id the id of the event\r\n     * @param data the data to send with the event\r\n     * @param async if true, the event will be dispatched asynchronously\r\n     */\r\n    public notifyCustomEvent(id: string, data: any, async: boolean = !this.dispatchEventsSynchronously) {\r\n        if (async) {\r\n            this._executeOnNextFrame.push({ id, data, uniqueId: this._eventUniqueId++ });\r\n            return;\r\n        }\r\n        // check if we are not exceeding the max number of events\r\n        if (this._eventExecutionCounter.has(id)) {\r\n            const count = this._eventExecutionCounter.get(id)!;\r\n            this._eventExecutionCounter.set(id, count + 1);\r\n            if (count >= FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\r\n                if (count === FlowGraphCoordinator.MaxEventTypeExecutionPerFrame) {\r\n                    Logger.Warn(`FlowGraphCoordinator: Too many executions of event \"${id}\".`);\r\n                }\r\n                return;\r\n            }\r\n        } else {\r\n            this._eventExecutionCounter.set(id, 1);\r\n        }\r\n        const observable = this._customEventsMap.get(id);\r\n        if (observable) {\r\n            observable.notifyObservers(data);\r\n        }\r\n    }\r\n}\r\n"],"names":["_IsDescendantOf","mesh1","mesh2","parent","_GetClassNameOf","v","getClassName","_AreSameVectorOrQuaternionClass","className","className2","_AreSameMatrixClass","_AreSameIntegerClass","isNumeric","a","validIfNaN","value","isNaN","getNumericValue","FlowGraphSignalConnection","priority","_isSingularConnection","connectTo","point","super","this","_connectedPoint","sort","b","_activateSignal","context","logger","addLogItem","action","_ownerBlock","uniqueId","payload","connectionType","name","_notifyExecuteNode","_execute","_increaseExecutionId","connectedPoint","FlowGraphExecutionBlock","config","signalInputs","signalOutputs","in","_registerSignalInput","error","_registerSignalOutput","input","push","output","_unregisterSignalInput","index","findIndex","dispose","splice","_unregisterSignalOutput","_reportError","Error","getSignalInput","find","getSignalOutput","serialize","serializationObject","serializedInput","serializedOutput","deserialize","i","length","signalInput","signalOutput","CustomBlocks","GetDataOutConnectionByUniqueId","blocks","block","dataOut","dataOutputs","GetSignalInConnectionByUniqueId","signalIn","ParseFlowGraphContext","options","rightHanded","result","graph","createContext","enableLogging","treatDataAsRightHanded","valueParseFunction","scene","getScene","_assetsContext","ac","assetsContext","meshes","map","m","getMeshById","lights","l","getLightByName","cameras","c","getCameraByName","materials","getMaterialById","textures","t","getTextureByName","animations","anim","skeletons","s","getSkeletonByName","particleSystems","ps","getParticleSystemById","animationGroups","ag","getAnimationGroupByName","transformNodes","tn","getTransformNodeById","rootNodes","multiMaterials","morphTargetManagers","geometries","actionManagers","environmentTexture","postProcesses","sounds","effectLayers","layers","reflectionProbes","lensFlareSystems","proceduralTextures","getNodes","key","_userVariables","userVariables","_connectionValues","_setConnectionValueByKey","ParseFlowGraphBlockWithClassType","parseOptions","classType","parsedConfig","assetsContainer","pathConverter","obj","dataInputs","dataInput","getDataInput","dataOutput","getDataOutput","metadata","gltfTypeToBabylonType","float","flowGraphType","elementType","bool","float2","float3","float4","float4x4","float2x2","float3x3","int","InteractivityGraphToFlowGraphParser","constructor","_interactivityGraph","_gltf","_animationTargetFps","_types","_mappings","_staticVariables","_events","_internalEventsCounter","_nodes","_parseTypes","_parseDeclarations","_parseVariables","_parseEvents","_parseNodes","arrays","types","mappings","staticVariables","events","nodes","type","signature","declarations","declaration","mapping","flowGraphMapping","fullOperationName","extension","op","variables","variable","parsed","_parseVariable","dataTransform","NaN","fill","parseFloat","event","converted","eventId","id","values","eventData","Object","keys","eventValue","undefined","node","validation","validationResult","valid","blockType","_getEmptyBlock","_parseNodeConfiguration","nodeMapping","gltfConfiguration","configuration","gltfProperty","propertyMapping","toBlock","indexOf","defaultValue","isArray","Warn","dataTransformer","_parseNodeConnections","gltfNode","flowGraphBlocks","outputMapper","flowsFromGLTF","flows","flowsKeys","flowKey","flow","flowMapping","outputs","socketOutName","socketOut","_createNewSocketConnection","inputNodeId","nodeIn","inputMapper","flowInMapping","inputs","socket","arrayMapping","startsWith","endsWith","nodeInSocketName","replace","inputBlock","socketIn","connectedPointIds","valuesFromGLTF","valuesKeys","valueKey","valueMapping","socketInName","convertedValue","nodeOutId","nodeOutSocketName","nodeOut","outBlock","interBlockConnectors","connector","isVariable","_connectFlowGraphNodes","inputBlockIndex","outputBlockIndex","extraProcessor","isOutput","_connectionType","inputArray","outputArray","inputConnection","outputConnection","getVariableName","serializeToFlowGraph","allBlocks","reduce","acc","val","concat","executionContexts","NAME","KHR_interactivity","_loader","enabled","isExtensionUsed","_pathConverter","gltf","_skipStartAnimationStep","babylonScene","get","activeCamera","quat","FromRotationMatrix","getWorldMatrix","normalize","useRightHandedSystem","w","x","getTarget","pos","getTranslation","animation","_babylonAnimationGroup","isPlaying","from","to","getCurrentFrame","_AddInteractivityObjectModel","onReady","interactivityDefinition","extensions","coordinator","dispatchEventsSynchronously","graphs","targetFps","Promise","all","async","resolvedClasses","serializedBlock","classFactory","blockName","FlowGraphPlayAnimationBlock","FlowGraphStopAnimationBlock","FlowGraphPauseAnimationBlock","FlowGraphInterpolationBlock","FlowGraphSceneReadyEventBlock","FlowGraphSceneTickEventBlock","FlowGraphSendCustomEventBlock","FlowGraphReceiveCustomEventBlock","FlowGraphMeshPickEventBlock","FlowGraphEBlock","FlowGraphPiBlock","FlowGraphInfBlock","FlowGraphNaNBlock","FlowGraphRandomBlock","FlowGraphAddBlock","FlowGraphSubtractBlock","FlowGraphMultiplyBlock","FlowGraphDivideBlock","FlowGraphAbsBlock","FlowGraphSignBlock","FlowGraphTruncBlock","FlowGraphFloorBlock","FlowGraphCeilBlock","FlowGraphRoundBlock","FlowGraphFractionBlock","FlowGraphNegationBlock","FlowGraphModuloBlock","FlowGraphMinBlock","FlowGraphMaxBlock","FlowGraphClampBlock","FlowGraphSaturateBlock","FlowGraphMathInterpolationBlock","FlowGraphEqualityBlock","FlowGraphLessThanBlock","FlowGraphLessThanOrEqualBlock","FlowGraphGreaterThanBlock","FlowGraphGreaterThanOrEqualBlock","FlowGraphIsNanBlock","FlowGraphIsInfinityBlock","FlowGraphDegToRadBlock","FlowGraphRadToDegBlock","FlowGraphSinBlock","FlowGraphCosBlock","FlowGraphTanBlock","FlowGraphAsinBlock","FlowGraphAcosBlock","FlowGraphAtanBlock","FlowGraphAtan2Block","FlowGraphSinhBlock","FlowGraphCoshBlock","FlowGraphTanhBlock","FlowGraphAsinhBlock","FlowGraphAcoshBlock","FlowGraphAtanhBlock","FlowGraphExpBlock","FlowGraphLogBlock","FlowGraphLog2Block","FlowGraphLog10Block","FlowGraphSquareRootBlock","FlowGraphPowerBlock","FlowGraphCubeRootBlock","FlowGraphBitwiseAndBlock","FlowGraphBitwiseOrBlock","FlowGraphBitwiseNotBlock","FlowGraphBitwiseXorBlock","FlowGraphBitwiseLeftShiftBlock","FlowGraphBitwiseRightShiftBlock","FlowGraphLengthBlock","FlowGraphNormalizeBlock","FlowGraphDotBlock","FlowGraphCrossBlock","FlowGraphRotate2DBlock","FlowGraphRotate3DBlock","FlowGraphTransposeBlock","FlowGraphDeterminantBlock","FlowGraphInvertMatrixBlock","FlowGraphMatrixMultiplicationBlock","FlowGraphBranchBlock","FlowGraphSetDelayBlock","FlowGraphCancelDelayBlock","FlowGraphCallCounterBlock","FlowGraphDebounceBlock","FlowGraphThrottleBlock","FlowGraphDoNBlock","FlowGraphFlipFlopBlock","FlowGraphForLoopBlock","FlowGraphMultiGateBlock","FlowGraphSequenceBlock","FlowGraphSwitchBlock","FlowGraphWaitAllBlock","FlowGraphWhileLoopBlock","FlowGraphConsoleLogBlock","FlowGraphConditionalDataBlock","FlowGraphConstantBlock","FlowGraphTransformCoordinatesSystemBlock","FlowGraphGetAssetBlock","FlowGraphGetPropertyBlock","FlowGraphSetPropertyBlock","FlowGraphGetVariableBlock","FlowGraphSetVariableBlock","FlowGraphJsonPointerParserBlock","FlowGraphLeadingZerosBlock","FlowGraphTrailingZerosBlock","FlowGraphOneBitsCounterBlock","FlowGraphCombineVector2Block","FlowGraphCombineVector3Block","FlowGraphCombineVector4Block","FlowGraphCombineMatrixBlock","FlowGraphExtractVector2Block","FlowGraphExtractVector3Block","FlowGraphExtractVector4Block","FlowGraphExtractMatrixBlock","FlowGraphTransformBlock","FlowGraphTransformCoordinatesBlock","FlowGraphConjugateBlock","FlowGraphAngleBetweenBlock","FlowGraphQuaternionFromAxisAngleBlock","FlowGraphAxisAngleFromQuaternionBlock","FlowGraphQuaternionFromDirectionsBlock","FlowGraphMatrixDecomposeBlock","FlowGraphMatrixComposeBlock","FlowGraphBooleanToFloat","FlowGraphBooleanToInt","FlowGraphFloatToBoolean","FlowGraphIntToBoolean","FlowGraphIntToFloat","FlowGraphFloatToInt","FlowGraphEasingBlock","FlowGraphBezierCurveEasingBlock","FlowGraphPointerOverEventBlock","FlowGraphPointerOutEventBlock","FlowGraphContextBlock","FlowGraphArrayIndexBlock","FlowGraphCodeExecutionBlock","FlowGraphIndexOfBlock","FlowGraphFunctionReferenceBlock","FlowGraphDataSwitchBlock","createGraph","addEventBlock","dataIn","serializedConnection","connection","signalOut","serializedContext","ParseFlowGraph","ParseFlowGraphAsync","start","factory","FlowGraphGLTFDataProvider","loader","IsVectorClassName","defaultValueSerializationFunction","IsMatrixClassName","asArray","defaultValueParseFunction","intermediateValue","finalValue","IsMeshClassName","filter","flipHandedness","FromArray","ParseVector","IsAnimationGroupClassName","ags","FromValue","Array","needsPathConverter","FlowGraphDataConnection","ownerBlock","richType","_defaultValue","_optional","_isDisabled","_lastValue","onValueChangedObservable","optional","isDisabled","disconnectFromAll","setValue","_getConnectionValue","_setConnectionValue","notifyObservers","resetToDefaultValue","_getValueOrDefault","getValue","_updateOutputs","typeTransformer","isConnected","_getLastValue","FlowGraphBlock","_context","registerDataInput","registerDataOutput","_valueSerializeFunction","_serializationObject","_log","FlowGraphExecutionBlockWithOutSignal","out","FlowGraphConnectionType","FlowGraphConnection","disconnectFrom","removeFromLocal","indexLocal","indexConnected","FlowGraphEventBlock","initPriority","done","FlowGraphAsyncExecutionBlock","_eventsSignalOutputs","eventName","_executeOnTick","_startPendingTasks","_getExecutionVariable","_cancelPendingTasks","_resetAfterCanceled","_preparePendingTasks","_addPendingBlock","_setExecutionVariable","_deleteExecutionVariable","_removePendingBlock","FlowGraphAssetType","GetFlowGraphAssetWithType","useIndexAsUniqueId","FlowGraphAction","FlowGraphLogger","logToConsole","log","item","time","Date","now","Log","split","JSON","stringify","toString","getItemsOfType","FlowGraphContext","_enableLogging","params","_executionVariables","_globalContextVariables","_pendingBlocks","_executionId","onNodeExecutedObservable","_configuration","hasVariable","setVariable","getAsset","getVariable","_getUniqueIdPrefixedName","_getGlobalContextVariable","possibleValue","_hasGlobalContextVariable","_setGlobalContextVariable","_deleteGlobalContextVariable","_hasExecutionVariable","_hasConnectionValue","connectionPoint","connectionPointId","hasPendingBlocks","includes","_clearPendingBlocks","_notifyOnTick","framePayload","timeSinceStart","deltaTime","executionId","valueSerializationFunction","FlowGraphSceneEventCoordinator","onEventTriggeredObservable","sceneReadyTriggered","_pointerUnderMeshState","_startingTime","_scene","_initialize","_sceneReadyObserver","onReadyObservable","add","_sceneDisposeObserver","onDisposeObservable","_sceneOnBeforeRenderObserver","onBeforeRenderObservable","getEngine","getDeltaTime","_meshPickedObserver","onPointerObservable","pointerInfo","POINTERPICK","_meshUnderPointerObserver","onMeshUnderPointerUpdatedObservable","data","pointerId","mesh","previousState","over","POINTERMOVE","remove","clear","FlowGraphState","FlowGraph","state","_state","onStateChangedObservable","_eventBlocks","_executionContexts","_sceneEventCoordinator","_coordinator","_eventObserver","order","_getContextualOrder","_executeEvent","getContext","constantlyUpdateMeshUnderPointer","addOnce","_startPendingEvents","isReady","meshPickOrder","block1","asset","visitAllBlocks","visitor","visitList","idsAddedToVisitList","Set","pop","has","valueSerializeFunction","FlowGraphCoordinator","_flowGraphs","_customEventsMap","Map","_eventExecutionCounter","_executeOnNextFrame","_eventUniqueId","_disposeObserver","_onBeforeRenderObserver","executeOnNextFrame","slice","notifyCustomEvent","e","SceneCoordinators","removeGraph","coordinators","serializedGraph","flowGraphs","getCustomEventObservable","observable","set","count","MaxEventTypeExecutionPerFrame","MaxEventsPerType"],"ignoreList":[],"sourceRoot":""}