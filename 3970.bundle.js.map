{"version":3,"file":"3970.bundle.js","mappings":"mOA8BO,MAAMA,UAAoC,IAoC7C,YAIoBC,GAEhBC,MAAMD,GAFU,KAAAA,OAAAA,EANK,KAAAE,KAAI,WASzBC,KAAKC,MAAQD,KAAKE,kBAAkB,QAAS,KAAaL,GAAQM,YAClEH,KAAKI,YAAcJ,KAAKK,mBAAmB,cAAe,MAC1DL,KAAKM,WAAaN,KAAKK,mBAAmB,aAAc,MACxDL,KAAKO,UAAYP,KAAKK,mBAAmB,YAAa,MACtDL,KAAKQ,WAAaR,KAAKK,mBAAmB,aAAc,MACxDL,KAAKS,YAAcT,KAAKE,kBAAkB,cAAe,KAAa,KAAkBQ,YAC5F,CAEO,kBAAAC,CAAmBC,GACtB,OAAOZ,KAAKC,MAAMY,SAASD,EAC/B,CAEgB,aAAAE,CAAcF,EAA2BG,GAGrD,GADoBf,KAAKS,YAAYI,SAASD,KAC1BG,EAAWhB,KAE3B,OAAO,EAGX,MAAMiB,EAAOhB,KAAKW,mBAAmBC,GACrC,OAAII,GAAQD,EAAWE,UAAUT,aAAeO,EAAWE,UAAUT,aAAeQ,IAAQ,QAAgBD,EAAWE,UAAUT,WAAYQ,KACzIhB,KAAKO,UAAUW,SAAUH,EAAWI,MAAuBZ,UAAWK,GACtEZ,KAAKM,WAAWY,SAASH,EAAWE,SAASG,KAAKC,OAAST,GAC3DZ,KAAKI,YAAYc,SAASH,EAAWE,SAASb,YAAcQ,GAC5DZ,KAAKQ,WAAWU,SAASH,EAAWE,SAAST,WAAYI,GACzDZ,KAAKsB,SAASV,IAENZ,KAAKH,QAAQ0B,kBAGrBvB,KAAKO,UAAUiB,oBAAoBZ,GACnCZ,KAAKM,WAAWkB,oBAAoBZ,GACpCZ,KAAKI,YAAYoB,oBAAoBZ,GACrCZ,KAAKQ,WAAWgB,oBAAoBZ,IAEjC,EACX,CAKgB,oBAAAa,CAAqBC,GAErC,CAKgB,mBAAAC,CAAoBD,GAEpC,CAKgB,YAAAE,GACZ,MAAO,6BACX,GAEJ,QAAc,8BAAmChC,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Event/flowGraphMeshPickEventBlock.ts?"],"sourcesContent":["import type { AbstractMesh } from \"../../../Meshes/abstractMesh\";\r\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock\";\r\nimport type { PointerInfo } from \"../../../Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"../../../Events/pointerEvents\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { _IsDescendantOf } from \"../../utils\";\r\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\r\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\r\nimport { RichTypeAny, RichTypeNumber, RichTypeVector3 } from \"core/FlowGraph/flowGraphRichTypes\";\r\nimport type { Vector3 } from \"core/Maths/math.vector\";\r\nimport { FlowGraphEventType } from \"core/FlowGraph/flowGraphEventType\";\r\n/**\r\n * Configuration for the mesh pick event block.\r\n */\r\nexport interface IFlowGraphMeshPickEventBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * Should this mesh block propagation of the event.\r\n     */\r\n    stopPropagation?: boolean;\r\n\r\n    /**\r\n     * The mesh to listen to. Can also be set by the asset input.\r\n     */\r\n    targetMesh?: AbstractMesh;\r\n}\r\n/**\r\n * A block that activates when a mesh is picked.\r\n */\r\nexport class FlowGraphMeshPickEventBlock extends FlowGraphEventBlock {\r\n    /**\r\n     * Input connection: The mesh to listen to.\r\n     */\r\n    public readonly asset: FlowGraphDataConnection<AbstractMesh>;\r\n\r\n    /**\r\n     * Output connection: The picked point.\r\n     */\r\n    public readonly pickedPoint: FlowGraphDataConnection<Vector3>;\r\n\r\n    /**\r\n     * Output connection: The picked origin.\r\n     */\r\n    public readonly pickOrigin: FlowGraphDataConnection<Vector3>;\r\n\r\n    /**\r\n     * Output connection: The pointer id.\r\n     */\r\n    public readonly pointerId: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The picked mesh. Possibly NOT the same as the asset (could be a descendant).\r\n     */\r\n    public readonly pickedMesh: FlowGraphDataConnection<AbstractMesh>;\r\n\r\n    /**\r\n     * Input connection: The type of the pointer event.\r\n     */\r\n    public readonly pointerType: FlowGraphDataConnection<PointerEventTypes>;\r\n\r\n    /**\r\n     * the type of the event this block reacts to\r\n     */\r\n    public override readonly type: FlowGraphEventType = FlowGraphEventType.MeshPick;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config?: IFlowGraphMeshPickEventBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        this.asset = this.registerDataInput(\"asset\", RichTypeAny, config?.targetMesh);\r\n        this.pickedPoint = this.registerDataOutput(\"pickedPoint\", RichTypeVector3);\r\n        this.pickOrigin = this.registerDataOutput(\"pickOrigin\", RichTypeVector3);\r\n        this.pointerId = this.registerDataOutput(\"pointerId\", RichTypeNumber);\r\n        this.pickedMesh = this.registerDataOutput(\"pickedMesh\", RichTypeAny);\r\n        this.pointerType = this.registerDataInput(\"pointerType\", RichTypeAny, PointerEventTypes.POINTERPICK);\r\n    }\r\n\r\n    public _getReferencedMesh(context: FlowGraphContext): AbstractMesh {\r\n        return this.asset.getValue(context);\r\n    }\r\n\r\n    public override _executeEvent(context: FlowGraphContext, pickedInfo: PointerInfo): boolean {\r\n        // get the pointer type\r\n        const pointerType = this.pointerType.getValue(context);\r\n        if (pointerType !== pickedInfo.type) {\r\n            // returning true here to continue the propagation of the pointer event to the rest of the blocks\r\n            return true;\r\n        }\r\n        // check if the mesh is the picked mesh or a descendant\r\n        const mesh = this._getReferencedMesh(context);\r\n        if (mesh && pickedInfo.pickInfo?.pickedMesh && (pickedInfo.pickInfo?.pickedMesh === mesh || _IsDescendantOf(pickedInfo.pickInfo?.pickedMesh, mesh))) {\r\n            this.pointerId.setValue((pickedInfo.event as PointerEvent).pointerId, context);\r\n            this.pickOrigin.setValue(pickedInfo.pickInfo.ray?.origin!, context);\r\n            this.pickedPoint.setValue(pickedInfo.pickInfo.pickedPoint!, context);\r\n            this.pickedMesh.setValue(pickedInfo.pickInfo.pickedMesh, context);\r\n            this._execute(context);\r\n            // stop the propagation if the configuration says so\r\n            return !this.config?.stopPropagation;\r\n        } else {\r\n            // reset the outputs\r\n            this.pointerId.resetToDefaultValue(context);\r\n            this.pickOrigin.resetToDefaultValue(context);\r\n            this.pickedPoint.resetToDefaultValue(context);\r\n            this.pickedMesh.resetToDefaultValue(context);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _preparePendingTasks(_context: FlowGraphContext): void {\r\n        // no-op\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _cancelPendingTasks(_context: FlowGraphContext): void {\r\n        // no-op\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.MeshPickEvent;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.MeshPickEvent, FlowGraphMeshPickEventBlock);\r\n"],"names":["FlowGraphMeshPickEventBlock","config","super","type","this","asset","registerDataInput","targetMesh","pickedPoint","registerDataOutput","pickOrigin","pointerId","pickedMesh","pointerType","POINTERPICK","_getReferencedMesh","context","getValue","_executeEvent","pickedInfo","mesh","pickInfo","setValue","event","ray","origin","_execute","stopPropagation","resetToDefaultValue","_preparePendingTasks","_context","_cancelPendingTasks","getClassName"],"ignoreList":[],"sourceRoot":""}