"use strict";(self.webpackChunk_dev_inspector_v2=self.webpackChunk_dev_inspector_v2||[]).push([[6659],{6659:(e,n,t)=>{t.r(n),t.d(n,{depthVertexShaderWGSL:()=>f});var i=t(75876);t(9308),t(4842),t(82518),t(791),t(56323),t(17489),t(93024),t(92779),t(18875),t(62392),t(46652),t(8991);const r="depthVertexShader",d="attribute position: vec3f;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform viewProjection: mat4x4f;uniform depthValues: vec2f;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vUV: vec2f;uniform diffuseMatrix: mat4x4f;\n#ifdef UV1\nattribute uv: vec2f;\n#endif\n#ifdef UV2\nattribute uv2: vec2f;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform view: mat4x4f;varying vViewPos: vec4f;\n#endif\nvarying vDepthMetric: f32;\n#define CUSTOM_VERTEX_DEFINITIONS\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var positionUpdated: vec3f=input.position;\n#ifdef UV1\nvar uvUpdated: vec2f=input.uv;\n#endif\n#ifdef UV2\nvar uv2Updated: vec2f=input.uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvar worldPos: vec4f=finalWorld* vec4f(positionUpdated,1.0);\n#include<clipPlaneVertex>\nvertexOutputs.position=uniforms.viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvertexOutputs.vViewPos=uniforms.view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#else\nvertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uvUpdated,1.0,0.0)).xy;\n#endif\n#ifdef UV2\nvertexOutputs.vUV= (uniforms.diffuseMatrix* vec4f(uv2Updated,1.0,0.0)).xy;\n#endif\n#endif\n}\n";i.l.ShadersStoreWGSL[r]||(i.l.ShadersStoreWGSL[r]=d);const f={name:r,shader:d}}}]);
//# sourceMappingURL=6659.bundle.js.map