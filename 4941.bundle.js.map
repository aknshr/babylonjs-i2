{"version":3,"file":"4941.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/Misc/videoRecorder.ts?","webpack://@dev/inspector-v2/../core/src/Probes/reflectionProbe.ts?","webpack://@dev/inspector-v2/../core/src/Shaders/equirectangularPanorama.fragment.ts?","webpack://@dev/inspector-v2/./src/components/tools/captureTools.tsx?","webpack://@dev/inspector-v2/../core/src/Misc/equirectangularCapture.ts?","webpack://@dev/inspector-v2/./src/services/panes/tools/captureService.tsx?"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable no-var */\r\nimport type { Nullable } from \"../types\";\r\nimport { Tools } from \"./tools\";\r\nimport type { AbstractEngine } from \"../Engines/abstractEngine\";\r\n\r\ninterface MediaRecorder {\r\n    /** Starts recording */\r\n    start(timeSlice: number): void;\r\n    /** Stops recording */\r\n    stop(): void;\r\n\r\n    /** Event raised when an error arised. */\r\n    onerror: (event: ErrorEvent) => void;\r\n    /** Event raised when the recording stops. */\r\n    onstop: (event: Event) => void;\r\n    /** Event raised when a new chunk of data is available and should be tracked. */\r\n    ondataavailable: (event: Event) => void;\r\n}\r\n\r\ninterface MediaRecorderOptions {\r\n    /** The mime type you want to use as the recording container for the new MediaRecorder. */\r\n    mimeType?: string;\r\n    /** The chosen bitrate for the audio component of the media. */\r\n    audioBitsPerSecond?: number;\r\n    /** The chosen bitrate for the video component of the media. */\r\n    videoBitsPerSecond?: number;\r\n    /** The chosen bitrate for the audio and video components of the media. This can be specified instead of the above two properties.\r\n     * If this is specified along with one or the other of the above properties, this will be used for the one that isn't specified. */\r\n    bitsPerSecond?: number;\r\n}\r\n\r\ninterface MediaRecorderConstructor {\r\n    /**\r\n     * A reference to the prototype.\r\n     */\r\n    readonly prototype: MediaRecorder;\r\n\r\n    /**\r\n     * Creates a new MediaRecorder.\r\n     * @param stream Defines the stream to record.\r\n     * @param options Defines the options for the recorder available in the type MediaRecorderOptions.\r\n     */\r\n    new (stream: MediaStream, options?: MediaRecorderOptions): MediaRecorder;\r\n}\r\n\r\n/**\r\n * MediaRecorder object available in some browsers.\r\n */\r\ndeclare var MediaRecorder: MediaRecorderConstructor;\r\n\r\n/**\r\n * This represents the different options available for the video capture.\r\n */\r\nexport interface VideoRecorderOptions {\r\n    /** The canvas you want to record */\r\n    canvas?: HTMLCanvasElement;\r\n    /** Defines the mime type of the video. */\r\n    mimeType: string;\r\n    /** Defines the FPS the video should be recorded at. */\r\n    fps: number;\r\n    /** Defines the chunk size for the recording data. */\r\n    recordChunckSize: number;\r\n    /** The audio tracks to attach to the recording. */\r\n    audioTracks?: MediaStreamTrack[];\r\n}\r\n\r\n/**\r\n * This can help with recording videos from BabylonJS.\r\n * This is based on the available WebRTC functionalities of the browser.\r\n *\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/scene/renderToVideo\r\n */\r\nexport class VideoRecorder {\r\n    private static readonly _DefaultOptions = {\r\n        mimeType: \"video/webm\",\r\n        fps: 25,\r\n        recordChunckSize: 3000,\r\n    };\r\n\r\n    /**\r\n     * Returns whether or not the VideoRecorder is available in your browser.\r\n     * @param engine Defines the Babylon Engine.\r\n     * @param canvas Defines the canvas to record. If not provided, the engine canvas will be used.\r\n     * @returns true if supported otherwise false.\r\n     */\r\n    public static IsSupported(engine: AbstractEngine, canvas?: HTMLCanvasElement): boolean {\r\n        const targetCanvas = canvas ?? engine.getRenderingCanvas();\r\n        return !!targetCanvas && typeof (<any>targetCanvas).captureStream === \"function\";\r\n    }\r\n\r\n    private readonly _options: VideoRecorderOptions;\r\n    private _canvas: Nullable<HTMLCanvasElement>;\r\n    private _mediaRecorder: Nullable<MediaRecorder>;\r\n\r\n    private _recordedChunks: any[];\r\n    private _fileName: Nullable<string>;\r\n    private _resolve: Nullable<(blob: Blob) => void>;\r\n    private _reject: Nullable<(error: any) => void>;\r\n\r\n    private _isRecording: boolean;\r\n\r\n    /**\r\n     * True when a recording is already in progress.\r\n     */\r\n    public get isRecording(): boolean {\r\n        return !!this._canvas && this._isRecording;\r\n    }\r\n\r\n    /**\r\n     * Create a new VideoCapture object which can help converting what you see in Babylon to a video file.\r\n     * @param engine Defines the BabylonJS Engine you wish to record.\r\n     * @param options Defines options that can be used to customize the capture.\r\n     */\r\n    constructor(engine: AbstractEngine, options: Partial<VideoRecorderOptions> = {}) {\r\n        if (!VideoRecorder.IsSupported(engine, options.canvas)) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Your browser does not support recording so far.\";\r\n        }\r\n\r\n        const canvas = options.canvas ?? engine.getRenderingCanvas();\r\n        if (!canvas) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"The babylon engine must have a canvas to be recorded\";\r\n        }\r\n\r\n        this._canvas = canvas;\r\n        this._isRecording = false;\r\n\r\n        this._options = {\r\n            ...VideoRecorder._DefaultOptions,\r\n            ...options,\r\n        };\r\n\r\n        const stream = this._canvas.captureStream(this._options.fps);\r\n        if (this._options.audioTracks) {\r\n            for (const track of this._options.audioTracks) {\r\n                stream.addTrack(track);\r\n            }\r\n        }\r\n\r\n        this._mediaRecorder = new MediaRecorder(stream, { mimeType: this._options.mimeType });\r\n        this._mediaRecorder.ondataavailable = (evt: Event) => this._handleDataAvailable(evt);\r\n        this._mediaRecorder.onerror = (evt: ErrorEvent) => this._handleError(evt);\r\n        this._mediaRecorder.onstop = () => this._handleStop();\r\n    }\r\n\r\n    /**\r\n     * Stops the current recording before the default capture timeout passed in the startRecording function.\r\n     */\r\n    public stopRecording(): void {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            return;\r\n        }\r\n\r\n        if (!this.isRecording) {\r\n            return;\r\n        }\r\n\r\n        this._isRecording = false;\r\n        this._mediaRecorder.stop();\r\n    }\r\n\r\n    /**\r\n     * Starts recording the canvas for a max duration specified in parameters.\r\n     * @param fileName Defines the name of the file to be downloaded when the recording stop.\r\n     * If null no automatic download will start and you can rely on the promise to get the data back.\r\n     * @param maxDuration Defines the maximum recording time in seconds.\r\n     * It defaults to 7 seconds. A value of zero will not stop automatically, you would need to call stopRecording manually.\r\n     * @returns A promise callback at the end of the recording with the video data in Blob.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n    public startRecording(fileName: Nullable<string> = \"babylonjs.webm\", maxDuration = 7): Promise<Blob> {\r\n        if (!this._canvas || !this._mediaRecorder) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Recorder has already been disposed\";\r\n        }\r\n\r\n        if (this.isRecording) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"Recording already in progress\";\r\n        }\r\n\r\n        if (maxDuration > 0) {\r\n            setTimeout(() => {\r\n                this.stopRecording();\r\n            }, maxDuration * 1000);\r\n        }\r\n\r\n        this._fileName = fileName;\r\n        this._recordedChunks = [];\r\n        this._resolve = null;\r\n        this._reject = null;\r\n\r\n        this._isRecording = true;\r\n        this._mediaRecorder.start(this._options.recordChunckSize);\r\n\r\n        return new Promise<Blob>((resolve, reject) => {\r\n            this._resolve = resolve;\r\n            this._reject = reject;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Releases internal resources used during the recording.\r\n     */\r\n    public dispose() {\r\n        this._canvas = null;\r\n        this._mediaRecorder = null;\r\n\r\n        this._recordedChunks = [];\r\n        this._fileName = null;\r\n        this._resolve = null;\r\n        this._reject = null;\r\n    }\r\n\r\n    private _handleDataAvailable(event: any): void {\r\n        if (event.data.size > 0) {\r\n            this._recordedChunks.push(event.data);\r\n        }\r\n    }\r\n\r\n    private _handleError(event: ErrorEvent): void {\r\n        this.stopRecording();\r\n\r\n        if (this._reject) {\r\n            this._reject(event.error);\r\n        } else {\r\n            throw new event.error();\r\n        }\r\n    }\r\n\r\n    private _handleStop(): void {\r\n        this.stopRecording();\r\n\r\n        const superBuffer = new Blob(this._recordedChunks);\r\n        if (this._resolve) {\r\n            this._resolve(superBuffer);\r\n        }\r\n\r\n        window.URL.createObjectURL(superBuffer);\r\n\r\n        if (this._fileName) {\r\n            Tools.Download(superBuffer, this._fileName);\r\n        }\r\n    }\r\n}\r\n","import { serializeAsMeshReference, serializeAsVector3 } from \"../Misc/decorators\";\r\nimport { SerializationHelper } from \"../Misc/decorators.serialization\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Scene } from \"../scene\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { UniformBuffer } from \"../Materials/uniformBuffer\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * The list of reflection probes added to the scene\r\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\r\n         */\r\n        reflectionProbes: Array<ReflectionProbe>;\r\n\r\n        /**\r\n         * Removes the given reflection probe from this scene.\r\n         * @param toRemove The reflection probe to remove\r\n         * @returns The index of the removed reflection probe\r\n         */\r\n        removeReflectionProbe(toRemove: ReflectionProbe): number;\r\n\r\n        /**\r\n         * Adds the given reflection probe to this scene.\r\n         * @param newReflectionProbe The reflection probe to add\r\n         */\r\n        addReflectionProbe(newReflectionProbe: ReflectionProbe): void;\r\n    }\r\n}\r\n\r\nScene.prototype.removeReflectionProbe = function (toRemove: ReflectionProbe): number {\r\n    if (!this.reflectionProbes) {\r\n        return -1;\r\n    }\r\n\r\n    const index = this.reflectionProbes.indexOf(toRemove);\r\n    if (index !== -1) {\r\n        this.reflectionProbes.splice(index, 1);\r\n    }\r\n\r\n    return index;\r\n};\r\n\r\nScene.prototype.addReflectionProbe = function (newReflectionProbe: ReflectionProbe): void {\r\n    if (!this.reflectionProbes) {\r\n        this.reflectionProbes = [];\r\n    }\r\n\r\n    this.reflectionProbes.push(newReflectionProbe);\r\n};\r\n\r\n/**\r\n * Class used to generate realtime reflection / refraction cube textures\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/environment/reflectionProbes\r\n */\r\nexport class ReflectionProbe {\r\n    private _scene: Scene;\r\n    private _renderTargetTexture: RenderTargetTexture;\r\n    private _projectionMatrix: Matrix;\r\n    private _viewMatrix = Matrix.Identity();\r\n    private _target = Vector3.Zero();\r\n    private _add = Vector3.Zero();\r\n    @serializeAsMeshReference()\r\n    private _attachedMesh: Nullable<AbstractMesh>;\r\n\r\n    private _invertYAxis = false;\r\n    private _sceneUBOs: UniformBuffer[];\r\n    private _currentSceneUBO: UniformBuffer;\r\n\r\n    /** Gets or sets probe position (center of the cube map) */\r\n    @serializeAsVector3()\r\n    public position = Vector3.Zero();\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the reflection probe.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /**\r\n     * Creates a new reflection probe\r\n     * @param name defines the name of the probe\r\n     * @param size defines the texture resolution (for each face)\r\n     * @param scene defines the hosting scene\r\n     * @param generateMipMaps defines if mip maps should be generated automatically (true by default)\r\n     * @param useFloat defines if HDR data (float data) should be used to store colors (false by default)\r\n     * @param linearSpace defines if the probe should be generated in linear space or not (false by default)\r\n     */\r\n    constructor(\r\n        /** defines the name of the probe */\r\n        public name: string,\r\n        size: number,\r\n        scene: Scene,\r\n        generateMipMaps = true,\r\n        useFloat = false,\r\n        linearSpace = false\r\n    ) {\r\n        this._scene = scene;\r\n\r\n        if (scene.getEngine().supportsUniformBuffers) {\r\n            this._sceneUBOs = [];\r\n            for (let i = 0; i < 6; ++i) {\r\n                this._sceneUBOs.push(scene.createSceneUniformBuffer(`Scene for Reflection Probe (name \"${name}\") face #${i}`));\r\n            }\r\n        }\r\n\r\n        // Create the scene field if not exist.\r\n        if (!this._scene.reflectionProbes) {\r\n            this._scene.reflectionProbes = [] as ReflectionProbe[];\r\n        }\r\n        this._scene.reflectionProbes.push(this);\r\n\r\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n        if (useFloat) {\r\n            const caps = this._scene.getEngine().getCaps();\r\n            if (caps.textureHalfFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\r\n            } else if (caps.textureFloatRender) {\r\n                textureType = Constants.TEXTURETYPE_FLOAT;\r\n            }\r\n        }\r\n        this._renderTargetTexture = new RenderTargetTexture(name, size, scene, generateMipMaps, true, textureType, true);\r\n        this._renderTargetTexture.gammaSpace = !linearSpace;\r\n        this._renderTargetTexture.invertZ = scene.useRightHandedSystem;\r\n\r\n        const useReverseDepthBuffer = scene.getEngine().useReverseDepthBuffer;\r\n\r\n        this._renderTargetTexture.onBeforeRenderObservable.add((faceIndex: number) => {\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._sceneUBOs[faceIndex]);\r\n                scene.getSceneUniformBuffer().unbindEffect();\r\n            }\r\n            switch (faceIndex) {\r\n                case 0:\r\n                    this._add.copyFromFloats(1, 0, 0);\r\n                    break;\r\n                case 1:\r\n                    this._add.copyFromFloats(-1, 0, 0);\r\n                    break;\r\n                case 2:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? 1 : -1, 0);\r\n                    break;\r\n                case 3:\r\n                    this._add.copyFromFloats(0, this._invertYAxis ? -1 : 1, 0);\r\n                    break;\r\n                case 4:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? -1 : 1);\r\n                    break;\r\n                case 5:\r\n                    this._add.copyFromFloats(0, 0, scene.useRightHandedSystem ? 1 : -1);\r\n                    break;\r\n            }\r\n\r\n            if (this._attachedMesh) {\r\n                this.position.copyFrom(this._attachedMesh.getAbsolutePosition());\r\n            }\r\n\r\n            this.position.addToRef(this._add, this._target);\r\n\r\n            const lookAtFunction = scene.useRightHandedSystem ? Matrix.LookAtRHToRef : Matrix.LookAtLHToRef;\r\n            const perspectiveFunction = scene.useRightHandedSystem ? Matrix.PerspectiveFovRH : Matrix.PerspectiveFovLH;\r\n\r\n            lookAtFunction(this.position, this._target, Vector3.Up(), this._viewMatrix);\r\n\r\n            if (scene.activeCamera) {\r\n                this._projectionMatrix = perspectiveFunction(\r\n                    Math.PI / 2,\r\n                    1,\r\n                    useReverseDepthBuffer ? scene.activeCamera.maxZ : scene.activeCamera.minZ,\r\n                    useReverseDepthBuffer ? scene.activeCamera.minZ : scene.activeCamera.maxZ,\r\n                    this._scene.getEngine().isNDCHalfZRange\r\n                );\r\n                scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix);\r\n                if (scene.activeCamera.isRigCamera && !this._renderTargetTexture.activeCamera) {\r\n                    this._renderTargetTexture.activeCamera = scene.activeCamera.rigParent || null;\r\n                }\r\n            }\r\n            scene._forcedViewPosition = this.position;\r\n        });\r\n\r\n        let currentApplyByPostProcess: boolean;\r\n\r\n        this._renderTargetTexture.onBeforeBindObservable.add(() => {\r\n            const engine = scene.getEngine();\r\n            this._currentSceneUBO = scene.getSceneUniformBuffer();\r\n            if (engine._enableGPUDebugMarkers) {\r\n                engine.restoreDefaultFramebuffer();\r\n                engine._debugPushGroup?.(`reflection probe generation for ${name}`);\r\n            }\r\n            currentApplyByPostProcess = this._scene.imageProcessingConfiguration.applyByPostProcess;\r\n            if (linearSpace) {\r\n                scene.imageProcessingConfiguration.applyByPostProcess = true;\r\n            }\r\n        });\r\n\r\n        this._renderTargetTexture.onAfterUnbindObservable.add(() => {\r\n            const engine = scene.getEngine();\r\n            scene.imageProcessingConfiguration.applyByPostProcess = currentApplyByPostProcess;\r\n            scene._forcedViewPosition = null;\r\n            if (this._sceneUBOs) {\r\n                scene.setSceneUniformBuffer(this._currentSceneUBO);\r\n            }\r\n            scene.updateTransformMatrix(true);\r\n            if (engine._enableGPUDebugMarkers) {\r\n                engine._debugPopGroup?.();\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Gets or sets the number of samples to use for multi-sampling (0 by default). Required WebGL2 */\r\n    public get samples(): number {\r\n        return this._renderTargetTexture.samples;\r\n    }\r\n\r\n    public set samples(value: number) {\r\n        this._renderTargetTexture.samples = value;\r\n    }\r\n\r\n    /** Gets or sets the refresh rate to use (on every frame by default) */\r\n    public get refreshRate(): number {\r\n        return this._renderTargetTexture.refreshRate;\r\n    }\r\n\r\n    public set refreshRate(value: number) {\r\n        this._renderTargetTexture.refreshRate = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the hosting scene\r\n     * @returns a Scene\r\n     */\r\n    public getScene(): Scene {\r\n        return this._scene;\r\n    }\r\n\r\n    /** Gets the internal CubeTexture used to render to */\r\n    public get cubeTexture(): RenderTargetTexture {\r\n        return this._renderTargetTexture;\r\n    }\r\n\r\n    /** Gets or sets the list of meshes to render */\r\n    public get renderList(): Nullable<AbstractMesh[]> {\r\n        return this._renderTargetTexture.renderList;\r\n    }\r\n\r\n    public set renderList(value: Nullable<AbstractMesh[]>) {\r\n        this._renderTargetTexture.renderList = value;\r\n    }\r\n\r\n    /**\r\n     * Attach the probe to a specific mesh (Rendering will be done from attached mesh's position)\r\n     * @param mesh defines the mesh to attach to\r\n     */\r\n    public attachToMesh(mesh: Nullable<AbstractMesh>): void {\r\n        this._attachedMesh = mesh;\r\n    }\r\n\r\n    /**\r\n     * Specifies whether or not the stencil and depth buffer are cleared between two rendering groups\r\n     * @param renderingGroupId The rendering group id corresponding to its index\r\n     * @param autoClearDepthStencil Automatically clears depth and stencil between groups if true.\r\n     */\r\n    public setRenderingAutoClearDepthStencil(renderingGroupId: number, autoClearDepthStencil: boolean): void {\r\n        this._renderTargetTexture.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);\r\n    }\r\n\r\n    /**\r\n     * Clean all associated resources\r\n     */\r\n    public dispose() {\r\n        const index = this._scene.reflectionProbes.indexOf(this);\r\n\r\n        if (index !== -1) {\r\n            // Remove from the scene if found\r\n            this._scene.reflectionProbes.splice(index, 1);\r\n        }\r\n\r\n        if (this._parentContainer) {\r\n            const index = this._parentContainer.reflectionProbes.indexOf(this);\r\n            if (index > -1) {\r\n                this._parentContainer.reflectionProbes.splice(index, 1);\r\n            }\r\n            this._parentContainer = null;\r\n        }\r\n\r\n        if (this._renderTargetTexture) {\r\n            this._renderTargetTexture.dispose();\r\n            (<any>this._renderTargetTexture) = null;\r\n        }\r\n\r\n        if (this._sceneUBOs) {\r\n            for (const ubo of this._sceneUBOs) {\r\n                ubo.dispose();\r\n            }\r\n            this._sceneUBOs = [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts the reflection probe information to a readable string for debug purpose.\r\n     * @param fullDetails Supports for multiple levels of logging within scene loading\r\n     * @returns the human readable reflection probe info\r\n     */\r\n    public toString(fullDetails?: boolean): string {\r\n        let ret = \"Name: \" + this.name;\r\n\r\n        if (fullDetails) {\r\n            ret += \", position: \" + this.position.toString();\r\n\r\n            if (this._attachedMesh) {\r\n                ret += \", attached mesh: \" + this._attachedMesh.name;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Get the class name of the refection probe.\r\n     * @returns \"ReflectionProbe\"\r\n     */\r\n    public getClassName(): string {\r\n        return \"ReflectionProbe\";\r\n    }\r\n\r\n    /**\r\n     * Serialize the reflection probe to a JSON representation we can easily use in the respective Parse function.\r\n     * @returns The JSON representation of the texture\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject = SerializationHelper.Serialize(this, this._renderTargetTexture.serialize());\r\n        serializationObject.isReflectionProbe = true;\r\n        serializationObject.metadata = this.metadata;\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse the JSON representation of a reflection probe in order to recreate the reflection probe in the given scene.\r\n     * @param parsedReflectionProbe Define the JSON representation of the reflection probe\r\n     * @param scene Define the scene the parsed reflection probe should be instantiated in\r\n     * @param rootUrl Define the root url of the parsing sequence in the case of relative dependencies\r\n     * @returns The parsed reflection probe if successful\r\n     */\r\n    public static Parse(parsedReflectionProbe: any, scene: Scene, rootUrl: string): Nullable<ReflectionProbe> {\r\n        let reflectionProbe: Nullable<ReflectionProbe> = null;\r\n        if (scene.reflectionProbes) {\r\n            for (let index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const rp = scene.reflectionProbes[index];\r\n                if (rp.name === parsedReflectionProbe.name) {\r\n                    reflectionProbe = rp;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        reflectionProbe = SerializationHelper.Parse(\r\n            () => reflectionProbe || new ReflectionProbe(parsedReflectionProbe.name, parsedReflectionProbe.renderTargetSize, scene, parsedReflectionProbe._generateMipMaps),\r\n            parsedReflectionProbe,\r\n            scene,\r\n            rootUrl\r\n        );\r\n        reflectionProbe.cubeTexture._waitingRenderList = parsedReflectionProbe.renderList;\r\n\r\n        if (parsedReflectionProbe._attachedMesh) {\r\n            reflectionProbe.attachToMesh(scene.getMeshById(parsedReflectionProbe._attachedMesh));\r\n        }\r\n\r\n        if (parsedReflectionProbe.metadata) {\r\n            reflectionProbe.metadata = parsedReflectionProbe.metadata;\r\n        }\r\n\r\n        return reflectionProbe;\r\n    }\r\n}\r\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\n\nconst name = \"equirectangularPanoramaPixelShader\";\nconst shader = `#ifdef GL_ES\nprecision highp float;\n#endif\n#define M_PI 3.1415926535897932384626433832795\nvarying vec2 vUV;uniform samplerCube cubeMap;void main(void) {vec2 uv=vUV;float longitude=uv.x*2.*M_PI-M_PI+M_PI/2.;float latitude=(1.-uv.y)*M_PI;vec3 dir=vec3(\n- sin( longitude )*sin( latitude ),\ncos( latitude ),\n- cos( longitude )*sin( latitude )\n);normalize( dir );gl_FragColor=textureCube( cubeMap,dir );}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const equirectangularPanoramaPixelShader = { name, shader };\n","import { ButtonLine } from \"shared-ui-components/fluent/hoc/buttonLine\";\r\nimport { useState, useRef, useCallback } from \"react\";\r\nimport type { FunctionComponent } from \"react\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { SyncedSliderPropertyLine } from \"shared-ui-components/fluent/hoc/propertyLines/syncedSliderPropertyLine\";\r\nimport type { IScreenshotSize } from \"core/Misc/interfaces/screenshotSize\";\r\nimport { SwitchPropertyLine } from \"shared-ui-components/fluent/hoc/propertyLines/switchPropertyLine\";\r\nimport { VideoRecorder } from \"core/Misc/videoRecorder\";\r\nimport { captureEquirectangularFromScene } from \"core/Misc/equirectangularCapture\";\r\nimport { Collapse } from \"shared-ui-components/fluent/primitives/collapse\";\r\nimport { CameraRegular, RecordRegular, RecordStopRegular } from \"@fluentui/react-icons\";\r\nimport { FrameGraphUtils } from \"core/FrameGraph/frameGraphUtils\";\r\n\r\nexport const CaptureRttTools: FunctionComponent<{ scene: Scene }> = ({ scene }) => {\r\n    const [useWidthHeight, setUseWidthHeight] = useState(false);\r\n    const [screenshotSize, setScreenshotSize] = useState<IScreenshotSize>({ precision: 1 });\r\n\r\n    const captureRender = useCallback(async () => {\r\n        const sizeToUse: IScreenshotSize = { ...screenshotSize };\r\n        if (!useWidthHeight) {\r\n            sizeToUse.width = undefined;\r\n            sizeToUse.height = undefined;\r\n        }\r\n\r\n        if (scene.activeCamera) {\r\n            Tools.CreateScreenshotUsingRenderTarget(scene.getEngine(), scene.activeCamera, sizeToUse, undefined, undefined, 4);\r\n        }\r\n    }, [scene, screenshotSize, useWidthHeight]);\r\n\r\n    return (\r\n        <>\r\n            <ButtonLine label=\"Capture\" icon={CameraRegular} onClick={captureRender} />\r\n            <SyncedSliderPropertyLine\r\n                label=\"Precision\"\r\n                value={screenshotSize.precision ?? 1}\r\n                onChange={(value) => setScreenshotSize({ ...screenshotSize, precision: value ?? 1 })}\r\n                min={0.1}\r\n                max={10}\r\n                step={0.1}\r\n            />\r\n            <SwitchPropertyLine label=\"Use Custom Width/Height\" value={useWidthHeight} onChange={(value) => setUseWidthHeight(value)} />\r\n            <Collapse visible={useWidthHeight}>\r\n                <SyncedSliderPropertyLine\r\n                    label=\"Width\"\r\n                    value={screenshotSize.width ?? 512}\r\n                    onChange={(data) => setScreenshotSize({ ...screenshotSize, width: data ?? 512 })}\r\n                    min={1}\r\n                    step={1}\r\n                />\r\n                <SyncedSliderPropertyLine\r\n                    label=\"Height\"\r\n                    value={screenshotSize.height ?? 512}\r\n                    onChange={(data) => setScreenshotSize({ ...screenshotSize, height: data ?? 512 })}\r\n                    min={1}\r\n                    step={1}\r\n                />\r\n            </Collapse>\r\n        </>\r\n    );\r\n};\r\n\r\nexport const CaptureScreenshotTools: FunctionComponent<{ scene: Scene }> = ({ scene }) => {\r\n    const [isRecording, setIsRecording] = useState(false);\r\n    const videoRecorder = useRef<VideoRecorder>();\r\n\r\n    const captureScreenshot = useCallback(() => {\r\n        const camera = scene.frameGraph ? FrameGraphUtils.FindMainCamera(scene.frameGraph) : scene.activeCamera;\r\n        if (camera) {\r\n            Tools.CreateScreenshot(scene.getEngine(), camera, { precision: 1 });\r\n        }\r\n    }, [scene]);\r\n\r\n    const captureEquirectangularAsync = useCallback(async () => {\r\n        const currentActiveCamera = scene.activeCamera;\r\n        if (!currentActiveCamera && scene.frameGraph) {\r\n            scene.activeCamera = FrameGraphUtils.FindMainCamera(scene.frameGraph);\r\n        }\r\n        if (scene.activeCamera) {\r\n            await captureEquirectangularFromScene(scene, { size: 1024, filename: \"equirectangular_capture.png\" });\r\n        }\r\n        // eslint-disable-next-line require-atomic-updates\r\n        scene.activeCamera = currentActiveCamera;\r\n    }, [scene]);\r\n\r\n    const recordVideoAsync = useCallback(async () => {\r\n        if (videoRecorder.current && videoRecorder.current.isRecording) {\r\n            videoRecorder.current.stopRecording();\r\n            setIsRecording(false);\r\n            return;\r\n        }\r\n\r\n        if (!videoRecorder.current) {\r\n            videoRecorder.current = new VideoRecorder(scene.getEngine());\r\n        }\r\n\r\n        void videoRecorder.current.startRecording();\r\n        setIsRecording(true);\r\n    }, [scene]);\r\n\r\n    return (\r\n        <>\r\n            <ButtonLine label=\"Capture\" icon={CameraRegular} onClick={captureScreenshot} />\r\n            <ButtonLine label=\"Capture Equirectangular\" icon={CameraRegular} onClick={captureEquirectangularAsync} />\r\n            <ButtonLine\r\n                label={isRecording ? \"Stop Recording\" : \"Record Video\"}\r\n                itemId=\"Start/Stop Recording\"\r\n                icon={isRecording ? RecordStopRegular : RecordRegular}\r\n                onClick={recordVideoAsync}\r\n            />\r\n        </>\r\n    );\r\n};\r\n","import type { Scene } from \"../scene\";\r\nimport { ReflectionProbe } from \"../Probes/reflectionProbe\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport { RenderTargetTexture } from \"../Materials/Textures/renderTargetTexture\";\r\nimport { CustomProceduralTexture } from \"../Materials/Textures/Procedurals/customProceduralTexture\";\r\nimport { DumpData } from \"./dumpTools\";\r\nimport type { Vector3 } from \"../Maths/math.vector\";\r\nimport \"../Shaders/equirectangularPanorama.fragment\";\r\n\r\n/**\r\n * Interface containing options related to equirectangular capture of the current scene\r\n */\r\n// Should have \"I\" prefix but we are keeping it as is for backward compatibility\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface EquiRectangularCaptureOptions {\r\n    /**\r\n     * This option relates to smallest dimension of the given equirectangular capture\r\n     * Giving a 512px size would result in an image that 512 x 1024px\r\n     */\r\n    size: number;\r\n    /**\r\n     * Optional function to map which meshes should get rendered on the equirectangular map\r\n     * This is specifically helpful when you have certain meshes that you want to skip, especially ground\r\n     */\r\n    meshesFilter?: (mesh: AbstractMesh) => boolean;\r\n    /**\r\n     * Optional argument to specify filename, passing this would auto download the given file\r\n     */\r\n    filename?: string;\r\n\r\n    /**\r\n     * Optional argument to specify position in 3D Space from where the equirectangular capture should be taken, if not specified, it would take the position of the scene's active camera or else origin\r\n     */\r\n    position?: Vector3;\r\n\r\n    /**\r\n     * Optional argument to specify probe with which the equirectangular image is generated\r\n     * When passing this, size and position arguments are ignored\r\n     */\r\n    probe?: ReflectionProbe;\r\n}\r\n\r\n/**\r\n * @param scene This refers to the scene which would be rendered in the given equirectangular capture\r\n * @param options This refers to the options for a given equirectangular capture\r\n * @returns the requested capture's pixel-data or auto downloads the file if options.filename is specified\r\n */\r\n// Should end with \"Async\" and start with \"C\" but we are keeping it as is for backward compatibility\r\n// eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\nexport async function captureEquirectangularFromScene(scene: Scene, options: EquiRectangularCaptureOptions): Promise<ArrayBufferView | null> {\r\n    const probe: ReflectionProbe = options.probe ?? new ReflectionProbe(\"tempProbe\", options.size, scene);\r\n    const wasProbeProvided = !!options.probe;\r\n    if (!wasProbeProvided) {\r\n        if (options.position) {\r\n            probe.position = options.position.clone();\r\n        } else if (scene.activeCamera) {\r\n            probe.position = scene.activeCamera.position.clone();\r\n        }\r\n    }\r\n    const meshesToConsider = options.meshesFilter ? scene.meshes.filter(options.meshesFilter) : scene.meshes;\r\n    probe.renderList?.push(...meshesToConsider);\r\n    probe.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;\r\n    probe.cubeTexture.render();\r\n    const dumpTexture = new CustomProceduralTexture(\"tempProceduralTexture\", \"equirectangularPanorama\", { width: options.size * 2, height: options.size }, scene);\r\n    dumpTexture.setTexture(\"cubeMap\", probe.cubeTexture);\r\n    return await new Promise((resolve, reject) => {\r\n        dumpTexture.onGeneratedObservable.addOnce(() => {\r\n            const pixelDataPromise = dumpTexture.readPixels();\r\n            if (!pixelDataPromise) {\r\n                reject(new Error(\"No Pixel Data found on procedural texture\"));\r\n                dumpTexture.dispose();\r\n                if (!wasProbeProvided) {\r\n                    probe.dispose();\r\n                }\r\n                return;\r\n            }\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            pixelDataPromise.then((pixelData) => {\r\n                dumpTexture.dispose();\r\n                if (!wasProbeProvided) {\r\n                    probe.dispose();\r\n                }\r\n                if (options.filename) {\r\n                    DumpData(options.size * 2, options.size, pixelData, undefined, \"image/png\", options.filename);\r\n                    resolve(null);\r\n                } else {\r\n                    resolve(pixelData);\r\n                }\r\n            });\r\n        });\r\n    });\r\n}\r\n","import type { ServiceDefinition } from \"../../../modularity/serviceDefinition\";\r\nimport { ToolsServiceIdentity } from \"../toolsService\";\r\nimport type { IToolsService } from \"../toolsService\";\r\nimport type { IDisposable } from \"core/scene\";\r\nimport { CaptureRttTools, CaptureScreenshotTools } from \"../../../components/tools/captureTools\";\r\n\r\nexport const CaptureServiceDefinition: ServiceDefinition<[], [IToolsService]> = {\r\n    friendlyName: \"Capture Tools\",\r\n    consumes: [ToolsServiceIdentity],\r\n    factory: (toolsService) => {\r\n        const contentRegistrations: IDisposable[] = [];\r\n\r\n        // Screenshot capture content\r\n        contentRegistrations.push(\r\n            toolsService.addSectionContent({\r\n                key: \"Screenshot Capture\",\r\n                section: \"Screenshot Capture\",\r\n                component: ({ context }) => <CaptureScreenshotTools scene={context} />,\r\n            })\r\n        );\r\n\r\n        // RTT capture content\r\n        contentRegistrations.push(\r\n            toolsService.addSectionContent({\r\n                key: \"RTT Capture\",\r\n                section: \"RTT Capture\",\r\n                component: ({ context }) => <CaptureRttTools scene={context} />,\r\n            })\r\n        );\r\n\r\n        return {\r\n            dispose: () => {\r\n                contentRegistrations.forEach((registration) => registration.dispose());\r\n            },\r\n        };\r\n    },\r\n};\r\n\r\nexport default {\r\n    serviceDefinitions: [CaptureServiceDefinition],\r\n} as const;\r\n"],"names":["VideoRecorder","IsSupported","engine","canvas","targetCanvas","getRenderingCanvas","captureStream","isRecording","this","_canvas","_isRecording","constructor","options","_options","_DefaultOptions","stream","fps","audioTracks","track","addTrack","_mediaRecorder","MediaRecorder","mimeType","ondataavailable","evt","_handleDataAvailable","onerror","_handleError","onstop","_handleStop","stopRecording","stop","startRecording","fileName","maxDuration","setTimeout","_fileName","_recordedChunks","_resolve","_reject","start","recordChunckSize","Promise","resolve","reject","dispose","event","data","size","push","error","superBuffer","Blob","window","URL","createObjectURL","Download","prototype","removeReflectionProbe","toRemove","reflectionProbes","index","indexOf","splice","addReflectionProbe","newReflectionProbe","ReflectionProbe","name","scene","generateMipMaps","useFloat","linearSpace","_viewMatrix","Identity","_target","Zero","_add","_invertYAxis","position","metadata","_parentContainer","_scene","getEngine","supportsUniformBuffers","_sceneUBOs","i","createSceneUniformBuffer","textureType","TEXTURETYPE_UNSIGNED_BYTE","caps","getCaps","textureHalfFloatRender","TEXTURETYPE_HALF_FLOAT","textureFloatRender","TEXTURETYPE_FLOAT","_renderTargetTexture","gammaSpace","invertZ","useRightHandedSystem","useReverseDepthBuffer","currentApplyByPostProcess","onBeforeRenderObservable","add","faceIndex","setSceneUniformBuffer","getSceneUniformBuffer","unbindEffect","copyFromFloats","_attachedMesh","copyFrom","getAbsolutePosition","addToRef","lookAtFunction","LookAtRHToRef","LookAtLHToRef","perspectiveFunction","PerspectiveFovRH","PerspectiveFovLH","Up","activeCamera","_projectionMatrix","Math","PI","maxZ","minZ","isNDCHalfZRange","setTransformMatrix","isRigCamera","rigParent","_forcedViewPosition","onBeforeBindObservable","_currentSceneUBO","_enableGPUDebugMarkers","restoreDefaultFramebuffer","_debugPushGroup","imageProcessingConfiguration","applyByPostProcess","onAfterUnbindObservable","updateTransformMatrix","_debugPopGroup","samples","value","refreshRate","getScene","cubeTexture","renderList","attachToMesh","mesh","setRenderingAutoClearDepthStencil","renderingGroupId","autoClearDepthStencil","ubo","toString","fullDetails","ret","getClassName","serialize","serializationObject","Serialize","isReflectionProbe","Parse","parsedReflectionProbe","rootUrl","reflectionProbe","length","rp","renderTargetSize","_generateMipMaps","_waitingRenderList","getMeshById","ShadersStore","CaptureRttTools","useWidthHeight","setUseWidthHeight","useState","screenshotSize","setScreenshotSize","precision","captureRender","useCallback","async","sizeToUse","width","undefined","height","CreateScreenshotUsingRenderTarget","label","icon","onClick","onChange","min","max","step","visible","CaptureScreenshotTools","setIsRecording","videoRecorder","useRef","captureScreenshot","camera","frameGraph","FindMainCamera","CreateScreenshot","captureEquirectangularAsync","currentActiveCamera","probe","wasProbeProvided","clone","meshesToConsider","meshesFilter","meshes","filter","REFRESHRATE_RENDER_ONCE","render","dumpTexture","setTexture","onGeneratedObservable","addOnce","pixelDataPromise","readPixels","Error","then","pixelData","filename","DumpData","captureEquirectangularFromScene","recordVideoAsync","current","itemId","CaptureServiceDefinition","friendlyName","consumes","factory","toolsService","contentRegistrations","addSectionContent","key","section","component","context","forEach","registration","serviceDefinitions"],"ignoreList":[],"sourceRoot":""}