{"version":3,"file":"8324.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/KHR_materials_variants.ts?"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { Node } from \"core/node\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { INode, IMeshPrimitive, IMesh } from \"../glTFLoaderInterfaces\";\r\nimport type { IKHRMaterialVariants_Mapping, IKHRMaterialVariants_Variant, IKHRMaterialVariants_Variants } from \"babylonjs-gltf2interface\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\nimport type { MaterialVariantsController } from \"../../glTFFileLoader\";\r\n\r\nconst NAME = \"KHR_materials_variants\";\r\n\r\nexport { MaterialVariantsController };\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // Define options related types here so they can be referenced in the options,\r\n    // but export the types at the module level. This ensures the types are in the\r\n    // correct namespace for UMD.\r\n    type MaterialVariantsController = {\r\n        /**\r\n         * The list of available variant names for this asset.\r\n         */\r\n        readonly variants: readonly string[];\r\n\r\n        /**\r\n         * Gets or sets the selected variant.\r\n         */\r\n        selectedVariant: string;\r\n    };\r\n\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_variants extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_variants\"]: Partial<{\r\n            /**\r\n             * Specifies the name of the variant that should be selected by default.\r\n             */\r\n            defaultVariant: string;\r\n\r\n            /**\r\n             * Defines a callback that will be called if material variants are loaded.\r\n             * @experimental\r\n             */\r\n            onLoaded: (controller: MaterialVariantsController) => void;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IVariantsMap {\r\n    [key: string]: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n}\r\n\r\ninterface IExtensionMetadata {\r\n    lastSelected: Nullable<string | Array<string>>;\r\n    original: Array<{ mesh: AbstractMesh; material: Nullable<Material> }>;\r\n    variants: IVariantsMap;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_variants/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_variants implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _variants?: Array<IKHRMaterialVariants_Variant>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME) && !this._loader.parent.skipMaterials;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public static GetAvailableVariants(rootNode: TransformNode): string[] {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            return [];\r\n        }\r\n\r\n        return Object.keys(extensionMetadata.variants);\r\n    }\r\n\r\n    /**\r\n     * Gets the list of available variant names for this asset.\r\n     * @param rootNode The glTF root node\r\n     * @returns the list of all the variant names for this model\r\n     */\r\n    public getAvailableVariants(rootNode: TransformNode): string[] {\r\n        return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public static SelectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot select variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        const select = (variantName: string): void => {\r\n            const entries = extensionMetadata.variants[variantName];\r\n            if (entries) {\r\n                for (const entry of entries) {\r\n                    entry.mesh.material = entry.material;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (variantName instanceof Array) {\r\n            for (const name of variantName) {\r\n                select(name);\r\n            }\r\n        } else {\r\n            select(variantName);\r\n        }\r\n\r\n        extensionMetadata.lastSelected = variantName;\r\n    }\r\n\r\n    /**\r\n     * Select a variant given a variant name or a list of variant names.\r\n     * @param rootNode The glTF root node\r\n     * @param variantName The variant name(s) to select.\r\n     */\r\n    public selectVariant(rootNode: TransformNode, variantName: string | string[]): void {\r\n        KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public static Reset(rootNode: TransformNode): void {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot reset on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        for (const entry of extensionMetadata.original) {\r\n            entry.mesh.material = entry.material;\r\n        }\r\n\r\n        extensionMetadata.lastSelected = null;\r\n    }\r\n\r\n    /**\r\n     * Reset back to the original before selecting a variant.\r\n     * @param rootNode The glTF root node\r\n     */\r\n    public reset(rootNode: TransformNode): void {\r\n        KHR_materials_variants.Reset(rootNode);\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public static GetLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        const extensionMetadata = this._GetExtensionMetadata(rootNode);\r\n        if (!extensionMetadata) {\r\n            throw new Error(`Cannot get the last selected variant on a glTF mesh that does not have the ${NAME} extension`);\r\n        }\r\n\r\n        return extensionMetadata.lastSelected;\r\n    }\r\n\r\n    /**\r\n     * Gets the last selected variant name(s) or null if original.\r\n     * @param rootNode The glTF root node\r\n     * @returns The selected variant name(s).\r\n     */\r\n    public getLastSelectedVariant(rootNode: TransformNode): Nullable<string | string[]> {\r\n        return KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n    }\r\n\r\n    private static _GetExtensionMetadata(rootNode: Nullable<TransformNode>): Nullable<IExtensionMetadata> {\r\n        return rootNode?._internalMetadata?.gltf?.[NAME] || null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IKHRMaterialVariants_Variants;\r\n            this._variants = extension.variants;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        const rootNode = this._loader.rootBabylonMesh;\r\n        if (rootNode) {\r\n            const options = this._loader.parent.extensionOptions[NAME];\r\n            if (options?.defaultVariant) {\r\n                KHR_materials_variants.SelectVariant(rootNode, options.defaultVariant);\r\n            }\r\n\r\n            options?.onLoaded?.({\r\n                get variants() {\r\n                    return KHR_materials_variants.GetAvailableVariants(rootNode);\r\n                },\r\n                get selectedVariant(): string {\r\n                    const lastSelectedVariant = KHR_materials_variants.GetLastSelectedVariant(rootNode);\r\n                    if (!lastSelectedVariant) {\r\n                        return KHR_materials_variants.GetAvailableVariants(rootNode)[0];\r\n                    }\r\n                    if (Array.isArray(lastSelectedVariant)) {\r\n                        return lastSelectedVariant[0];\r\n                    }\r\n                    return lastSelectedVariant;\r\n                },\r\n                set selectedVariant(variantName) {\r\n                    KHR_materials_variants.SelectVariant(rootNode, variantName);\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialVariants_Mapping, AbstractMesh>(context, primitive, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(\r\n                this._loader._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, (babylonMesh) => {\r\n                    assign(babylonMesh);\r\n\r\n                    if (babylonMesh instanceof Mesh) {\r\n                        const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n\r\n                        const root = this._loader.rootBabylonMesh;\r\n                        const metadata = root ? (root._internalMetadata = root._internalMetadata || {}) : {};\r\n                        const gltf = (metadata.gltf = metadata.gltf || {});\r\n                        const extensionMetadata: IExtensionMetadata = (gltf[NAME] = gltf[NAME] || { lastSelected: null, original: [], variants: {} });\r\n\r\n                        // Store the original material.\r\n                        extensionMetadata.original.push({ mesh: babylonMesh, material: babylonMesh.material });\r\n\r\n                        // For each mapping, look at the variants and make a new entry for them.\r\n                        for (let mappingIndex = 0; mappingIndex < extension.mappings.length; ++mappingIndex) {\r\n                            const mapping = extension.mappings[mappingIndex];\r\n                            const material = ArrayItem.Get(`${extensionContext}/mappings/${mappingIndex}/material`, this._loader.gltf.materials, mapping.material);\r\n                            promises.push(\r\n                                this._loader._loadMaterialAsync(`#/materials/${mapping.material}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                                    for (let mappingVariantIndex = 0; mappingVariantIndex < mapping.variants.length; ++mappingVariantIndex) {\r\n                                        const variantIndex = mapping.variants[mappingVariantIndex];\r\n                                        const variant = ArrayItem.Get(`/extensions/${NAME}/variants/${variantIndex}`, this._variants, variantIndex);\r\n                                        extensionMetadata.variants[variant.name] = extensionMetadata.variants[variant.name] || [];\r\n                                        extensionMetadata.variants[variant.name].push({\r\n                                            mesh: babylonMesh,\r\n                                            material: babylonMaterial,\r\n                                        });\r\n\r\n                                        // Replace the target when original mesh is cloned\r\n                                        babylonMesh.onClonedObservable.add((newOne: Node) => {\r\n                                            const newMesh = newOne as Mesh;\r\n                                            let metadata: Nullable<IExtensionMetadata> = null;\r\n                                            let newRoot: Nullable<Node> = newMesh;\r\n\r\n                                            // Find root to get medata\r\n                                            do {\r\n                                                newRoot = newRoot.parent;\r\n                                                if (!newRoot) {\r\n                                                    return;\r\n                                                }\r\n                                                metadata = KHR_materials_variants._GetExtensionMetadata(newRoot as Mesh);\r\n                                            } while (metadata === null);\r\n\r\n                                            // Need to clone the metadata on the root (first time only)\r\n                                            if (root && metadata === KHR_materials_variants._GetExtensionMetadata(root)) {\r\n                                                // Copy main metadata\r\n                                                newRoot._internalMetadata = {};\r\n                                                for (const key in root._internalMetadata) {\r\n                                                    newRoot._internalMetadata[key] = root._internalMetadata[key];\r\n                                                }\r\n\r\n                                                // Copy the gltf metadata\r\n                                                newRoot._internalMetadata.gltf = [];\r\n                                                for (const key in root._internalMetadata.gltf) {\r\n                                                    newRoot._internalMetadata.gltf[key] = root._internalMetadata.gltf[key];\r\n                                                }\r\n\r\n                                                // Duplicate the extension specific metadata\r\n                                                newRoot._internalMetadata.gltf[NAME] = { lastSelected: null, original: [], variants: {} };\r\n                                                for (const original of metadata.original) {\r\n                                                    newRoot._internalMetadata.gltf[NAME].original.push({\r\n                                                        mesh: original.mesh,\r\n                                                        material: original.material,\r\n                                                    });\r\n                                                }\r\n                                                for (const key in metadata.variants) {\r\n                                                    if (Object.prototype.hasOwnProperty.call(metadata.variants, key)) {\r\n                                                        newRoot._internalMetadata.gltf[NAME].variants[key] = [];\r\n                                                        for (const variantEntry of metadata.variants[key]) {\r\n                                                            newRoot._internalMetadata.gltf[NAME].variants[key].push({\r\n                                                                mesh: variantEntry.mesh,\r\n                                                                material: variantEntry.material,\r\n                                                            });\r\n                                                        }\r\n                                                    }\r\n                                                }\r\n\r\n                                                metadata = newRoot._internalMetadata.gltf[NAME];\r\n                                            }\r\n\r\n                                            // Relocate\r\n                                            for (const target of metadata!.original) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                            for (const target of metadata!.variants[variant.name]) {\r\n                                                if (target.mesh === babylonMesh) {\r\n                                                    target.mesh = newMesh;\r\n                                                }\r\n                                            }\r\n                                        });\r\n                                    }\r\n                                })\r\n                            );\r\n                        }\r\n                    }\r\n                })\r\n            );\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(([babylonMesh]) => {\r\n                return babylonMesh;\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_variants(loader));\r\n"],"names":["NAME","KHR_materials_variants","constructor","loader","name","this","_loader","enabled","isExtensionUsed","parent","skipMaterials","dispose","GetAvailableVariants","rootNode","extensionMetadata","_GetExtensionMetadata","Object","keys","variants","getAvailableVariants","SelectVariant","variantName","Error","select","entries","entry","mesh","material","Array","lastSelected","selectVariant","Reset","original","reset","GetLastSelectedVariant","getLastSelectedVariant","_internalMetadata","gltf","onLoading","extensions","extension","_variants","onReady","rootBabylonMesh","options","extensionOptions","defaultVariant","onLoaded","selectedVariant","lastSelectedVariant","isArray","_loadMeshPrimitiveAsync","context","node","primitive","assign","LoadExtensionAsync","async","extensionContext","promises","push","babylonMesh","babylonDrawMode","_GetDrawMode","mode","root","metadata","mappingIndex","mappings","length","mapping","Get","materials","_loadMaterialAsync","babylonMaterial","mappingVariantIndex","variantIndex","variant","onClonedObservable","add","newOne","newMesh","newRoot","key","prototype","hasOwnProperty","call","variantEntry","target","Promise","all","then"],"ignoreList":[],"sourceRoot":""}