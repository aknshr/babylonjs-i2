{"version":3,"file":"5079.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/streamingSound.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/streamingSoundInstance.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/webAudio/webAudioStreamingSound.ts?","webpack://@dev/inspector-v2/../core/src/Animations/animationEvent.ts?","webpack://@dev/inspector-v2/../core/src/Audio/sound.ts?","webpack://@dev/inspector-v2/../core/src/Audio/weightedsound.ts?","webpack://@dev/inspector-v2/../core/src/Audio/soundTrack.ts?","webpack://@dev/inspector-v2/../core/src/Audio/audioSceneComponent.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/MSFT_audio_emitter.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/webAudio/webAudioSoundSource.ts?"],"sourcesContent":["import { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { _StreamingSoundInstance } from \"./streamingSoundInstance\";\n\n/** @internal */\nexport interface IStreamingSoundOptionsBase {\n    /**\n     * The number of instances to preload. Defaults to 1.\n     * */\n    preloadCount: number;\n}\n\n/**\n * Options for creating a streaming sound.\n */\nexport interface IStreamingSoundOptions extends IAbstractSoundOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Options for playing a streaming sound.\n */\nexport interface IStreamingSoundPlayOptions extends IAbstractSoundPlayOptions {}\n\n/**\n * Options stored in a streaming sound.\n * @internal\n */\nexport interface IStreamingSoundStoredOptions extends IAbstractSoundStoredOptions, IStreamingSoundOptionsBase {}\n\n/**\n * Abstract class representing a streaming sound.\n *\n * A streaming sound has a sound buffer that is loaded into memory in chunks as it is played. This allows it to be played\n * more quickly than a static sound, but it also means that it cannot have loop points or playback rate changes.\n *\n * Due to the way streaming sounds are typically implemented, there can be a significant delay when attempting to play\n * a streaming sound for the first time. To prevent this delay, it is recommended to preload instances of the sound\n * using the {@link IStreamingSoundStoredOptions.preloadCount} options, or the {@link preloadInstanceAsync} and\n * {@link preloadInstancesAsync} methods before calling the `play` method.\n *\n * Streaming sounds are created by the {@link CreateStreamingSoundAsync} function.\n */\nexport abstract class StreamingSound extends AbstractSound {\n    private _preloadedInstances = new Array<_StreamingSoundInstance>();\n\n    protected abstract override readonly _options: IStreamingSoundStoredOptions;\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IStreamingSoundOptions>) {\n        super(name, engine, options);\n    }\n\n    /**\n     * The number of instances to preload. Defaults to `1`.\n     */\n    public get preloadCount(): number {\n        return this._options.preloadCount ?? 1;\n    }\n\n    /**\n     * Returns the number of instances that have been preloaded.\n     */\n    public get preloadCompletedCount(): number {\n        return this._preloadedInstances.length;\n    }\n\n    /**\n     * Preloads an instance of the sound.\n     * @returns A promise that resolves when the instance is preloaded.\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public preloadInstanceAsync(): Promise<void> {\n        const instance = this._createInstance();\n\n        this._addPreloadedInstance(instance);\n\n        return instance.preloadedPromise;\n    }\n\n    /**\n     * Preloads the given number of instances of the sound.\n     * @param count - The number of instances to preload.\n     * @returns A promise that resolves when all instances are preloaded.\n     */\n    public async preloadInstancesAsync(count: number): Promise<void> {\n        for (let i = 0; i < count; i++) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            this.preloadInstanceAsync();\n        }\n\n        await Promise.all(this._preloadedInstances.map(async (instance) => await instance.preloadedPromise));\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        let instance: _StreamingSoundInstance;\n\n        if (this.preloadCompletedCount > 0) {\n            instance = this._preloadedInstances[0];\n            instance.startOffset = this.startOffset;\n            this._removePreloadedInstance(instance);\n        } else {\n            instance = this._createInstance();\n        }\n\n        const onInstanceStateChanged = () => {\n            if (instance.state === SoundState.Started) {\n                this._stopExcessInstances();\n                instance.onStateChangedObservable.removeCallback(onInstanceStateChanged);\n            }\n        };\n        instance.onStateChangedObservable.add(onInstanceStateChanged);\n\n        options.startOffset ??= this.startOffset;\n        options.loop ??= this.loop;\n        options.volume ??= 1;\n\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n    }\n\n    /**\n     * Stops the sound.\n     */\n    public stop(): void {\n        this._setState(SoundState.Stopped);\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop();\n        }\n    }\n\n    protected abstract override _createInstance(): _StreamingSoundInstance;\n\n    private _addPreloadedInstance(instance: _StreamingSoundInstance): void {\n        if (!this._preloadedInstances.includes(instance)) {\n            this._preloadedInstances.push(instance);\n        }\n    }\n\n    private _removePreloadedInstance(instance: _StreamingSoundInstance): void {\n        const index = this._preloadedInstances.indexOf(instance);\n        if (index !== -1) {\n            this._preloadedInstances.splice(index, 1);\n        }\n    }\n}\n","import { Observable } from \"../../Misc/observable\";\nimport type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStreamingSoundOptionsBase, StreamingSound } from \"./streamingSound\";\n\n/**\n * Options for creating streaming sound instance.\n * @internal\n */\nexport interface IStreamingSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStreamingSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StreamingSoundInstance extends _AbstractSoundInstance {\n    private _rejectPreloadedProimse: (reason?: any) => void;\n    private _resolvePreloadedPromise: () => void;\n\n    protected abstract override readonly _options: IStreamingSoundInstanceOptions;\n\n    /** @internal */\n    public readonly onReadyObservable = new Observable<_StreamingSoundInstance>();\n\n    /** @internal */\n    public readonly preloadedPromise = new Promise<void>((resolve, reject) => {\n        this._rejectPreloadedProimse = reject;\n        this._resolvePreloadedPromise = resolve;\n    });\n\n    protected constructor(sound: StreamingSound) {\n        super(sound);\n\n        this.onErrorObservable.add(this._rejectPreloadedProimse);\n        this.onReadyObservable.add(this._resolvePreloadedPromise);\n    }\n\n    /** @internal */\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.onErrorObservable.clear();\n        this.onReadyObservable.clear();\n\n        this._resolvePreloadedPromise();\n    }\n}\n","import { Logger } from \"../../Misc/logger\";\nimport { Tools } from \"../../Misc/tools\";\nimport type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type {} from \"../abstractAudio/abstractSound\";\nimport type { IStreamingSoundOptions, IStreamingSoundPlayOptions, IStreamingSoundStoredOptions } from \"../abstractAudio/streamingSound\";\nimport { StreamingSound } from \"../abstractAudio/streamingSound\";\nimport { _StreamingSoundInstance } from \"../abstractAudio/streamingSoundInstance\";\nimport { _HasSpatialAudioOptions, type AbstractSpatialAudio } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StreamingSoundSourceType = HTMLMediaElement | string | string[];\n\n/** @internal */\nexport class _WebAudioStreamingSound extends StreamingSound implements IWebAudioSuperNode {\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public _source: StreamingSoundSourceType;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStreamingSoundOptions>) {\n        super(name, engine, options);\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            loop: options.loop ?? false,\n            maxInstances: options.maxInstances ?? Infinity,\n            preloadCount: options.preloadCount ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStreamingSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _initAsync(source: StreamingSoundSourceType, options: Partial<IStreamingSoundOptions>): Promise<void> {\n        const audioContext = this.engine._audioContext;\n\n        if (!(audioContext instanceof AudioContext)) {\n            throw new Error(\"Unsupported audio context type.\");\n        }\n\n        this._audioContext = audioContext;\n        this._source = source;\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.initAsync(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (this.preloadCount) {\n            await this.preloadInstancesAsync(this.preloadCount);\n        }\n\n        if (options.autoplay) {\n            this.play(options);\n        }\n\n        this.engine._addSound(this);\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeSound(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSound\";\n    }\n\n    protected _createInstance(): _WebAudioStreamingSoundInstance {\n        return new _WebAudioStreamingSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio {\n        return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);\n    }\n\n    public _getOptions(): IStreamingSoundStoredOptions {\n        return this._options;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStreamingSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nclass _WebAudioStreamingSoundInstance extends _StreamingSoundInstance implements IWebAudioOutNode {\n    private _currentTimeChangedWhilePaused = false;\n    private _enginePlayTime: number = Infinity;\n    private _enginePauseTime: number = 0;\n    private _isReady: boolean = false;\n    private _isReadyPromise: Promise<HTMLMediaElement> = new Promise((resolve, reject) => {\n        this._resolveIsReadyPromise = resolve;\n        this._rejectIsReadyPromise = reject;\n    });\n    private _mediaElement: HTMLMediaElement;\n    private _sourceNode: Nullable<MediaElementAudioSourceNode>;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStreamingSoundStoredOptions;\n    protected override _sound: _WebAudioStreamingSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStreamingSound, options: IStreamingSoundStoredOptions) {\n        super(sound);\n\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n\n        if (typeof sound._source === \"string\") {\n            this._initFromUrl(sound._source);\n        } else if (Array.isArray(sound._source)) {\n            this._initFromUrls(sound._source);\n        } else if (sound._source instanceof HTMLMediaElement) {\n            this._initFromMediaElement(sound._source);\n        } else {\n            throw new Error(`Invalid streaming sound source (${sound._source}).`);\n        }\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            this._mediaElement.pause();\n            this._state = SoundState.Stopped;\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play({ startOffset: value });\n        } else if (this._state === SoundState.Paused) {\n            this._currentTimeChangedWhilePaused = true;\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._sourceNode?.disconnect(this._volumeNode);\n        this._sourceNode = null;\n\n        this._mediaElement.removeEventListener(\"error\", this._onError);\n        this._mediaElement.removeEventListener(\"ended\", this._onEnded);\n        this._mediaElement.removeEventListener(\"canplaythrough\", this._onCanPlayThrough);\n\n        for (const source of Array.from(this._mediaElement.children)) {\n            this._mediaElement.removeChild(source);\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        this.engine.userGestureObservable.removeCallback(this._onUserGesture);\n    }\n\n    /** @internal */\n    public play(options: Partial<IStreamingSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        this._mediaElement.loop = this._options.loop;\n\n        let startOffset = options.startOffset;\n\n        if (this._currentTimeChangedWhilePaused) {\n            startOffset = this._options.startOffset;\n            this._currentTimeChangedWhilePaused = false;\n        } else if (this._state === SoundState.Paused) {\n            startOffset = this.currentTime + this._options.startOffset;\n        }\n\n        if (startOffset && startOffset > 0) {\n            this._mediaElement.currentTime = startOffset;\n        }\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._play();\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state !== SoundState.Starting && this._state !== SoundState.Started) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        this._mediaElement.pause();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        } else if (this._currentTimeChangedWhilePaused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public override stop(): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        this._stop();\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStreamingSoundInstance\";\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStreamingSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    private _initFromMediaElement(mediaElement: HTMLMediaElement): void {\n        Tools.SetCorsBehavior(mediaElement.currentSrc, mediaElement);\n\n        mediaElement.controls = false;\n        mediaElement.loop = this._options.loop;\n        mediaElement.preload = \"auto\";\n\n        mediaElement.addEventListener(\"canplaythrough\", this._onCanPlayThrough, { once: true });\n        mediaElement.addEventListener(\"ended\", this._onEnded, { once: true });\n        mediaElement.addEventListener(\"error\", this._onError, { once: true });\n\n        mediaElement.load();\n\n        this._sourceNode = new MediaElementAudioSourceNode(this._sound._audioContext, { mediaElement: mediaElement });\n        this._sourceNode.connect(this._volumeNode);\n\n        if (!this._connect(this._sound)) {\n            throw new Error(\"Connect failed\");\n        }\n\n        this._mediaElement = mediaElement;\n    }\n\n    private _initFromUrl(url: string): void {\n        const audio = new Audio(_CleanUrl(url));\n        this._initFromMediaElement(audio);\n    }\n\n    private _initFromUrls(urls: string[]): void {\n        const audio = new Audio();\n\n        for (const url of urls) {\n            const source = document.createElement(\"source\");\n            source.src = _CleanUrl(url);\n            audio.appendChild(source);\n        }\n\n        this._initFromMediaElement(audio);\n    }\n\n    private _onCanPlayThrough: () => void = () => {\n        this._isReady = true;\n        this._resolveIsReadyPromise(this._mediaElement);\n        this.onReadyObservable.notifyObservers(this);\n    };\n\n    private _onEnded: () => void = () => {\n        this.onEndedObservable.notifyObservers(this);\n        this.dispose();\n    };\n\n    private _onError: (reason: any) => void = (reason: any) => {\n        this._setState(SoundState.FailedToStart);\n        this.onErrorObservable.notifyObservers(reason);\n        this._rejectIsReadyPromise(reason);\n        this.dispose();\n    };\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n\n    private _onUserGesture = () => {\n        this.play();\n    };\n\n    private _play(): void {\n        this._setState(SoundState.Starting);\n\n        if (!this._isReady) {\n            this._playWhenReady();\n            return;\n        }\n\n        if (this._state !== SoundState.Starting) {\n            return;\n        }\n\n        if (this.engine.state === \"running\") {\n            const result = this._mediaElement.play();\n\n            this._enginePlayTime = this.engine.currentTime;\n            this._setState(SoundState.Started);\n\n            // It's possible that the play() method fails on Safari, even if the audio engine's state is \"running\".\n            // This occurs when the audio context is paused by the system and resumed automatically by the audio engine\n            // without a user interaction (e.g. when the Vision Pro exits and reenters immersive mode).\n            // eslint-disable-next-line github/no-then\n            result.catch(() => {\n                this._setState(SoundState.FailedToStart);\n\n                if (this._options.loop) {\n                    this.engine.userGestureObservable.addOnce(this._onUserGesture);\n                }\n            });\n        } else if (this._options.loop) {\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        } else {\n            this.stop();\n            this._setState(SoundState.FailedToStart);\n        }\n    }\n\n    private _playWhenReady(): void {\n        this._isReadyPromise\n            // eslint-disable-next-line github/no-then\n            .then(() => {\n                this._play();\n            })\n            // eslint-disable-next-line github/no-then\n            .catch(() => {\n                Logger.Error(\"Streaming sound instance failed to play\");\n                this._setState(SoundState.FailedToStart);\n            });\n    }\n\n    private _rejectIsReadyPromise: (reason?: any) => void;\n    private _resolveIsReadyPromise: (mediaElement: HTMLMediaElement) => void;\n\n    private _stop(): void {\n        this._mediaElement.pause();\n        this._setState(SoundState.Stopped);\n        this._onEnded();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n}\n","/**\r\n * Composed of a frame, and an action function\r\n */\r\nexport class AnimationEvent {\r\n    /**\r\n     * Specifies if the animation event is done\r\n     */\r\n    public isDone: boolean = false;\r\n\r\n    /**\r\n     * Initializes the animation event\r\n     * @param frame The frame for which the event is triggered\r\n     * @param action The event to perform when triggered\r\n     * @param onlyOnce Specifies if the event should be triggered only once\r\n     */\r\n    constructor(\r\n        /** The frame for which the event is triggered **/\r\n        public frame: number,\r\n        /** The event to perform when triggered **/\r\n        public action: (currentFrame: number) => void,\r\n        /** Specifies if the event should be triggered only once**/\r\n        public onlyOnce?: boolean\r\n    ) {}\r\n\r\n    /** @internal */\r\n    public _clone(): AnimationEvent {\r\n        return new AnimationEvent(this.frame, this.action, this.onlyOnce);\r\n    }\r\n}\r\n","import type { IStaticSoundOptions, IStaticSoundPlayOptions, IStaticSoundStopOptions } from \"../AudioV2/abstractAudio/staticSound\";\r\nimport type { IStreamingSoundOptions } from \"../AudioV2/abstractAudio/streamingSound\";\r\nimport { _HasSpatialAudioOptions, _SpatialAudioDefaults } from \"../AudioV2/abstractAudio/subProperties/abstractSpatialAudio\";\r\nimport type { IAudioParameterRampOptions } from \"../AudioV2/audioParameter\";\r\nimport { AudioParameterRampShape } from \"../AudioV2/audioParameter\";\r\nimport { SoundState } from \"../AudioV2/soundState\";\r\nimport { _WebAudioSoundSource } from \"../AudioV2/webAudio/webAudioSoundSource\";\r\nimport { _WebAudioStaticSound } from \"../AudioV2/webAudio/webAudioStaticSound\";\r\nimport { _WebAudioStreamingSound } from \"../AudioV2/webAudio/webAudioStreamingSound\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { _RetryWithInterval } from \"../Misc/timingTools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AudioEngine } from \"./audioEngine\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\n\r\nconst TmpRampOptions: IAudioParameterRampOptions = {\r\n    duration: 0,\r\n    shape: AudioParameterRampShape.Linear,\r\n};\r\n\r\nconst TmpPlayOptions: Partial<IStaticSoundPlayOptions> = {\r\n    duration: 0,\r\n    startOffset: 0,\r\n    waitTime: 0,\r\n};\r\n\r\nconst TmpStopOptions: IStaticSoundStopOptions = {\r\n    waitTime: 0,\r\n};\r\n\r\nfunction D2r(degrees: number): number {\r\n    return (degrees * Math.PI) / 180;\r\n}\r\n\r\nfunction R2d(radians: number): number {\r\n    return (radians * 180) / Math.PI;\r\n}\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/legacy/audio\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public get name(): string {\r\n        return this._soundV2.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._soundV2.name = value;\r\n    }\r\n\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public get autoplay(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._optionsV2.autoplay!;\r\n    }\r\n\r\n    public set autoplay(value: boolean) {\r\n        this._optionsV2.autoplay = value;\r\n    }\r\n\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2.loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        if (this._soundV2) {\r\n            this._soundV2.loop = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number = -1;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2?.state === SoundState.Started || (!this.isReady() && this._optionsV2.autoplay!);\r\n    }\r\n\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public get isPaused(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? false : this._soundV2.state === SoundState.Paused;\r\n    }\r\n\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public get maxDistance(): number {\r\n        return this._optionsV2.spatialMaxDistance || 100;\r\n    }\r\n    public set maxDistance(value: number) {\r\n        this._optionsV2.spatialMaxDistance = value;\r\n\r\n        if (this.useCustomAttenuation) {\r\n            return;\r\n        }\r\n\r\n        if (this._soundV2) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.maxDistance = value;\r\n        }\r\n    }\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public get distanceModel(): \"linear\" | \"inverse\" | \"exponential\" {\r\n        return this._optionsV2.spatialDistanceModel || \"linear\";\r\n    }\r\n    public set distanceModel(value: \"linear\" | \"inverse\" | \"exponential\") {\r\n        this._optionsV2.spatialDistanceModel = value;\r\n\r\n        if (this._soundV2) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.distanceModel = value;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? this._soundV2.engine.currentTime : this._soundV2.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._soundV2?._isSpatial ?? false;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        if (this._soundV2) {\r\n            if (newValue) {\r\n                this._initSpatial();\r\n            } else {\r\n                this._soundV2._isSpatial = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: () => any;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _url: Nullable<string> = null;\r\n\r\n    private readonly _optionsV2: Partial<IStaticSoundOptions>;\r\n    private readonly _soundV2: _WebAudioSoundSource | _WebAudioStaticSound | _WebAudioStreamingSound;\r\n    private _onReadyObservable: Nullable<Observable<void>> = null;\r\n\r\n    private get _onReady(): Observable<void> {\r\n        if (!this._onReadyObservable) {\r\n            this._onReadyObservable = new Observable<void>();\r\n        }\r\n        return this._onReadyObservable;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n        this._readyToPlayCallback = readyToPlayCallback || (() => {});\r\n\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n\r\n        options = options || {};\r\n\r\n        const optionsV2: Partial<IStaticSoundOptions> = {\r\n            analyzerEnabled: false,\r\n            autoplay: false, // `false` for now, but will be set to given option later\r\n            duration: options.length || 0,\r\n            loop: options.loop || false,\r\n            loopEnd: 0,\r\n            loopStart: 0,\r\n            outBus: null,\r\n            outBusAutoDefault: false,\r\n            playbackRate: options.playbackRate || 1,\r\n            pitch: 0,\r\n            skipCodecCheck: options.skipCodecCheck || false,\r\n            spatialDistanceModel: options.distanceModel,\r\n            spatialEnabled: options.spatialSound,\r\n            spatialMaxDistance: options.maxDistance,\r\n            spatialMinDistance: options.refDistance,\r\n            spatialRolloffFactor: options.rolloffFactor,\r\n            stereoEnabled: false,\r\n            startOffset: options.offset || 0,\r\n            volume: options.volume ?? 1,\r\n        };\r\n        this._volume = options.volume ?? 1;\r\n\r\n        if (_HasSpatialAudioOptions(optionsV2)) {\r\n            optionsV2.spatialAutoUpdate = false;\r\n            optionsV2.spatialConeInnerAngle = _SpatialAudioDefaults.coneInnerAngle;\r\n            optionsV2.spatialConeOuterAngle = _SpatialAudioDefaults.coneOuterAngle;\r\n            optionsV2.spatialConeOuterVolume = _SpatialAudioDefaults.coneOuterVolume;\r\n            optionsV2.spatialMinUpdateTime = 0;\r\n            optionsV2.spatialOrientation = _SpatialAudioDefaults.orientation.clone();\r\n            optionsV2.spatialPanningModel = (this._scene.headphone ? \"HRTF\" : \"equalpower\") as \"equalpower\" | \"HRTF\";\r\n            optionsV2.spatialPosition = _SpatialAudioDefaults.position.clone();\r\n            optionsV2.spatialRotation = _SpatialAudioDefaults.rotation.clone();\r\n            optionsV2.spatialRotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();\r\n\r\n            if (optionsV2.spatialMaxDistance === undefined) {\r\n                optionsV2.spatialMaxDistance = 100;\r\n            }\r\n        }\r\n\r\n        this._optionsV2 = { ...optionsV2 };\r\n        this._optionsV2.autoplay = options.autoplay || false;\r\n\r\n        this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n        if (this.useCustomAttenuation) {\r\n            optionsV2.spatialMaxDistance = Number.MAX_VALUE;\r\n            optionsV2.volume = 0;\r\n        }\r\n\r\n        let streaming = options?.streaming || false;\r\n\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n        if (!audioEngine) {\r\n            return;\r\n        }\r\n\r\n        const audioEngineV2 = (AbstractEngine.audioEngine as AudioEngine)._v2;\r\n\r\n        const createSoundV2 = () => {\r\n            if (streaming) {\r\n                const streamingOptionsV2: Partial<IStreamingSoundOptions> = {\r\n                    preloadCount: 0,\r\n                    ...optionsV2,\r\n                };\r\n\r\n                const sound = new _WebAudioStreamingSound(name, audioEngineV2, streamingOptionsV2);\r\n\r\n                // eslint-disable-next-line github/no-then\r\n                void sound._initAsync(urlOrArrayBuffer, optionsV2).then(() => {\r\n                    // eslint-disable-next-line github/no-then\r\n                    void sound.preloadInstancesAsync(1).then(this._onReadyToPlay);\r\n                });\r\n\r\n                return sound;\r\n            } else {\r\n                const sound = new _WebAudioStaticSound(name, audioEngineV2, optionsV2);\r\n\r\n                // eslint-disable-next-line github/no-then\r\n                void sound._initAsync(urlOrArrayBuffer, optionsV2).then(this._onReadyToPlay);\r\n\r\n                return sound;\r\n            }\r\n        };\r\n\r\n        // If no parameter is passed then the setAudioBuffer should be called to prepare the sound.\r\n        if (!urlOrArrayBuffer) {\r\n            // Create the sound but don't call _initAsync on it, yet. Call it later when `setAudioBuffer` is called.\r\n            this._soundV2 = new _WebAudioStaticSound(name, audioEngineV2, optionsV2);\r\n        } else if (typeof urlOrArrayBuffer === \"string\") {\r\n            this._url = urlOrArrayBuffer;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n            streaming = false;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n            streaming = true;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n            const node = new MediaStreamAudioSourceNode(audioEngineV2._audioContext, { mediaStream: urlOrArrayBuffer });\r\n            this._soundV2 = new _WebAudioSoundSource(name, node, audioEngineV2, optionsV2);\r\n            // eslint-disable-next-line github/no-then\r\n            void this._soundV2._initAsync(optionsV2).then(this._onReadyToPlay);\r\n        } else if (urlOrArrayBuffer instanceof AudioBuffer) {\r\n            streaming = false;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (Array.isArray(urlOrArrayBuffer)) {\r\n            this._soundV2 = createSoundV2();\r\n        }\r\n\r\n        if (!this._soundV2) {\r\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n            return;\r\n        }\r\n\r\n        if (!(this._soundV2 instanceof _WebAudioSoundSource)) {\r\n            this._soundV2.onEndedObservable.add(this._onended);\r\n        }\r\n    }\r\n\r\n    private _onReadyToPlay = () => {\r\n        this._scene.mainSoundTrack.addSound(this);\r\n        this._isReadyToPlay = true;\r\n        this._readyToPlayCallback();\r\n\r\n        if (this._onReadyObservable) {\r\n            this._onReadyObservable.notifyObservers();\r\n        }\r\n\r\n        if (this._optionsV2.autoplay) {\r\n            this.play();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (this.isPlaying) {\r\n            this.stop();\r\n        }\r\n        this._isReadyToPlay = false;\r\n        if (this.soundTrackId === -1) {\r\n            this._scene.mainSoundTrack.removeSound(this);\r\n        } else if (this._scene.soundTracks) {\r\n            this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n        }\r\n\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._connectedTransformNode = null;\r\n        }\r\n\r\n        this._soundV2.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (this._isReadyToPlay) {\r\n            return;\r\n        }\r\n\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._soundV2._initAsync(audioBuffer, this._optionsV2).then(this._onReadyToPlay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            if (options.playbackRate !== undefined) {\r\n                this.setPlaybackRate(options.playbackRate);\r\n            }\r\n            if (options.spatialSound !== undefined) {\r\n                this.spatialSound = options.spatialSound;\r\n            }\r\n            if (options.volume !== undefined) {\r\n                this.setVolume(options.volume);\r\n            }\r\n            if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n                let updated = false;\r\n                if (options.offset !== undefined) {\r\n                    this._optionsV2.startOffset = options.offset;\r\n                    updated = true;\r\n                }\r\n                if (options.length !== undefined) {\r\n                    this._soundV2.duration = options.length;\r\n                    updated = true;\r\n                }\r\n                if (updated && this.isPaused) {\r\n                    this.stop();\r\n                }\r\n            }\r\n\r\n            this._updateSpatialParameters();\r\n        }\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (!this.spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const spatial = this._soundV2.spatial;\r\n\r\n        if (this.useCustomAttenuation) {\r\n            // Disable WebAudio attenuation.\r\n            spatial.distanceModel = \"linear\";\r\n            spatial.minDistance = 1;\r\n            spatial.maxDistance = Number.MAX_VALUE;\r\n            spatial.rolloffFactor = 1;\r\n            spatial.panningModel = \"equalpower\";\r\n        } else {\r\n            spatial.distanceModel = this.distanceModel;\r\n            spatial.minDistance = this.refDistance;\r\n            spatial.maxDistance = this.maxDistance;\r\n            spatial.rolloffFactor = this.rolloffFactor;\r\n            spatial.panningModel = this._optionsV2.spatialPanningModel || \"equalpower\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        if (this.spatialSound) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.panningModel = \"HRTF\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        if (this.spatialSound) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.panningModel = \"equalpower\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        const outputNode = this._soundV2._outNode;\r\n        if (outputNode) {\r\n            if (this._isOutputConnected) {\r\n                outputNode.disconnect();\r\n            }\r\n            outputNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n\r\n        this._optionsV2.spatialConeInnerAngle = D2r(coneInnerAngle);\r\n        this._optionsV2.spatialConeOuterAngle = D2r(coneOuterAngle);\r\n        this._optionsV2.spatialConeOuterVolume = coneOuterGain;\r\n\r\n        this._initSpatial();\r\n        this._soundV2.spatial.coneInnerAngle = this._optionsV2.spatialConeInnerAngle;\r\n        this._soundV2.spatial.coneOuterAngle = this._optionsV2.spatialConeOuterAngle;\r\n        this._soundV2.spatial.coneOuterVolume = coneOuterGain;\r\n\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return R2d(typeof this._optionsV2.spatialConeInnerAngle === \"number\" ? this._optionsV2.spatialConeInnerAngle : _SpatialAudioDefaults.coneInnerAngle);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        value = D2r(value);\r\n\r\n        if (value != this._optionsV2.spatialConeInnerAngle) {\r\n            if (this.directionalConeOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n            this._optionsV2.spatialConeInnerAngle = value;\r\n            if (this.spatialSound) {\r\n                this._initSpatial();\r\n                this._soundV2.spatial.coneInnerAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return R2d(typeof this._optionsV2.spatialConeOuterAngle === \"number\" ? this._optionsV2.spatialConeOuterAngle : _SpatialAudioDefaults.coneOuterAngle);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        value = D2r(value);\r\n\r\n        if (value != this._optionsV2.spatialConeOuterAngle) {\r\n            if (value < this.directionalConeInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n            this._optionsV2.spatialConeOuterAngle = value;\r\n            if (this.spatialSound) {\r\n                this._initSpatial();\r\n                this._soundV2.spatial.coneOuterAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (this._optionsV2.spatialPosition && newPosition.equals(this._optionsV2.spatialPosition)) {\r\n            return;\r\n        }\r\n        if (!this._optionsV2.spatialPosition) {\r\n            this._optionsV2.spatialPosition = Vector3.Zero();\r\n        }\r\n        this._optionsV2.spatialPosition.copyFrom(newPosition);\r\n        if (this.spatialSound && !isNaN(newPosition.x) && !isNaN(newPosition.y) && !isNaN(newPosition.z)) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.position = newPosition;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this.spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n\r\n        this._initSpatial();\r\n        this._soundV2.spatial.orientation = direction;\r\n    }\r\n\r\n    private _initSpatial() {\r\n        this._soundV2._isSpatial = true;\r\n\r\n        if (this._optionsV2.spatialDistanceModel === undefined) {\r\n            this._optionsV2.spatialDistanceModel = \"linear\";\r\n            this._soundV2.spatial.distanceModel = \"linear\";\r\n        }\r\n\r\n        if (this._optionsV2.spatialMaxDistance === undefined) {\r\n            this._optionsV2.spatialMaxDistance = 100;\r\n            this._soundV2.spatial.maxDistance = 100;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public updateDistanceFromListener() {\r\n        if (this._soundV2._outNode && this._connectedTransformNode && this.useCustomAttenuation && this._scene.activeCamera) {\r\n            const distance = this._scene.audioListenerPositionProvider\r\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\r\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundV2.volume = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n        audioEngine?.unlock();\r\n\r\n        // WebAudio sound sources have no `play` function because they are always playing.\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        if (this._isReadyToPlay && this._scene.audioEnabled) {\r\n            // The sound can only resume from pause when the `time`, `offset` and `length` args are not set.\r\n            if (this._soundV2.state === SoundState.Paused && (time !== undefined || offset !== undefined || length !== undefined)) {\r\n                this._soundV2.stop();\r\n            }\r\n\r\n            try {\r\n                TmpPlayOptions.duration = length || 0;\r\n                TmpPlayOptions.startOffset = offset !== undefined ? offset || this._optionsV2.startOffset! : this._optionsV2.startOffset!;\r\n                TmpPlayOptions.waitTime = time || 0;\r\n\r\n                if (audioEngine?.unlocked) {\r\n                    this._soundV2.play(TmpPlayOptions);\r\n                } else {\r\n                    // Wait a bit for FF as context seems late to be ready.\r\n                    setTimeout(() => {\r\n                        (this._soundV2 as _WebAudioStaticSound | _WebAudioStreamingSound).play(TmpPlayOptions);\r\n                    }, 500);\r\n                }\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended = () => {\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    };\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (!this._soundV2) {\r\n            return;\r\n        }\r\n\r\n        // WebAudio sound sources have no `stop` function because they are always playing.\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        TmpStopOptions.waitTime = time || 0;\r\n        this._soundV2.stop(TmpStopOptions);\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (!this._soundV2) {\r\n            return;\r\n        }\r\n\r\n        // WebAudio sound sources have no `pause` function because they are always playing.\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        this._soundV2.pause();\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (!this.isReady()) {\r\n            this._onReady.addOnce(() => {\r\n                this.setVolume(newVolume, time);\r\n            });\r\n            return;\r\n        }\r\n\r\n        TmpRampOptions.duration = time || 0;\r\n        this._soundV2.setVolume(newVolume, TmpRampOptions);\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            this._soundV2.playbackRate = newPlaybackRate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sound play back rate.\r\n     * @returns the  play back rate of the sound\r\n     */\r\n    public getPlaybackRate(): number {\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            return this._soundV2.playbackRate;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this.spatialSound) {\r\n            this.spatialSound = true;\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!(this._soundV2 instanceof _WebAudioStaticSound)) {\r\n            return null;\r\n        }\r\n\r\n        const currentOptions: ISoundOptions = {\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this.spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            useCustomAttenuation: this.useCustomAttenuation,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n        };\r\n        const clonedSound = new Sound(this.name + \"_cloned\", this._soundV2.buffer, this._scene, null, currentOptions);\r\n        (clonedSound._optionsV2 as any) = this._optionsV2;\r\n        if (this.useCustomAttenuation) {\r\n            clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n        }\r\n        return clonedSound;\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            return this._soundV2.buffer._audioBuffer;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        // return this._soundSource;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundV2._outNode as GainNode;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this._url,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this.spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this.getPlaybackRate(),\r\n            panningModel: this._soundV2.spatial.panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this.spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._soundV2.spatial.position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this.directionalConeInnerAngle;\r\n            serializationObject.coneOuterAngle = this.directionalConeOuterAngle;\r\n            serializationObject.coneOuterGain = this._soundV2.spatial.coneOuterVolume;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n        let newSound: Sound;\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene.removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene.addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                _RetryWithInterval(\r\n                    () => sourceSound._isReadyToPlay,\r\n                    () => {\r\n                        const audioBuffer = sourceSound.getAudioBuffer();\r\n                        if (audioBuffer) {\r\n                            newSound.setAudioBuffer(audioBuffer);\r\n                        }\r\n                        newSound._isReadyToPlay = true;\r\n                        if (newSound.autoplay) {\r\n                            newSound.play(0, sourceSound._optionsV2.startOffset, sourceSound._optionsV2.duration);\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    300\r\n                );\r\n            };\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n        return newSound;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.Sound\", Sound);\r\n","import type { Sound } from \"../Audio/sound\";\r\nimport { Logger } from \"../Misc/logger\";\r\n\r\n/**\r\n * Wraps one or more Sound objects and selects one with random weight for playback.\r\n */\r\nexport class WeightedSound {\r\n    /** When true a Sound will be selected and played when the current playing Sound completes. */\r\n    public loop: boolean = false;\r\n    private _coneInnerAngle: number = 360;\r\n    private _coneOuterAngle: number = 360;\r\n    private _volume: number = 1;\r\n    /** A Sound is currently playing. */\r\n    public isPlaying: boolean = false;\r\n    /** A Sound is currently paused. */\r\n    public isPaused: boolean = false;\r\n\r\n    private _sounds: Sound[] = [];\r\n    private _weights: number[] = [];\r\n    private _currentIndex?: number;\r\n\r\n    /**\r\n     * Creates a new WeightedSound from the list of sounds given.\r\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\r\n     * @param sounds Array of Sounds that will be selected from.\r\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\r\n     */\r\n    constructor(loop: boolean, sounds: Sound[], weights: number[]) {\r\n        if (sounds.length !== weights.length) {\r\n            throw new Error(\"Sounds length does not equal weights length\");\r\n        }\r\n\r\n        this.loop = loop;\r\n        this._weights = weights;\r\n        // Normalize the weights\r\n        let weightSum = 0;\r\n        for (const weight of weights) {\r\n            weightSum += weight;\r\n        }\r\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\r\n        for (let i = 0; i < this._weights.length; i++) {\r\n            this._weights[i] *= invWeightSum;\r\n        }\r\n        this._sounds = sounds;\r\n        for (const sound of this._sounds) {\r\n            sound.onEndedObservable.add(() => {\r\n                this._onended();\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return this._coneInnerAngle;\r\n    }\r\n\r\n    /**\r\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        if (value !== this._coneInnerAngle) {\r\n            if (this._coneOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneInnerAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeInnerAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return this._coneOuterAngle;\r\n    }\r\n\r\n    /**\r\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\r\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        if (value !== this._coneOuterAngle) {\r\n            if (value < this._coneInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n\r\n            this._coneOuterAngle = value;\r\n            for (const sound of this._sounds) {\r\n                sound.directionalConeOuterAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public get volume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Playback volume.\r\n     */\r\n    public set volume(value: number) {\r\n        if (value !== this._volume) {\r\n            for (const sound of this._sounds) {\r\n                sound.setVolume(value);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended() {\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].autoplay = false;\r\n        }\r\n        if (this.loop && this.isPlaying) {\r\n            this.play();\r\n        } else {\r\n            this.isPlaying = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Suspend playback\r\n     */\r\n    public pause() {\r\n        if (this.isPlaying) {\r\n            this.isPaused = true;\r\n            if (this._currentIndex !== undefined) {\r\n                this._sounds[this._currentIndex].pause();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stop playback\r\n     */\r\n    public stop() {\r\n        this.isPlaying = false;\r\n        if (this._currentIndex !== undefined) {\r\n            this._sounds[this._currentIndex].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start playback.\r\n     * @param startOffset Position the clip head at a specific time in seconds.\r\n     */\r\n    public play(startOffset?: number) {\r\n        if (!this.isPaused) {\r\n            this.stop();\r\n            const randomValue = Math.random();\r\n            let total = 0;\r\n            for (let i = 0; i < this._weights.length; i++) {\r\n                total += this._weights[i];\r\n                if (randomValue <= total) {\r\n                    this._currentIndex = i;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        const sound = this._sounds[this._currentIndex ?? 0];\r\n        if (sound.isReady()) {\r\n            sound.play(0, this.isPaused ? undefined : startOffset);\r\n        } else {\r\n            sound.autoplay = true;\r\n        }\r\n        this.isPlaying = true;\r\n        this.isPaused = false;\r\n    }\r\n}\r\n","import type { Sound } from \"./sound\";\r\nimport type { Analyser } from \"./analyser\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Options allowed during the creation of a sound track.\r\n */\r\nexport interface ISoundTrackOptions {\r\n    /**\r\n     * The volume the sound track should take during creation\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * Define if the sound track is the main sound track of the scene\r\n     */\r\n    mainTrack?: boolean;\r\n}\r\n\r\n/**\r\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\r\n * It will be also used in a future release to apply effects on a specific track.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n */\r\nexport class SoundTrack {\r\n    /**\r\n     * The unique identifier of the sound track in the scene.\r\n     */\r\n    public id: number = -1;\r\n    /**\r\n     * The list of sounds included in the sound track.\r\n     */\r\n    public soundCollection: Array<Sound>;\r\n\r\n    private _outputAudioNode: Nullable<GainNode>;\r\n    private _scene: Scene;\r\n    private _connectedAnalyser: Analyser;\r\n    private _options: ISoundTrackOptions;\r\n    private _isInitialized = false;\r\n\r\n    /**\r\n     * Creates a new sound track.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n     * @param scene Define the scene the sound track belongs to\r\n     * @param options\r\n     */\r\n    constructor(scene?: Nullable<Scene>, options: ISoundTrackOptions = {}) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        this.soundCollection = [];\r\n        this._options = options;\r\n\r\n        if (!this._options.mainTrack && this._scene.soundTracks) {\r\n            this._scene.soundTracks.push(this);\r\n            this.id = this._scene.soundTracks.length - 1;\r\n        }\r\n    }\r\n\r\n    private _initializeSoundTrackAudioGraph() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();\r\n            this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);\r\n\r\n            if (this._options) {\r\n                if (this._options.volume) {\r\n                    this._outputAudioNode.gain.value = this._options.volume;\r\n                }\r\n            }\r\n\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound track and its associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {\r\n            if (this._connectedAnalyser) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n            }\r\n            while (this.soundCollection.length) {\r\n                this.soundCollection[0].dispose();\r\n            }\r\n            if (this._outputAudioNode) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a sound to this sound track\r\n     * @param sound define the sound to add\r\n     * @ignoreNaming\r\n     */\r\n    public addSound(sound: Sound): void {\r\n        if (!this._isInitialized) {\r\n            this._initializeSoundTrackAudioGraph();\r\n        }\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\r\n        }\r\n        if (sound.soundTrackId !== undefined) {\r\n            if (sound.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(sound);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\r\n            }\r\n        }\r\n\r\n        this.soundCollection.push(sound);\r\n        sound.soundTrackId = this.id;\r\n    }\r\n\r\n    /**\r\n     * Removes a sound to this sound track\r\n     * @param sound define the sound to remove\r\n     * @ignoreNaming\r\n     */\r\n    public removeSound(sound: Sound): void {\r\n        const index = this.soundCollection.indexOf(sound);\r\n        if (index !== -1) {\r\n            this.soundCollection.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global volume for the full sound track.\r\n     * @param newVolume Define the new volume of the sound track\r\n     */\r\n    public setVolume(newVolume: number): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower  it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the sound track to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        this._connectedAnalyser = analyser;\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);\r\n        }\r\n    }\r\n}\r\n","import { Sound } from \"./sound\";\r\nimport { SoundTrack } from \"./soundTrack\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"./audioEngine\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    // TODO: add sound\r\n    let loadedSounds: Sound[] = [];\r\n    let loadedSound: Sound;\r\n    container.sounds = container.sounds || [];\r\n    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\r\n        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\r\n            const parsedSound = parsedData.sounds[index];\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n                if (!parsedSound.url) {\r\n                    parsedSound.url = parsedSound.name;\r\n                }\r\n                if (!loadedSounds[parsedSound.url]) {\r\n                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\r\n                    loadedSounds[parsedSound.url] = loadedSound;\r\n                    container.sounds.push(loadedSound);\r\n                } else {\r\n                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\r\n                }\r\n            } else {\r\n                container.sounds.push(new Sound(parsedSound.name, null, scene));\r\n            }\r\n        }\r\n    }\r\n\r\n    loadedSounds = [];\r\n});\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         * Backing field\r\n         */\r\n        _mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The main sound track played by the scene.\r\n         * It contains your primary collection of sounds.\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The list of sound tracks added to the scene\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        soundTracks: Nullable<Array<SoundTrack>>;\r\n\r\n        /**\r\n         * Gets a sound using a given name\r\n         * @param name defines the name to search for\r\n         * @returns the found sound or null if not found at all.\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        getSoundByName(name: string): Nullable<Sound>;\r\n\r\n        /**\r\n         * Gets or sets if audio support is enabled\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioEnabled: boolean;\r\n\r\n        /**\r\n         * Gets or sets if audio will be output to headphones\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        headphone: boolean;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener position provider\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioListenerPositionProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener rotation provider\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioListenerRotationProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets a refresh rate when using 3D audio positioning\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioPositioningRefreshRate: number;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (!this._mainSoundTrack) {\r\n            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });\r\n        }\r\n\r\n        return this._mainSoundTrack;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getSoundByName = function (name: string): Nullable<Sound> {\r\n    let index: number;\r\n    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\r\n        if (this.mainSoundTrack.soundCollection[index].name === name) {\r\n            return this.mainSoundTrack.soundCollection[index];\r\n        }\r\n    }\r\n\r\n    if (this.soundTracks) {\r\n        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\r\n            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\r\n                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\r\n                    return this.soundTracks[sdIndex].soundCollection[index];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioEnabled;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.enableAudio();\r\n        } else {\r\n            compo.disableAudio();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"headphone\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.headphone;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.switchAudioModeForHeadphones();\r\n        } else {\r\n            compo.switchAudioModeForNormalSpeakers();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerPositionProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerPositionProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerRotationProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerRotationProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioPositioningRefreshRate;\r\n    },\r\n    set: function (this: Scene, value: number) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        compo.audioPositioningRefreshRate = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Defines the sound scene component responsible to manage any sounds\r\n * in a given scene.\r\n * @deprecated please use AudioEngineV2 instead\r\n */\r\nexport class AudioSceneComponent implements ISceneSerializableComponent {\r\n    private static _CameraDirection = new Vector3(0, 0, -1);\r\n\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_AUDIO;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _audioEnabled = true;\r\n    /**\r\n     * Gets whether audio is enabled or not.\r\n     * Please use related enable/disable method to switch state.\r\n     */\r\n    public get audioEnabled(): boolean {\r\n        return this._audioEnabled;\r\n    }\r\n\r\n    private _headphone = false;\r\n    /**\r\n     * Gets whether audio is outputting to headphone or not.\r\n     * Please use the according Switch methods to change output.\r\n     */\r\n    public get headphone(): boolean {\r\n        return this._headphone;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a refresh rate when using 3D audio positioning\r\n     */\r\n    public audioPositioningRefreshRate = 500;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener position for all sounds in the scene\r\n     * By default, this is the position of the first active camera\r\n     */\r\n    public audioListenerPositionProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener rotation for all sounds in the scene\r\n     * By default, this is the rotation of the first active camera\r\n     */\r\n    public audioListenerRotationProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        scene.soundTracks = [] as SoundTrack[];\r\n        scene.sounds = [] as Sound[];\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here. (Not rendering related)\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        serializationObject.sounds = [];\r\n\r\n        if (this.scene.soundTracks) {\r\n            for (let index = 0; index < this.scene.soundTracks.length; index++) {\r\n                const soundtrack = this.scene.soundTracks[index];\r\n\r\n                for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\r\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.play();\r\n            sound.autoplay = true;\r\n            this.scene.mainSoundTrack.addSound(sound);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose = false): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.stop();\r\n            sound.autoplay = false;\r\n            this.scene.mainSoundTrack.removeSound(sound);\r\n            if (dispose) {\r\n                sound.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.scene;\r\n        if (scene._mainSoundTrack) {\r\n            scene.mainSoundTrack.dispose();\r\n        }\r\n\r\n        if (scene.soundTracks) {\r\n            for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\r\n                scene.soundTracks[scIndex].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables audio in the associated scene.\r\n     */\r\n    public disableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = false;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.suspend();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            scene.mainSoundTrack.soundCollection[i].pause();\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    scene.soundTracks[i].soundCollection[j].pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables audio in the associated scene.\r\n     */\r\n    public enableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = true;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.resume();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            if (scene.mainSoundTrack.soundCollection[i].isPaused) {\r\n                scene.mainSoundTrack.soundCollection[i].play();\r\n            }\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    if (scene.soundTracks[i].soundCollection[j].isPaused) {\r\n                        scene.soundTracks[i].soundCollection[j].play();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to headphone output.\r\n     */\r\n    public switchAudioModeForHeadphones() {\r\n        const scene = this.scene;\r\n        this._headphone = true;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToHRTF();\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to normal speakers.\r\n     */\r\n    public switchAudioModeForNormalSpeakers() {\r\n        const scene = this.scene;\r\n        this._headphone = false;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToEqualPower();\r\n\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _cachedCameraDirection = new Vector3();\r\n    private _cachedCameraPosition = new Vector3();\r\n    private _lastCheck = 0;\r\n    private _invertMatrixTemp = new Matrix();\r\n    private _cameraDirectionTemp = new Vector3();\r\n\r\n    private _afterRender() {\r\n        const now = PrecisionDate.Now;\r\n        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck = now;\r\n\r\n        const scene = this.scene;\r\n        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {\r\n            return;\r\n        }\r\n\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n\r\n        if (!audioEngine) {\r\n            return;\r\n        }\r\n\r\n        if (audioEngine.audioContext) {\r\n            let listeningCamera = scene.activeCamera;\r\n            if (scene.activeCameras && scene.activeCameras.length > 0) {\r\n                listeningCamera = scene.activeCameras[0];\r\n            }\r\n\r\n            // A custom listener position provider was set\r\n            // Use the users provided position instead of camera's\r\n            if (this.audioListenerPositionProvider) {\r\n                const position: Vector3 = this.audioListenerPositionProvider();\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // Set the listener position to the listening camera global position\r\n                if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\r\n                    this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\r\n                    audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\r\n                }\r\n            }\r\n            // Otherwise set the listener position to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(0, 0, 0);\r\n            }\r\n\r\n            // A custom listener rotation provider was set\r\n            // Use the users provided rotation instead of camera's\r\n            if (this.audioListenerRotationProvider) {\r\n                const rotation: Vector3 = this.audioListenerRotationProvider();\r\n                audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // for VR cameras\r\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\r\n                    listeningCamera = listeningCamera.rigCameras[0];\r\n                }\r\n\r\n                listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\r\n                Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\r\n                this._cameraDirectionTemp.normalize();\r\n                // To avoid some errors on GearVR\r\n                if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\r\n                    if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\r\n                        this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\r\n                        audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise set the listener rotation to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\r\n            }\r\n\r\n            let i: number;\r\n            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n                const sound = scene.mainSoundTrack.soundCollection[i];\r\n                if (sound.useCustomAttenuation) {\r\n                    sound.updateDistanceFromListener();\r\n                }\r\n            }\r\n            if (scene.soundTracks) {\r\n                for (i = 0; i < scene.soundTracks.length; i++) {\r\n                    for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                        const sound = scene.soundTracks[i].soundCollection[j];\r\n                        if (sound.useCustomAttenuation) {\r\n                            sound.updateDistanceFromListener();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nSound._SceneComponentInitialization = (scene: Scene) => {\r\n    let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\r\n    if (!compo) {\r\n        compo = new AudioSceneComponent(scene);\r\n        scene._addComponent(compo);\r\n    }\r\n};\r\n","import type { Nullable } from \"core/types\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Sound } from \"core/Audio/sound\";\r\nimport { WeightedSound } from \"core/Audio/weightedsound\";\r\n\r\nimport type { IArrayItem, IScene, INode, IAnimation } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IMSFTAudioEmitter_Clip, IMSFTAudioEmitter_Emitter, IMSFTAudioEmitter_EmittersReference, IMSFTAudioEmitter_AnimationEvent } from \"babylonjs-gltf2interface\";\r\nimport { IMSFTAudioEmitter_AnimationEventAction } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nimport \"core/Audio/audioSceneComponent\";\r\n\r\nconst NAME = \"MSFT_audio_emitter\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_audio_emitter extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_audio_emitter\"]: {};\r\n    }\r\n}\r\n\r\ninterface ILoaderClip extends IMSFTAudioEmitter_Clip, IArrayItem {\r\n    _objectURL?: Promise<string>;\r\n}\r\n\r\ninterface ILoaderEmitter extends IMSFTAudioEmitter_Emitter, IArrayItem {\r\n    _babylonData?: {\r\n        sound?: WeightedSound;\r\n        loaded: Promise<void>;\r\n    };\r\n    _babylonSounds: Sound[];\r\n}\r\n\r\ninterface IMSFTAudioEmitter {\r\n    clips: ILoaderClip[];\r\n    emitters: ILoaderEmitter[];\r\n}\r\n\r\ninterface ILoaderAnimationEvent extends IMSFTAudioEmitter_AnimationEvent, IArrayItem {}\r\n\r\ninterface ILoaderAnimationEvents {\r\n    events: ILoaderAnimationEvent[];\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_audio_emitter implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    private _loader: GLTFLoader;\r\n    private _clips: Array<ILoaderClip>;\r\n    private _emitters: Array<ILoaderEmitter>;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n        (this._clips as any) = null;\r\n        (this._emitters as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public onLoading(): void {\r\n        const extensions = this._loader.gltf.extensions;\r\n        if (extensions && extensions[this.name]) {\r\n            const extension = extensions[this.name] as IMSFTAudioEmitter;\r\n\r\n            this._clips = extension.clips;\r\n            this._emitters = extension.emitters;\r\n\r\n            ArrayItem.Assign(this._clips);\r\n            ArrayItem.Assign(this._emitters);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference>(context, scene, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            promises.push(this._loader.loadSceneAsync(context, scene));\r\n\r\n            for (const emitterIndex of extension.emitters) {\r\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                if (\r\n                    emitter.refDistance != undefined ||\r\n                    emitter.maxDistance != undefined ||\r\n                    emitter.rolloffFactor != undefined ||\r\n                    emitter.distanceModel != undefined ||\r\n                    emitter.innerAngle != undefined ||\r\n                    emitter.outerAngle != undefined\r\n                ) {\r\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\r\n                }\r\n\r\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\r\n            }\r\n\r\n            await Promise.all(promises);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTAudioEmitter_EmittersReference, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n\r\n            const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\r\n                for (const emitterIndex of extension.emitters) {\r\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\r\n                    promises.push(\r\n                        // eslint-disable-next-line github/no-then\r\n                        this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\r\n                            for (const sound of emitter._babylonSounds) {\r\n                                sound.attachToMesh(babylonMesh);\r\n                                if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\r\n                                    sound.setLocalDirectionToMesh(Vector3.Forward());\r\n                                    sound.setDirectionalCone(\r\n                                        2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle),\r\n                                        2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle),\r\n                                        0\r\n                                    );\r\n                                }\r\n                            }\r\n                        })\r\n                    );\r\n                }\r\n\r\n                assign(babylonMesh);\r\n            });\r\n            await Promise.all(promises);\r\n            return babylonMesh;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return GLTFLoader.LoadExtensionAsync<ILoaderAnimationEvents, AnimationGroup>(context, animation, this.name, async (extensionContext, extension) => {\r\n            const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);\r\n            const promises = new Array<Promise<any>>();\r\n            ArrayItem.Assign(extension.events);\r\n            for (const event of extension.events) {\r\n                promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\r\n            }\r\n            await Promise.all(promises);\r\n            return babylonAnimationGroup;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadClipAsync(context: string, clip: ILoaderClip): Promise<string> {\r\n        if (clip._objectURL) {\r\n            return clip._objectURL;\r\n        }\r\n\r\n        let promise: Promise<ArrayBufferView>;\r\n        if (clip.uri) {\r\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\r\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        clip._objectURL = promise.then((data) => {\r\n            return URL.createObjectURL(new Blob([data], { type: clip.mimeType }));\r\n        });\r\n\r\n        return clip._objectURL;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadEmitterAsync(context: string, emitter: ILoaderEmitter): Promise<void> {\r\n        emitter._babylonSounds = emitter._babylonSounds || [];\r\n        if (!emitter._babylonData) {\r\n            const clipPromises = new Array<Promise<any>>();\r\n            const name = emitter.name || `emitter${emitter.index}`;\r\n            const options = {\r\n                loop: false,\r\n                autoplay: false,\r\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\r\n            };\r\n\r\n            for (let i = 0; i < emitter.clips.length; i++) {\r\n                const clipContext = `/extensions/${this.name}/clips`;\r\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\r\n                clipPromises.push(\r\n                    // eslint-disable-next-line github/no-then\r\n                    this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL: string) => {\r\n                        const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\r\n                        sound.refDistance = emitter.refDistance || 1;\r\n                        sound.maxDistance = emitter.maxDistance || 256;\r\n                        sound.rolloffFactor = emitter.rolloffFactor || 1;\r\n                        sound.distanceModel = emitter.distanceModel || \"exponential\";\r\n                    })\r\n                );\r\n            }\r\n\r\n            // eslint-disable-next-line github/no-then\r\n            const promise = Promise.all(clipPromises).then(() => {\r\n                const weights = emitter.clips.map((clip) => {\r\n                    return clip.weight || 1;\r\n                });\r\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\r\n                if (emitter.innerAngle) {\r\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\r\n                }\r\n                if (emitter.outerAngle) {\r\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\r\n                }\r\n                if (emitter.volume) {\r\n                    weightedSound.volume = emitter.volume;\r\n                }\r\n                emitter._babylonData!.sound = weightedSound;\r\n            });\r\n\r\n            emitter._babylonData = {\r\n                loaded: promise,\r\n            };\r\n        }\r\n\r\n        return emitter._babylonData.loaded;\r\n    }\r\n\r\n    private _getEventAction(\r\n        context: string,\r\n        sound: WeightedSound,\r\n        action: IMSFTAudioEmitter_AnimationEventAction,\r\n        time: number,\r\n        startOffset?: number\r\n    ): (currentFrame: number) => void {\r\n        switch (action) {\r\n            case IMSFTAudioEmitter_AnimationEventAction.play: {\r\n                return (currentFrame: number) => {\r\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\r\n                    sound.play(frameOffset);\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.stop: {\r\n                return () => {\r\n                    sound.stop();\r\n                };\r\n            }\r\n            case IMSFTAudioEmitter_AnimationEventAction.pause: {\r\n                return () => {\r\n                    sound.pause();\r\n                };\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Unsupported action ${action}`);\r\n            }\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadAnimationEventAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        event: ILoaderAnimationEvent,\r\n        babylonAnimationGroup: AnimationGroup\r\n    ): Promise<void> {\r\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\r\n            return Promise.resolve();\r\n        }\r\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\r\n        const emitterIndex = event.emitter;\r\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\r\n        // eslint-disable-next-line github/no-then\r\n        return this._loadEmitterAsync(context, emitter).then(() => {\r\n            const sound = emitter._babylonData!.sound;\r\n            if (sound) {\r\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\r\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\r\n                // Make sure all started audio stops when this animation is terminated.\r\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\r\n                    sound.stop();\r\n                });\r\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\r\n                    sound.pause();\r\n                });\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\r\n","import type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { ISoundSourceOptions } from \"../abstractAudio/abstractSoundSource\";\nimport { AbstractSoundSource } from \"../abstractAudio/abstractSoundSource\";\nimport type { AbstractSpatialAudio } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode } from \"./webAudioNode\";\n\n/** @internal */\nexport class _WebAudioSoundSource extends AbstractSoundSource {\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n    protected _webAudioNode: AudioNode;\n\n    /** @internal */\n    public _audioContext: AudioContext | OfflineAudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(name: string, webAudioNode: AudioNode, engine: _WebAudioEngine, options: Partial<ISoundSourceOptions>) {\n        super(name, engine, options);\n\n        this._audioContext = this.engine._audioContext;\n        this._webAudioNode = webAudioNode;\n\n        this._subGraph = new _WebAudioSoundSource._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _initAsync(options: Partial<ISoundSourceOptions>): Promise<void> {\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.initAsync(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        this.engine._addNode(this);\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._webAudioNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeNode(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioSoundSource\";\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio {\n        return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioSoundSource;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n\n        protected override _onSubNodesChanged(): void {\n            super._onSubNodesChanged();\n\n            this._owner._inNode.disconnect();\n\n            if (this._owner._subGraph._inNode) {\n                this._owner._inNode.connect(this._owner._subGraph._inNode);\n            }\n        }\n    };\n}\n"],"names":["StreamingSound","name","engine","options","super","_preloadedInstances","Array","preloadCount","this","_options","preloadCompletedCount","length","preloadInstanceAsync","instance","_createInstance","_addPreloadedInstance","preloadedPromise","preloadInstancesAsync","count","i","Promise","all","map","async","play","state","resume","startOffset","_removePreloadedInstance","onInstanceStateChanged","_stopExcessInstances","onStateChangedObservable","removeCallback","add","loop","volume","_beforePlay","_afterPlay","stop","_setState","_instances","from","includes","push","index","indexOf","splice","_StreamingSoundInstance","sound","onReadyObservable","resolve","reject","_rejectPreloadedProimse","_resolvePreloadedPromise","onErrorObservable","value","dispose","clear","_WebAudioStreamingSound","_stereo","autoplay","maxInstances","Infinity","_subGraph","_SubGraph","_initAsync","source","audioContext","_audioContext","AudioContext","Error","_source","outBus","outBusAutoDefault","isReadyPromise","defaultMainBus","initAsync","_initSpatialProperty","_addSound","_inNode","_outNode","stereo","_removeSound","getClassName","_WebAudioStreamingSoundInstance","_connect","node","connect","_disconnect","disconnect","_createSpatialProperty","autoUpdate","minUpdateTime","_getOptions","_downstreamNodes","_owner","_upstreamNodes","_currentTimeChangedWhilePaused","_enginePlayTime","_enginePauseTime","_isReady","_isReadyPromise","_resolveIsReadyPromise","_rejectIsReadyPromise","_onCanPlayThrough","_mediaElement","notifyObservers","_onEnded","onEndedObservable","_onError","reason","_onEngineStateChanged","stateChangedObservable","_onUserGesture","_volumeNode","GainNode","_initFromUrl","isArray","_initFromUrls","HTMLMediaElement","_initFromMediaElement","currentTime","_state","timeSinceLastStart","restart","pause","startTime","_sourceNode","removeEventListener","children","removeChild","userGestureObservable","undefined","gain","_play","_stop","mediaElement","SetCorsBehavior","currentSrc","controls","preload","addEventListener","once","load","MediaElementAudioSourceNode","_sound","url","audio","Audio","urls","document","createElement","src","appendChild","result","catch","addOnce","_playWhenReady","then","AnimationEvent","constructor","frame","action","onlyOnce","isDone","_clone","TmpRampOptions","duration","shape","TmpPlayOptions","waitTime","TmpStopOptions","D2r","degrees","Math","PI","R2d","radians","Sound","_soundV2","_WebAudioSoundSource","_optionsV2","isPlaying","isReady","isPaused","maxDistance","spatialMaxDistance","useCustomAttenuation","_initSpatial","spatial","distanceModel","spatialDistanceModel","spatialSound","_isSpatial","newValue","_onReady","_onReadyObservable","urlOrArrayBuffer","scene","readyToPlayCallback","soundTrackId","refDistance","rolloffFactor","metadata","_localDirection","_volume","_isReadyToPlay","_isDirectional","_isOutputConnected","_url","_onReadyToPlay","_scene","mainSoundTrack","addSound","_readyToPlayCallback","_onended","onended","LastCreatedScene","_SceneComponentInitialization","_customAttenuationFunction","currentVolume","currentDistance","optionsV2","analyzerEnabled","loopEnd","loopStart","playbackRate","pitch","skipCodecCheck","spatialEnabled","spatialMinDistance","spatialRolloffFactor","stereoEnabled","offset","spatialAutoUpdate","spatialConeInnerAngle","coneInnerAngle","spatialConeOuterAngle","coneOuterAngle","spatialConeOuterVolume","coneOuterVolume","spatialMinUpdateTime","spatialOrientation","orientation","clone","spatialPanningModel","headphone","spatialPosition","position","spatialRotation","rotation","spatialRotationQuaternion","rotationQuaternion","Number","MAX_VALUE","streaming","audioEngine","audioEngineV2","_v2","createSoundV2","streamingOptionsV2","_WebAudioStaticSound","ArrayBuffer","MediaStream","MediaStreamAudioSourceNode","mediaStream","AudioBuffer","removeSound","soundTracks","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","setAudioBuffer","audioBuffer","updateOptions","setPlaybackRate","setVolume","updated","_updateSpatialParameters","minDistance","panningModel","switchPanningModelToHRTF","switchPanningModelToEqualPower","connectToSoundTrackAudioNode","soundTrackAudioNode","outputNode","setDirectionalCone","coneOuterGain","directionalConeInnerAngle","directionalConeOuterAngle","setPosition","newPosition","equals","Zero","copyFrom","isNaN","x","y","z","setLocalDirectionToMesh","newLocalDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","updateDistanceFromListener","activeCamera","distance","audioListenerPositionProvider","subtract","getDistanceToCamera","setAttenuationFunction","callback","time","unlock","audioEnabled","unlocked","setTimeout","ex","message","newVolume","newPlaybackRate","getPlaybackRate","getVolume","attachToMesh","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","detachFromMesh","getBoundingInfo","boundingInfo","boundingSphere","centerWorld","absolutePosition","currentOptions","clonedSound","buffer","getAudioBuffer","_audioBuffer","getSoundSource","getSoundGain","serialize","serializationObject","connectedMeshId","id","asArray","isDirectional","localDirectionToMesh","Parse","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","setBufferAndRun","removePendingData","addPendingData","soundPosition","FromArray","connectedMesh","getMeshById","_","WeightedSound","sounds","weights","_coneInnerAngle","_coneOuterAngle","_sounds","_weights","weightSum","weight","invWeightSum","_currentIndex","randomValue","random","total","SoundTrack","_isInitialized","soundCollection","mainTrack","_initializeSoundTrackAudioGraph","canUseWebAudio","_outputAudioNode","createGain","masterGain","_connectedAnalyser","stopDebugCanvas","connectToAnalyser","analyser","connectAudioNodes","NAME_AUDIO","parsedData","container","loadedSound","loadedSounds","cache","Object","defineProperty","prototype","get","compo","_getComponent","AudioSceneComponent","_addComponent","_mainSoundTrack","enumerable","configurable","getSoundByName","sdIndex","set","enableAudio","disableAudio","switchAudioModeForHeadphones","switchAudioModeForNormalSpeakers","audioListenerRotationProvider","audioPositioningRefreshRate","_audioEnabled","_headphone","_cachedCameraDirection","_cachedCameraPosition","_lastCheck","_invertMatrixTemp","_cameraDirectionTemp","register","_afterRenderStage","registerStep","STEP_AFTERRENDER_AUDIO","_afterRender","rebuild","soundtrack","soundId","addFromContainer","removeFromContainer","scIndex","suspend","j","now","Now","listeningCamera","activeCameras","listener","globalPosition","setOrientation","rigCameras","getViewMatrix","invertToRef","TransformNormalToRef","_CameraDirection","NAME","MSFT_audio_emitter","loader","_loader","enabled","isExtensionUsed","_clips","_emitters","onLoading","extensions","gltf","extension","clips","emitters","Assign","loadSceneAsync","context","LoadExtensionAsync","extensionContext","promises","emitterIndex","emitter","Get","innerAngle","outerAngle","_loadEmitterAsync","loadNodeAsync","assign","babylonMesh","_babylonSounds","Forward","ToDegrees","loadAnimationAsync","animation","babylonAnimationGroup","events","event","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","promise","uri","loadUriAsync","bufferView","bufferViews","loadBufferViewAsync","data","URL","createObjectURL","Blob","type","mimeType","_babylonData","clipPromises","clipContext","objectURL","babylonScene","weightedSound","loaded","_getEventAction","currentFrame","frameOffset","animationContext","targetedAnimations","babylonAnimation","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","webAudioNode","_webAudioNode","_addNode","_removeNode","_onSubNodesChanged"],"ignoreList":[],"sourceRoot":""}