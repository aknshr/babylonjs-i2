{"version":3,"file":"4760.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/KHR_interactivity/declarationMapper.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/CustomTypes/flowGraphMatrix.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/CustomTypes/flowGraphInteger.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphRichTypes.ts?"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport type { IKHRInteractivity_Declaration, IKHRInteractivity_Graph, IKHRInteractivity_Node } from \"babylonjs-gltf2interface\";\nimport { FlowGraphBlockNames } from \"core/FlowGraph/Blocks/flowGraphBlockNames\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { ISerializedFlowGraphBlock, ISerializedFlowGraphContext } from \"core/FlowGraph/typeDefinitions\";\nimport type { InteractivityEvent, InteractivityGraphToFlowGraphParser } from \"./interactivityGraphParser\";\nimport type { IGLTF } from \"../../glTFLoaderInterfaces\";\nimport { FlowGraphTypes, getAnimationTypeByFlowGraphType } from \"core/FlowGraph/flowGraphRichTypes\";\n\ninterface IGLTFToFlowGraphMappingObject {\n    /**\n     * The name of the property in the FlowGraph block.\n     */\n    name: string;\n\n    /**\n     * The type of the property in the glTF specs.\n     * If not provided will be inferred.\n     */\n    gltfType?: string;\n\n    /**\n     * The type of the property in the FlowGraph block.\n     * If not defined it equals the glTF type.\n     */\n    flowGraphType?: string;\n\n    /**\n     * A function that transforms the data from the glTF to the FlowGraph block.\n     */\n    dataTransformer?: (data: any, parser: InteractivityGraphToFlowGraphParser) => any;\n\n    /**\n     * If the property can contain multiple values.\n     */\n    isArray?: boolean;\n\n    /**\n     * If the property is in the options passed to the constructor of the block.\n     */\n    inOptions?: boolean;\n\n    /**\n     * If the property is an index to a value.\n     * if defined this will be the name of the array to find the object in.\n     */\n    isVariable?: boolean;\n\n    /**\n     * the name of the class type this value will be mapped to.\n     * This is used if we generate more than one block for a single glTF node.\n     * Defaults to the first block in the mapping.\n     */\n    toBlock?: FlowGraphBlockNames;\n\n    /**\n     * Used in configuration values. If defined, this will be the default value, if no value is provided.\n     */\n    defaultValue?: any;\n}\n\nexport interface IGLTFToFlowGraphMapping {\n    /**\n     * The type of the FlowGraph block(s).\n     * Typically will be a single element in an array.\n     * When adding blocks defined in this module use the KHR_interactivity prefix.\n     */\n    blocks: (FlowGraphBlockNames | string)[];\n    /**\n     * The inputs of the glTF node mapped to the FlowGraph block.\n     */\n    inputs?: {\n        /**\n         * The value inputs of the glTF node mapped to the FlowGraph block.\n         */\n        values?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n        /**\n         * The flow inputs of the glTF node mapped to the FlowGraph block.\n         */\n        flows?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n    };\n    /**\n     * The outputs of the glTF node mapped to the FlowGraph block.\n     */\n    outputs?: {\n        /**\n         * The value outputs of the glTF node mapped to the FlowGraph block.\n         */\n        values?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n        /**\n         * The flow outputs of the glTF node mapped to the FlowGraph block.\n         */\n        flows?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n    };\n    /**\n     * The configuration of the glTF node mapped to the FlowGraph block.\n     * This information is usually passed to the constructor of the block.\n     */\n    configuration?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n\n    /**\n     * If we generate more than one block for a single glTF node, this mapping will be used to map\n     * between the flowGraph classes.\n     */\n    typeToTypeMapping?: { [originName: string]: IGLTFToFlowGraphMappingObject };\n\n    /**\n     * The connections between two or more blocks.\n     * This is used to connect the blocks in the graph\n     */\n    interBlockConnectors?: {\n        /**\n         * The name of the input connection in the first block.\n         */\n        input: string;\n        /**\n         * The name of the output connection in the second block.\n         */\n        output: string;\n\n        /**\n         * The index of the block in the array of blocks that corresponds to the input.\n         */\n        inputBlockIndex: number;\n        /**\n         * The index of the block in the array of blocks that corresponds to the output.\n         */\n        outputBlockIndex: number;\n        /**\n         * If the connection is a variable connection or a flow connection.\n         */\n        isVariable?: boolean;\n    }[];\n\n    /**\n     * This optional function will allow to validate the node, according to the glTF specs.\n     * For example, if a node has a configuration object, it must be present and correct.\n     * This is a basic node-based validation.\n     * This function is expected to return false and log the error if the node is not valid.\n     * Note that this function can also modify the node, if needed.\n     *\n     * @param gltfBlock the glTF node to validate\n     * @param glTFObject the glTF object\n     * @returns true if validated, false if not.\n     */\n    validation?: (gltfBlock: IKHRInteractivity_Node, interactivityGraph: IKHRInteractivity_Graph, glTFObject?: IGLTF) => { valid: boolean; error?: string };\n\n    /**\n     * This is used if we need extra information for the constructor/options that is not provided directly by the glTF node.\n     * This function can return more than one node, if extra nodes are needed for this block to function correctly.\n     * Returning more than one block will usually happen when a json pointer was provided.\n     *\n     * @param gltfBlock the glTF node\n     * @param mapping the mapping object\n     * @param arrays the arrays of the interactivity object\n     * @param serializedObjects the serialized object\n     * @returns an array of serialized nodes that will be added to the graph.\n     */\n    extraProcessor?: (\n        gltfBlock: IKHRInteractivity_Node,\n        declaration: IKHRInteractivity_Declaration,\n        mapping: IGLTFToFlowGraphMapping,\n        parser: InteractivityGraphToFlowGraphParser,\n        serializedObjects: ISerializedFlowGraphBlock[],\n        context: ISerializedFlowGraphContext,\n        globalGLTF?: IGLTF\n    ) => ISerializedFlowGraphBlock[];\n}\n\nexport function getMappingForFullOperationName(fullOperationName: string) {\n    const [op, extension] = fullOperationName.split(\":\");\n    return getMappingForDeclaration({ op, extension });\n}\n\nexport function getMappingForDeclaration(declaration: IKHRInteractivity_Declaration, returnNoOpIfNotAvailable: boolean = true): IGLTFToFlowGraphMapping | undefined {\n    const mapping = declaration.extension ? gltfExtensionsToFlowGraphMapping[declaration.extension]?.[declaration.op] : gltfToFlowGraphMapping[declaration.op];\n    if (!mapping) {\n        Logger.Warn(`No mapping found for operation ${declaration.op} and extension ${declaration.extension || \"KHR_interactivity\"}`);\n        if (returnNoOpIfNotAvailable) {\n            const inputs: IGLTFToFlowGraphMapping[\"inputs\"] = {};\n            const outputs: IGLTFToFlowGraphMapping[\"outputs\"] = {\n                flows: {},\n            };\n            if (declaration.inputValueSockets) {\n                inputs.values = {};\n                for (const key in declaration.inputValueSockets) {\n                    inputs.values[key] = {\n                        name: key,\n                    };\n                }\n            }\n            if (declaration.outputValueSockets) {\n                outputs.values = {};\n                Object.keys(declaration.outputValueSockets).forEach((key) => {\n                    outputs.values![key] = {\n                        name: key,\n                    };\n                });\n            }\n            return {\n                blocks: [], // no blocks, just mapping\n                inputs,\n                outputs,\n            };\n        }\n    }\n    return mapping;\n}\n\n/**\n * This function will add new mapping to glTF interactivity.\n * Other extensions can define new types of blocks, this is the way to let interactivity know how to parse them.\n * @param key the type of node, i.e. \"variable/get\"\n * @param extension the extension of the interactivity operation, i.e. \"KHR_selectability\"\n * @param mapping The mapping object. See documentation or examples below.\n */\nexport function addNewInteractivityFlowGraphMapping(key: string, extension: string, mapping: IGLTFToFlowGraphMapping) {\n    gltfExtensionsToFlowGraphMapping[extension] ||= {};\n    gltfExtensionsToFlowGraphMapping[extension][key] = mapping;\n}\n\nconst gltfExtensionsToFlowGraphMapping: { [extension: string]: { [key: string]: IGLTFToFlowGraphMapping } } = {\n    /**\n     * This is the BABYLON extension for glTF interactivity.\n     * It defines babylon-specific blocks and operations.\n     */\n    BABYLON: {\n        /**\n         * flow/log is a flow node that logs input to the console.\n         * It has \"in\" and \"out\" flows, and takes a message as input.\n         * The message can be any type of value.\n         * The message is logged to the console when the \"in\" flow is triggered.\n         * The \"out\" flow is triggered when the message is logged.\n         */\n        \"flow/log\": {\n            blocks: [FlowGraphBlockNames.ConsoleLog],\n            inputs: {\n                values: {\n                    message: { name: \"message\" },\n                },\n            },\n        },\n    },\n};\n\n// this mapper is just a way to convert the glTF nodes to FlowGraph nodes in terms of input/output connection names and values.\nconst gltfToFlowGraphMapping: { [key: string]: IGLTFToFlowGraphMapping } = {\n    \"event/onStart\": {\n        blocks: [FlowGraphBlockNames.SceneReadyEvent],\n        outputs: {\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n    },\n    \"event/onTick\": {\n        blocks: [FlowGraphBlockNames.SceneTickEvent],\n        inputs: {},\n        outputs: {\n            values: {\n                timeSinceLastTick: { name: \"deltaTime\", gltfType: \"number\" /*, dataTransformer: (time: number) => time / 1000*/ },\n            },\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n    },\n    \"event/send\": {\n        blocks: [FlowGraphBlockNames.SendCustomEvent],\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // set eventId and eventData. The configuration object of the glTF should have a single object.\n            // validate that we are running it on the right block.\n            if (declaration.op !== \"event/send\" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {\n                throw new Error(\"Receive event should have a single configuration object, the event itself\");\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            const eventId = eventConfiguration.value?.[0];\n            if (typeof eventId !== \"number\") {\n                throw new Error(\"Event id should be a number\");\n            }\n            const event: InteractivityEvent = parser.arrays.events[eventId];\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.eventId = event.eventId;\n            serializedObject.config.eventData = event.eventData;\n            return serializedObjects;\n        },\n    },\n    \"event/receive\": {\n        blocks: [FlowGraphBlockNames.ReceiveCustomEvent],\n        outputs: {\n            flows: {\n                out: { name: \"done\" },\n            },\n        },\n        validation(gltfBlock, interactivityGraph) {\n            if (!gltfBlock.configuration) {\n                Logger.Error(\"Receive event should have a configuration object\");\n                return { valid: false, error: \"Receive event should have a configuration object\" };\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            if (!eventConfiguration) {\n                Logger.Error(\"Receive event should have a single configuration object, the event itself\");\n                return { valid: false, error: \"Receive event should have a single configuration object, the event itself\" };\n            }\n            const eventId = eventConfiguration.value?.[0];\n            if (typeof eventId !== \"number\") {\n                Logger.Error(\"Event id should be a number\");\n                return { valid: false, error: \"Event id should be a number\" };\n            }\n            const event = interactivityGraph.events?.[eventId];\n            if (!event) {\n                Logger.Error(`Event with id ${eventId} not found`);\n                return { valid: false, error: `Event with id ${eventId} not found` };\n            }\n            return { valid: true };\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // set eventId and eventData. The configuration object of the glTF should have a single object.\n            // validate that we are running it on the right block.\n            if (declaration.op !== \"event/receive\" || !gltfBlock.configuration || Object.keys(gltfBlock.configuration).length !== 1) {\n                throw new Error(\"Receive event should have a single configuration object, the event itself\");\n            }\n            const eventConfiguration = gltfBlock.configuration[\"event\"];\n            const eventId = eventConfiguration.value?.[0];\n            if (typeof eventId !== \"number\") {\n                throw new Error(\"Event id should be a number\");\n            }\n            const event: InteractivityEvent = parser.arrays.events[eventId];\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.eventId = event.eventId;\n            serializedObject.config.eventData = event.eventData;\n            return serializedObjects;\n        },\n    },\n    \"math/E\": getSimpleInputMapping(FlowGraphBlockNames.E),\n    \"math/Pi\": getSimpleInputMapping(FlowGraphBlockNames.PI),\n    \"math/Inf\": getSimpleInputMapping(FlowGraphBlockNames.Inf),\n    \"math/NaN\": getSimpleInputMapping(FlowGraphBlockNames.NaN),\n    \"math/abs\": getSimpleInputMapping(FlowGraphBlockNames.Abs),\n    \"math/sign\": getSimpleInputMapping(FlowGraphBlockNames.Sign),\n    \"math/trunc\": getSimpleInputMapping(FlowGraphBlockNames.Trunc),\n    \"math/floor\": getSimpleInputMapping(FlowGraphBlockNames.Floor),\n    \"math/ceil\": getSimpleInputMapping(FlowGraphBlockNames.Ceil),\n    \"math/round\": {\n        blocks: [FlowGraphBlockNames.Round],\n        configuration: {},\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.roundHalfAwayFromZero = true;\n            return serializedObjects;\n        },\n    },\n    \"math/fract\": getSimpleInputMapping(FlowGraphBlockNames.Fraction),\n    \"math/neg\": getSimpleInputMapping(FlowGraphBlockNames.Negation),\n    \"math/add\": getSimpleInputMapping(FlowGraphBlockNames.Add, [\"a\", \"b\"], true),\n    \"math/sub\": getSimpleInputMapping(FlowGraphBlockNames.Subtract, [\"a\", \"b\"], true),\n    \"math/mul\": {\n        blocks: [FlowGraphBlockNames.Multiply],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.useMatrixPerComponent = true;\n            serializedObjects[0].config.preventIntegerFloatArithmetic = true;\n            // try to infer the type or fallback to Integer\n            // check the gltf block for the inputs, see if they have a type\n            let type = -1;\n            Object.keys(_gltfBlock.values || {}).find((value) => {\n                if (_gltfBlock.values?.[value].type !== undefined) {\n                    type = _gltfBlock.values[value].type;\n                    return true;\n                }\n                return false;\n            });\n            if (type !== -1) {\n                serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;\n            }\n            return serializedObjects;\n        },\n        validation(gltfBlock) {\n            if (gltfBlock.values) {\n                // make sure types are the same\n                return ValidateTypes(gltfBlock);\n            }\n            return { valid: true };\n        },\n    },\n    \"math/div\": getSimpleInputMapping(FlowGraphBlockNames.Divide, [\"a\", \"b\"], true),\n    \"math/rem\": getSimpleInputMapping(FlowGraphBlockNames.Modulo, [\"a\", \"b\"]),\n    \"math/min\": getSimpleInputMapping(FlowGraphBlockNames.Min, [\"a\", \"b\"]),\n    \"math/max\": getSimpleInputMapping(FlowGraphBlockNames.Max, [\"a\", \"b\"]),\n    \"math/clamp\": getSimpleInputMapping(FlowGraphBlockNames.Clamp, [\"a\", \"b\", \"c\"]),\n    \"math/saturate\": getSimpleInputMapping(FlowGraphBlockNames.Saturate),\n    \"math/mix\": getSimpleInputMapping(FlowGraphBlockNames.MathInterpolation, [\"a\", \"b\", \"c\"]),\n    \"math/eq\": getSimpleInputMapping(FlowGraphBlockNames.Equality, [\"a\", \"b\"]),\n    \"math/lt\": getSimpleInputMapping(FlowGraphBlockNames.LessThan, [\"a\", \"b\"]),\n    \"math/le\": getSimpleInputMapping(FlowGraphBlockNames.LessThanOrEqual, [\"a\", \"b\"]),\n    \"math/gt\": getSimpleInputMapping(FlowGraphBlockNames.GreaterThan, [\"a\", \"b\"]),\n    \"math/ge\": getSimpleInputMapping(FlowGraphBlockNames.GreaterThanOrEqual, [\"a\", \"b\"]),\n    \"math/isNaN\": getSimpleInputMapping(FlowGraphBlockNames.IsNaN),\n    \"math/isInf\": getSimpleInputMapping(FlowGraphBlockNames.IsInfinity),\n    \"math/select\": {\n        blocks: [FlowGraphBlockNames.Conditional],\n        inputs: {\n            values: {\n                condition: { name: \"condition\" },\n                // Should we validate those have the same type here, or assume it is already validated?\n                a: { name: \"onTrue\" },\n                b: { name: \"onFalse\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"output\" },\n            },\n        },\n    },\n    \"math/random\": {\n        blocks: [FlowGraphBlockNames.Random],\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/sin\": getSimpleInputMapping(FlowGraphBlockNames.Sin),\n    \"math/cos\": getSimpleInputMapping(FlowGraphBlockNames.Cos),\n    \"math/tan\": getSimpleInputMapping(FlowGraphBlockNames.Tan),\n    \"math/asin\": getSimpleInputMapping(FlowGraphBlockNames.Asin),\n    \"math/acos\": getSimpleInputMapping(FlowGraphBlockNames.Acos),\n    \"math/atan\": getSimpleInputMapping(FlowGraphBlockNames.Atan),\n    \"math/atan2\": getSimpleInputMapping(FlowGraphBlockNames.Atan2, [\"a\", \"b\"]),\n    \"math/sinh\": getSimpleInputMapping(FlowGraphBlockNames.Sinh),\n    \"math/cosh\": getSimpleInputMapping(FlowGraphBlockNames.Cosh),\n    \"math/tanh\": getSimpleInputMapping(FlowGraphBlockNames.Tanh),\n    \"math/asinh\": getSimpleInputMapping(FlowGraphBlockNames.Asinh),\n    \"math/acosh\": getSimpleInputMapping(FlowGraphBlockNames.Acosh),\n    \"math/atanh\": getSimpleInputMapping(FlowGraphBlockNames.Atanh),\n    \"math/exp\": getSimpleInputMapping(FlowGraphBlockNames.Exponential),\n    \"math/log\": getSimpleInputMapping(FlowGraphBlockNames.Log),\n    \"math/log2\": getSimpleInputMapping(FlowGraphBlockNames.Log2),\n    \"math/log10\": getSimpleInputMapping(FlowGraphBlockNames.Log10),\n    \"math/sqrt\": getSimpleInputMapping(FlowGraphBlockNames.SquareRoot),\n    \"math/cbrt\": getSimpleInputMapping(FlowGraphBlockNames.CubeRoot),\n    \"math/pow\": getSimpleInputMapping(FlowGraphBlockNames.Power, [\"a\", \"b\"]),\n    \"math/length\": getSimpleInputMapping(FlowGraphBlockNames.Length),\n    \"math/normalize\": getSimpleInputMapping(FlowGraphBlockNames.Normalize),\n    \"math/dot\": getSimpleInputMapping(FlowGraphBlockNames.Dot, [\"a\", \"b\"]),\n    \"math/cross\": getSimpleInputMapping(FlowGraphBlockNames.Cross, [\"a\", \"b\"]),\n    \"math/rotate2D\": {\n        blocks: [FlowGraphBlockNames.Rotate2D],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                angle: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/rotate3D\": {\n        blocks: [FlowGraphBlockNames.Rotate3D],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                rotation: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/transform\": {\n        // glTF transform is vectorN with matrixN\n        blocks: [FlowGraphBlockNames.TransformVector],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine2\": {\n        blocks: [FlowGraphBlockNames.CombineVector2],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine3\": {\n        blocks: [FlowGraphBlockNames.CombineVector3],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/combine4\": {\n        blocks: [FlowGraphBlockNames.CombineVector4],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    // one input, N outputs! outputs named using numbers.\n    \"math/extract2\": {\n        blocks: [FlowGraphBlockNames.ExtractVector2],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n            },\n        },\n    },\n    \"math/extract3\": {\n        blocks: [FlowGraphBlockNames.ExtractVector3],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n            },\n        },\n    },\n    \"math/extract4\": {\n        blocks: [FlowGraphBlockNames.ExtractVector4],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n            },\n        },\n    },\n    \"math/transpose\": getSimpleInputMapping(FlowGraphBlockNames.Transpose),\n    \"math/determinant\": getSimpleInputMapping(FlowGraphBlockNames.Determinant),\n    \"math/inverse\": getSimpleInputMapping(FlowGraphBlockNames.InvertMatrix),\n    \"math/matMul\": getSimpleInputMapping(FlowGraphBlockNames.MatrixMultiplication, [\"a\", \"b\"]),\n    \"math/matCompose\": {\n        blocks: [FlowGraphBlockNames.MatrixCompose],\n        inputs: {\n            values: {\n                translation: { name: \"position\", gltfType: \"float3\" },\n                rotation: { name: \"rotationQuaternion\", gltfType: \"float4\" },\n                scale: { name: \"scaling\", gltfType: \"float3\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            const d = serializedObjects[0].dataInputs.find((input) => input.name === \"rotationQuaternion\");\n            if (!d) {\n                throw new Error(\"Rotation quaternion input not found\");\n            }\n            // if value is defined, set the type to quaternion\n            if (context._connectionValues[d.uniqueId]) {\n                context._connectionValues[d.uniqueId].type = FlowGraphTypes.Quaternion;\n            }\n            return serializedObjects;\n        },\n    },\n    \"math/matDecompose\": {\n        blocks: [FlowGraphBlockNames.MatrixDecompose],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                translation: { name: \"position\" },\n                rotation: { name: \"rotationQuaternion\" },\n                scale: { name: \"scaling\" },\n            },\n        },\n    },\n    \"math/quatConjugate\": getSimpleInputMapping(FlowGraphBlockNames.Conjugate, [\"a\"]),\n    \"math/quatMul\": {\n        blocks: [FlowGraphBlockNames.Multiply],\n        inputs: {\n            values: {\n                a: { name: \"a\", gltfType: \"vector4\" },\n                b: { name: \"b\", gltfType: \"vector4\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.type = FlowGraphTypes.Quaternion;\n            return serializedObjects;\n        },\n    },\n    \"math/quatAngleBetween\": getSimpleInputMapping(FlowGraphBlockNames.AngleBetween, [\"a\", \"b\"]),\n    \"math/quatFromAxisAngle\": {\n        blocks: [FlowGraphBlockNames.QuaternionFromAxisAngle],\n        inputs: {\n            values: {\n                axis: { name: \"a\", gltfType: \"float3\" },\n                angle: { name: \"b\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n    },\n    \"math/quatToAxisAngle\": getSimpleInputMapping(FlowGraphBlockNames.AxisAngleFromQuaternion, [\"a\"]),\n    \"math/quatFromDirections\": getSimpleInputMapping(FlowGraphBlockNames.QuaternionFromDirections, [\"a\", \"b\"]),\n    \"math/combine2x2\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix2D],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract2x2\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix2D],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"float2x2\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n            },\n        },\n    },\n    \"math/combine3x3\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix3D],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n                e: { name: \"input_4\", gltfType: \"number\" },\n                f: { name: \"input_5\", gltfType: \"number\" },\n                g: { name: \"input_6\", gltfType: \"number\" },\n                h: { name: \"input_7\", gltfType: \"number\" },\n                i: { name: \"input_8\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract3x3\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix3D],\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"float3x3\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n                \"4\": { name: \"output_4\" },\n                \"5\": { name: \"output_5\" },\n                \"6\": { name: \"output_6\" },\n                \"7\": { name: \"output_7\" },\n                \"8\": { name: \"output_8\" },\n            },\n        },\n    },\n    \"math/combine4x4\": {\n        blocks: [FlowGraphBlockNames.CombineMatrix],\n        inputs: {\n            values: {\n                a: { name: \"input_0\", gltfType: \"number\" },\n                b: { name: \"input_1\", gltfType: \"number\" },\n                c: { name: \"input_2\", gltfType: \"number\" },\n                d: { name: \"input_3\", gltfType: \"number\" },\n                e: { name: \"input_4\", gltfType: \"number\" },\n                f: { name: \"input_5\", gltfType: \"number\" },\n                g: { name: \"input_6\", gltfType: \"number\" },\n                h: { name: \"input_7\", gltfType: \"number\" },\n                i: { name: \"input_8\", gltfType: \"number\" },\n                j: { name: \"input_9\", gltfType: \"number\" },\n                k: { name: \"input_10\", gltfType: \"number\" },\n                l: { name: \"input_11\", gltfType: \"number\" },\n                m: { name: \"input_12\", gltfType: \"number\" },\n                n: { name: \"input_13\", gltfType: \"number\" },\n                o: { name: \"input_14\", gltfType: \"number\" },\n                p: { name: \"input_15\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            serializedObjects[0].config.inputIsColumnMajor = true;\n            return serializedObjects;\n        },\n    },\n    \"math/extract4x4\": {\n        blocks: [FlowGraphBlockNames.ExtractMatrix],\n        configuration: {},\n        inputs: {\n            values: {\n                a: { name: \"input\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                \"0\": { name: \"output_0\" },\n                \"1\": { name: \"output_1\" },\n                \"2\": { name: \"output_2\" },\n                \"3\": { name: \"output_3\" },\n                \"4\": { name: \"output_4\" },\n                \"5\": { name: \"output_5\" },\n                \"6\": { name: \"output_6\" },\n                \"7\": { name: \"output_7\" },\n                \"8\": { name: \"output_8\" },\n                \"9\": { name: \"output_9\" },\n                \"10\": { name: \"output_10\" },\n                \"11\": { name: \"output_11\" },\n                \"12\": { name: \"output_12\" },\n                \"13\": { name: \"output_13\" },\n                \"14\": { name: \"output_14\" },\n                \"15\": { name: \"output_15\" },\n            },\n        },\n    },\n    \"math/not\": {\n        blocks: [FlowGraphBlockNames.BitwiseNot],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketIn = serializedObjects[0].dataInputs[0];\n            serializedObjects[0].config.valueType = context._connectionValues[socketIn.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/and\": {\n        blocks: [FlowGraphBlockNames.BitwiseAnd],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/or\": {\n        blocks: [FlowGraphBlockNames.BitwiseOr],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/xor\": {\n        blocks: [FlowGraphBlockNames.BitwiseXor],\n        inputs: {\n            values: {\n                a: { name: \"a\" },\n                b: { name: \"b\" },\n            },\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _parser, serializedObjects, context) {\n            // configure it to work the way glTF specifies\n            serializedObjects[0].config ||= {};\n            // try to infer the type or fallback to Integer\n            const socketInA = serializedObjects[0].dataInputs[0];\n            const socketInB = serializedObjects[0].dataInputs[1];\n            serializedObjects[0].config.valueType =\n                context._connectionValues[socketInA.uniqueId]?.type ?? context._connectionValues[socketInB.uniqueId]?.type ?? FlowGraphTypes.Integer;\n            return serializedObjects;\n        },\n    },\n    \"math/asr\": getSimpleInputMapping(FlowGraphBlockNames.BitwiseRightShift, [\"a\", \"b\"]),\n    \"math/lsl\": getSimpleInputMapping(FlowGraphBlockNames.BitwiseLeftShift, [\"a\", \"b\"]),\n    \"math/clz\": getSimpleInputMapping(FlowGraphBlockNames.LeadingZeros),\n    \"math/ctz\": getSimpleInputMapping(FlowGraphBlockNames.TrailingZeros),\n    \"math/popcnt\": getSimpleInputMapping(FlowGraphBlockNames.OneBitsCounter),\n    \"math/rad\": getSimpleInputMapping(FlowGraphBlockNames.DegToRad),\n    \"math/deg\": getSimpleInputMapping(FlowGraphBlockNames.RadToDeg),\n    \"type/boolToInt\": getSimpleInputMapping(FlowGraphBlockNames.BooleanToInt),\n    \"type/boolToFloat\": getSimpleInputMapping(FlowGraphBlockNames.BooleanToFloat),\n    \"type/intToBool\": getSimpleInputMapping(FlowGraphBlockNames.IntToBoolean),\n    \"type/intToFloat\": getSimpleInputMapping(FlowGraphBlockNames.IntToFloat),\n    \"type/floatToInt\": getSimpleInputMapping(FlowGraphBlockNames.FloatToInt),\n    \"type/floatToBool\": getSimpleInputMapping(FlowGraphBlockNames.FloatToBoolean),\n\n    // flows\n    \"flow/sequence\": {\n        blocks: [FlowGraphBlockNames.Sequence],\n        extraProcessor(gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows || []).length;\n            serializedObject.signalOutputs.forEach((output, index) => {\n                output.name = \"out_\" + index;\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/branch\": {\n        blocks: [FlowGraphBlockNames.Branch],\n        outputs: {\n            flows: {\n                true: { name: \"onTrue\" },\n                false: { name: \"onFalse\" },\n            },\n        },\n    },\n    \"flow/switch\": {\n        blocks: [FlowGraphBlockNames.Switch],\n        configuration: {\n            cases: { name: \"cases\", isArray: true, inOptions: true, defaultValue: [] },\n        },\n        inputs: {\n            values: {\n                selection: { name: \"case\" },\n                default: { name: \"default\" },\n            },\n        },\n        validation(gltfBlock) {\n            const cases = gltfBlock.configuration?.cases;\n            if (cases && cases.value) {\n                const onlyIntegers = cases.value.every((caseValue) => {\n                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.\n                    return typeof caseValue === \"number\" && /^-?\\d+$/.test(caseValue.toString());\n                });\n                if (!onlyIntegers) {\n                    Logger.Warn(\"Switch cases should be integers. Using empty array instead.\");\n                    cases.value = [] as number[];\n                    return { valid: true };\n                }\n                // check for duplicates\n                const uniqueCases = new Set(cases.value);\n                cases.value = Array.from(uniqueCases) as number[];\n            }\n            return { valid: true };\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {\n            // convert all names of output flow to out_$1 apart from \"default\"\n            if (declaration.op !== \"flow/switch\" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {\n                throw new Error(\"Switch should have a single configuration object, the cases array\");\n            }\n            const serializedObject = serializedObjects[0];\n            serializedObject.signalOutputs.forEach((output) => {\n                if (output.name !== \"default\") {\n                    output.name = \"out_\" + output.name;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/while\": {\n        blocks: [FlowGraphBlockNames.WhileLoop],\n        outputs: {\n            flows: {\n                loopBody: { name: \"executionFlow\" },\n            },\n        },\n    },\n    \"flow/for\": {\n        blocks: [FlowGraphBlockNames.ForLoop],\n        configuration: {\n            initialIndex: { name: \"initialIndex\", gltfType: \"number\", inOptions: true, defaultValue: 0 },\n        },\n        inputs: {\n            values: {\n                startIndex: { name: \"startIndex\", gltfType: \"number\" },\n                endIndex: { name: \"endIndex\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                index: { name: \"index\" },\n            },\n            flows: {\n                loopBody: { name: \"executionFlow\" },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.incrementIndexWhenLoopDone = true;\n            return serializedObjects;\n        },\n    },\n    \"flow/doN\": {\n        blocks: [FlowGraphBlockNames.DoN],\n        configuration: {},\n        inputs: {\n            values: {\n                n: { name: \"maxExecutions\", gltfType: \"number\" },\n            },\n        },\n        outputs: {\n            values: {\n                currentCount: { name: \"executionCount\" },\n            },\n        },\n    },\n    \"flow/multiGate\": {\n        blocks: [FlowGraphBlockNames.MultiGate],\n        configuration: {\n            isRandom: { name: \"isRandom\", gltfType: \"boolean\", inOptions: true, defaultValue: false },\n            isLoop: { name: \"isLoop\", gltfType: \"boolean\", inOptions: true, defaultValue: false },\n        },\n        extraProcessor(gltfBlock, declaration, _mapping, _arrays, serializedObjects) {\n            if (declaration.op !== \"flow/multiGate\" || !gltfBlock.flows || Object.keys(gltfBlock.flows).length === 0) {\n                throw new Error(\"MultiGate should have a single configuration object, the number of output flows\");\n            }\n            const serializedObject = serializedObjects[0];\n            serializedObject.config ||= {};\n            serializedObject.config.outputSignalCount = Object.keys(gltfBlock.flows).length;\n            serializedObject.signalOutputs.forEach((output, index) => {\n                output.name = \"out_\" + index;\n            });\n            return serializedObjects;\n        },\n    },\n    \"flow/waitAll\": {\n        blocks: [FlowGraphBlockNames.WaitAll],\n        configuration: {\n            inputFlows: { name: \"inputSignalCount\", gltfType: \"number\", inOptions: true, defaultValue: 0 },\n        },\n        inputs: {\n            flows: {\n                reset: { name: \"reset\" },\n                \"[segment]\": { name: \"in_$1\" },\n            },\n        },\n        validation(gltfBlock) {\n            // check that the configuration value is an integer\n            if (typeof gltfBlock.configuration?.inputFlows?.value?.[0] !== \"number\") {\n                gltfBlock.configuration = gltfBlock.configuration || {\n                    inputFlows: { value: [0] },\n                };\n                gltfBlock.configuration.inputFlows.value = [0];\n            }\n            return { valid: true };\n        },\n    },\n    \"flow/throttle\": {\n        blocks: [FlowGraphBlockNames.Throttle],\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n    },\n    \"flow/setDelay\": {\n        blocks: [FlowGraphBlockNames.SetDelay],\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n    },\n    \"flow/cancelDelay\": {\n        blocks: [FlowGraphBlockNames.CancelDelay],\n    },\n    \"variable/get\": {\n        blocks: [FlowGraphBlockNames.GetVariable],\n        validation(gltfBlock) {\n            if (!gltfBlock.configuration?.variable?.value) {\n                Logger.Error(\"Variable get block should have a variable configuration\");\n                return { valid: false, error: \"Variable get block should have a variable configuration\" };\n            }\n            return { valid: true };\n        },\n        configuration: {\n            variable: {\n                name: \"variable\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index, parser) {\n                    return parser.getVariableName(index);\n                },\n            },\n        },\n    },\n    \"variable/set\": {\n        blocks: [FlowGraphBlockNames.SetVariable],\n        configuration: {\n            variables: {\n                name: \"variables\",\n                gltfType: \"number\",\n                flowGraphType: \"string\",\n                inOptions: true,\n                isArray: true,\n                dataTransformer(index: number[], parser): string[] {\n                    return index.map((i) => parser.getVariableName(i));\n                },\n            },\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            // variable/get configuration\n            const serializedGetVariable = serializedObjects[0];\n            serializedGetVariable.dataInputs.forEach((input) => {\n                input.name = parser.getVariableName(+input.name);\n            });\n\n            return serializedObjects;\n        },\n    },\n    \"variable/interpolate\": {\n        blocks: [\n            FlowGraphBlockNames.ValueInterpolation,\n            FlowGraphBlockNames.Context,\n            FlowGraphBlockNames.PlayAnimation,\n            FlowGraphBlockNames.BezierCurveEasing,\n            FlowGraphBlockNames.GetVariable,\n        ],\n        configuration: {\n            variable: {\n                name: \"propertyName\",\n                inOptions: true,\n                isVariable: true,\n                dataTransformer(index, parser) {\n                    return parser.getVariableName(index);\n                },\n            },\n            useSlerp: {\n                name: \"animationType\",\n                inOptions: true,\n                defaultValue: false,\n                dataTransformer(value) {\n                    return value === true ? FlowGraphTypes.Quaternion : undefined;\n                },\n            },\n        },\n        inputs: {\n            values: {\n                value: { name: \"value_1\" },\n                duration: { name: \"duration_1\", gltfType: \"number\" },\n                p1: { name: \"controlPoint1\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n                p2: { name: \"controlPoint2\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n            },\n            flows: {\n                in: { name: \"in\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                out: { name: \"out\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                done: { name: \"done\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"userVariables\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"animation\",\n                output: \"animation\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 0,\n                isVariable: true,\n            },\n            {\n                input: \"easingFunction\",\n                output: \"easingFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 3,\n                isVariable: true,\n            },\n            {\n                input: \"value_0\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 4,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            // is useSlerp is used, animationType should be set to be quaternion!\n            const serializedValueInterpolation = serializedObjects[0];\n            const propertyIndex = gltfBlock.configuration?.variable.value?.[0];\n            if (typeof propertyIndex !== \"number\") {\n                Logger.Error(\"Variable index is not defined for variable interpolation block\");\n                throw new Error(\"Variable index is not defined for variable interpolation block\");\n            }\n            const variable = parser.arrays.staticVariables[propertyIndex];\n            // if not set by useSlerp\n            if (typeof serializedValueInterpolation.config?.animationType?.value === \"undefined\") {\n                serializedValueInterpolation.config ||= {};\n                serializedValueInterpolation.config.animationType ||= {};\n                serializedValueInterpolation.config.animationType.value = getAnimationTypeByFlowGraphType(variable.type);\n            }\n\n            // variable/get configuration\n            const serializedGetVariable = serializedObjects[4];\n            serializedGetVariable.config ||= {};\n            serializedGetVariable.config.variable ||= {};\n            serializedGetVariable.config.variable.value = parser.getVariableName(propertyIndex);\n\n            return serializedObjects;\n        },\n    },\n    \"pointer/get\": {\n        blocks: [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customGetFunction\",\n                output: \"getFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"pointer/set\": {\n        blocks: [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                // must be defined due to the array taking over\n                value: { name: \"value\" },\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customSetFunction\",\n                output: \"setFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"pointer/interpolate\": {\n        // interpolate, parse the pointer and play the animation generated. 3 blocks!\n        blocks: [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.BezierCurveEasing],\n        configuration: {\n            pointer: { name: \"jsonPointer\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n        },\n        inputs: {\n            values: {\n                value: { name: \"value_1\" },\n                \"[segment]\": { name: \"$1\", toBlock: FlowGraphBlockNames.JsonPointerParser },\n                duration: { name: \"duration_1\", gltfType: \"number\" /*, inOptions: true */ },\n                p1: { name: \"controlPoint1\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n                p2: { name: \"controlPoint2\", toBlock: FlowGraphBlockNames.BezierCurveEasing },\n            },\n            flows: {\n                in: { name: \"in\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                out: { name: \"out\", toBlock: FlowGraphBlockNames.PlayAnimation },\n                done: { name: \"done\", toBlock: FlowGraphBlockNames.PlayAnimation },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"object\",\n                output: \"object\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"propertyName\",\n                output: \"propertyName\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"customBuildAnimation\",\n                output: \"generateAnimationsFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"animation\",\n                output: \"animation\",\n                inputBlockIndex: 2,\n                outputBlockIndex: 0,\n                isVariable: true,\n            },\n            {\n                input: \"easingFunction\",\n                output: \"easingFunction\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 3,\n                isVariable: true,\n            },\n            {\n                input: \"value_0\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(gltfBlock, _declaration, _mapping, parser, serializedObjects) {\n            serializedObjects.forEach((serializedObject) => {\n                // check if it is the json pointer block\n                if (serializedObject.className === FlowGraphBlockNames.JsonPointerParser) {\n                    serializedObject.config ||= {};\n                    serializedObject.config.outputValue = true;\n                } else if (serializedObject.className === FlowGraphBlockNames.ValueInterpolation) {\n                    serializedObject.config ||= {};\n                    Object.keys(gltfBlock.values || []).forEach((key) => {\n                        const value = gltfBlock.values?.[key];\n                        if (key === \"value\" && value) {\n                            // get the type of the value\n                            const type = value.type;\n                            if (type !== undefined) {\n                                serializedObject.config.animationType = parser.arrays.types[type].flowGraphType;\n                            }\n                        }\n                    });\n                }\n            });\n            return serializedObjects;\n        },\n    },\n    \"animation/start\": {\n        blocks: [FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n                speed: { name: \"speed\", gltfType: \"number\" },\n                startTime: { name: \"from\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n                endTime: { name: \"to\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"animation/stop\": {\n        blocks: [FlowGraphBlockNames.StopAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"animation/stopAt\": {\n        blocks: [FlowGraphBlockNames.StopAnimation, FlowGraphBlockNames.ArrayIndex, \"KHR_interactivity/FlowGraphGLTFDataProvider\"],\n        configuration: {},\n        inputs: {\n            values: {\n                animation: { name: \"index\", gltfType: \"number\", toBlock: FlowGraphBlockNames.ArrayIndex },\n                stopTime: { name: \"stopAtFrame\", gltfType: \"number\", dataTransformer: (time: number[], parser) => [time[0] * parser._animationTargetFps] },\n            },\n        },\n        outputs: {\n            flows: {\n                err: { name: \"error\" },\n            },\n        },\n        interBlockConnectors: [\n            {\n                input: \"animationGroup\",\n                output: \"value\",\n                inputBlockIndex: 0,\n                outputBlockIndex: 1,\n                isVariable: true,\n            },\n            {\n                input: \"array\",\n                output: \"animationGroups\",\n                inputBlockIndex: 1,\n                outputBlockIndex: 2,\n                isVariable: true,\n            },\n        ],\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects, _context, globalGLTF) {\n            // add the glTF to the configuration of the last serialized object\n            const serializedObject = serializedObjects[serializedObjects.length - 1];\n            serializedObject.config ||= {};\n            serializedObject.config.glTF = globalGLTF;\n            return serializedObjects;\n        },\n    },\n    \"math/switch\": {\n        blocks: [FlowGraphBlockNames.DataSwitch],\n        configuration: {\n            cases: { name: \"cases\", isArray: true, inOptions: true, defaultValue: [] },\n        },\n        inputs: {\n            values: {\n                selection: { name: \"case\" },\n            },\n        },\n        validation(gltfBlock) {\n            const cases = gltfBlock.configuration?.cases;\n            if (cases && cases.value) {\n                const onlyIntegers = cases.value.every((caseValue) => {\n                    // case value should be an integer. Since Number.isInteger(1.0) is true, we need to check if toString has only digits.\n                    return typeof caseValue === \"number\" && /^-?\\d+$/.test(caseValue.toString());\n                });\n                if (!onlyIntegers) {\n                    Logger.Warn(\"Switch cases should be integers. Using empty array instead.\");\n                    cases.value = [] as number[];\n                    return { valid: true };\n                }\n                // check for duplicates\n                const uniqueCases = new Set(cases.value);\n                cases.value = Array.from(uniqueCases) as number[];\n            }\n            return { valid: true };\n        },\n        extraProcessor(_gltfBlock, _declaration, _mapping, _arrays, serializedObjects) {\n            const serializedObject = serializedObjects[0];\n            serializedObject.dataInputs.forEach((input) => {\n                if (input.name !== \"default\" && input.name !== \"case\") {\n                    input.name = \"in_\" + input.name;\n                }\n            });\n            serializedObject.config ||= {};\n            serializedObject.config.treatCasesAsIntegers = true;\n            return serializedObjects;\n        },\n    },\n    \"debug/log\": {\n        blocks: [FlowGraphBlockNames.ConsoleLog],\n        configuration: {\n            message: { name: \"messageTemplate\", inOptions: true },\n        },\n    },\n};\n\nfunction getSimpleInputMapping(type: FlowGraphBlockNames, inputs: string[] = [\"a\"], inferType?: boolean): IGLTFToFlowGraphMapping {\n    return {\n        blocks: [type],\n        inputs: {\n            values: inputs.reduce(\n                (acc, input) => {\n                    acc[input] = { name: input };\n                    return acc;\n                },\n                {} as { [key: string]: { name: string } }\n            ),\n        },\n        outputs: {\n            values: {\n                value: { name: \"value\" },\n            },\n        },\n        extraProcessor(gltfBlock, _declaration, _mapping, _parser, serializedObjects) {\n            if (inferType) {\n                // configure it to work the way glTF specifies\n                serializedObjects[0].config ||= {};\n                serializedObjects[0].config.preventIntegerFloatArithmetic = true;\n                // try to infer the type or fallback to Integer\n                // check the gltf block for the inputs, see if they have a type\n                let type = -1;\n                Object.keys(gltfBlock.values || {}).find((value) => {\n                    if (gltfBlock.values?.[value].type !== undefined) {\n                        type = gltfBlock.values[value].type;\n                        return true;\n                    }\n                    return false;\n                });\n                if (type !== -1) {\n                    serializedObjects[0].config.type = _parser.arrays.types[type].flowGraphType;\n                }\n            }\n            return serializedObjects;\n        },\n        validation(gltfBlock) {\n            if (inferType) {\n                // make sure types are the same\n                return ValidateTypes(gltfBlock);\n            }\n            return { valid: true };\n        },\n    };\n}\n\nfunction ValidateTypes(gltfBlock: IKHRInteractivity_Node): { valid: boolean; error?: string } {\n    if (gltfBlock.values) {\n        const types = Object.keys(gltfBlock.values)\n            .map((key) => gltfBlock.values![key].type)\n            .filter((type) => type !== undefined);\n        const allSameType = types.every((type) => type === types[0]);\n        if (!allSameType) {\n            return { valid: false, error: \"All inputs must be of the same type\" };\n        }\n    }\n    return { valid: true };\n}\n\nexport function getAllSupportedNativeNodeTypes(): string[] {\n    return Object.keys(gltfToFlowGraphMapping);\n}\n\n/**\n * \n * These are the nodes from the specs:\n\n### Math Nodes\n1. **Constants**\n   - E (`math/E`) FlowGraphBlockNames.E\n   - Pi (`math/Pi`) FlowGraphBlockNames.PI\n   - Infinity (`math/Inf`) FlowGraphBlockNames.Inf\n   - Not a Number (`math/NaN`) FlowGraphBlockNames.NaN\n2. **Arithmetic Nodes**\n   - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs\n   - Sign (`math/sign`) FlowGraphBlockNames.Sign\n   - Truncate (`math/trunc`) FlowGraphBlockNames.Trunc\n   - Floor (`math/floor`) FlowGraphBlockNames.Floor\n   - Ceil (`math/ceil`) FlowGraphBlockNames.Ceil\n   - Round (`math/round`)  FlowGraphBlockNames.Round\n   - Fraction (`math/fract`) FlowGraphBlockNames.Fract\n   - Negation (`math/neg`) FlowGraphBlockNames.Negation\n   - Addition (`math/add`) FlowGraphBlockNames.Add\n   - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract\n   - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply\n   - Division (`math/div`) FlowGraphBlockNames.Divide\n   - Remainder (`math/rem`) FlowGraphBlockNames.Modulo\n   - Minimum (`math/min`) FlowGraphBlockNames.Min\n   - Maximum (`math/max`) FlowGraphBlockNames.Max\n   - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp\n   - Saturate (`math/saturate`) FlowGraphBlockNames.Saturate\n   - Interpolate (`math/mix`) FlowGraphBlockNames.MathInterpolation\n3. **Comparison Nodes**\n   - Equality (`math/eq`) FlowGraphBlockNames.Equality\n   - Less Than (`math/lt`) FlowGraphBlockNames.LessThan\n   - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual\n   - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan\n   - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual\n4. **Special Nodes**\n   - Is Not a Number (`math/isNaN`) FlowGraphBlockNames.IsNaN\n   - Is Infinity (`math/isInf`) FlowGraphBlockNames.IsInfinity\n   - Select (`math/select`) FlowGraphBlockNames.Conditional\n   - Switch (`math/switch`) FlowGraphBlockNames.DataSwitch\n   - Random (`math/random`) FlowGraphBlockNames.Random\n5. **Angle and Trigonometry Nodes**\n   - Degrees-To-Radians (`math/rad`) FlowGraphBlockNames.DegToRad\n   - Radians-To-Degrees (`math/deg`) FlowGraphBlockNames.RadToDeg\n   - Sine (`math/sin`)  FlowGraphBlockNames.Sin\n   - Cosine (`math/cos`) FlowGraphBlockNames.Cos\n   - Tangent (`math/tan`) FlowGraphBlockNames.Tan\n   - Arcsine (`math/asin`) FlowGraphBlockNames.Asin\n   - Arccosine (`math/acos`) FlowGraphBlockNames.Acos\n   - Arctangent (`math/atan`) FlowGraphBlockNames.Atan\n   - Arctangent 2 (`math/atan2`) FlowGraphBlockNames.Atan2\n6. **Hyperbolic Nodes**\n   - Hyperbolic Sine (`math/sinh`) FlowGraphBlockNames.Sinh\n   - Hyperbolic Cosine (`math/cosh`) FlowGraphBlockNames.Cosh\n   - Hyperbolic Tangent (`math/tanh`) FlowGraphBlockNames.Tanh\n   - Inverse Hyperbolic Sine (`math/asinh`) FlowGraphBlockNames.Asinh\n   - Inverse Hyperbolic Cosine (`math/acosh`) FlowGraphBlockNames.Acosh\n   - Inverse Hyperbolic Tangent (`math/atanh`) FlowGraphBlockNames.Atanh\n7. **Exponential Nodes**\n   - Exponent (`math/exp`) FlowGraphBlockNames.Exponential\n   - Natural Logarithm (`math/log`) FlowGraphBlockNames.Log\n   - Base-2 Logarithm (`math/log2`) FlowGraphBlockNames.Log2\n   - Base-10 Logarithm (`math/log10`) FlowGraphBlockNames.Log10\n   - Square Root (`math/sqrt`) FlowGraphBlockNames.SquareRoot\n   - Cube Root (`math/cbrt`) FlowGraphBlockNames.CubeRoot\n   - Power (`math/pow`) FlowGraphBlockNames.Power\n8. **Vector Nodes**\n   - Length (`math/length`) FlowGraphBlockNames.Length\n   - Normalize (`math/normalize`) FlowGraphBlockNames.Normalize\n   - Dot Product (`math/dot`) FlowGraphBlockNames.Dot\n   - Cross Product (`math/cross`) FlowGraphBlockNames.Cross\n   - Rotate 2D (`math/rotate2D`) FlowGraphBlockNames.Rotate2D\n   - Rotate 3D (`math/rotate3D`) FlowGraphBlockNames.Rotate3D\n   - Transform (`math/transform`) FlowGraphBlockNames.TransformVector\n9. **Matrix Nodes**\n   - Transpose (`math/transpose`) FlowGraphBlockNames.Transpose\n   - Determinant (`math/determinant`) FlowGraphBlockNames.Determinant\n   - Inverse (`math/inverse`) FlowGraphBlockNames.InvertMatrix\n   - Multiplication (`math/matMul`) FlowGraphBlockNames.MatrixMultiplication\n   - Compose (`math/matCompose`) FlowGraphBlockNames.MatrixCompose\n   - Decompose (`math/matDecompose`) FlowGraphBlockNames.MatrixDecompose\n10. **Quaternion Nodes**\n    - Conjugate (`math/quatConjugate`) FlowGraphBlockNames.Conjugate\n    - Multiplication (`math/quatMul`) FlowGraphBlockNames.Multiply\n    - Angle Between Quaternions (`math/quatAngleBetween`) FlowGraphBlockNames.AngleBetween\n    - Quaternion From Axis Angle (`math/quatFromAxisAngle`) FlowGraphBlockNames.QuaternionFromAxisAngle\n    - Quaternion To Axis Angle (`math/quatToAxisAngle`) FlowGraphBlockNames.QuaternionToAxisAngle\n    - Quaternion From Two Directional Vectors (`math/quatFromDirections`) FlowGraphBlockNames.QuaternionFromDirections\n11. **Swizzle Nodes**\n    - Combine (`math/combine2`, `math/combine3`, `math/combine4`, `math/combine2x2`, `math/combine3x3`, `math/combine4x4`)\n        FlowGraphBlockNames.CombineVector2, FlowGraphBlockNames.CombineVector3, FlowGraphBlockNames.CombineVector4\n        FlowGraphBlockNames.CombineMatrix2D, FlowGraphBlockNames.CombineMatrix3D, FlowGraphBlockNames.CombineMatrix\n    - Extract (`math/extract2`, `math/extract3`, `math/extract4`, `math/extract2x2`, `math/extract3x3`, `math/extract4x4`)\n        FlowGraphBlockNames.ExtractVector2, FlowGraphBlockNames.ExtractVector3, FlowGraphBlockNames.ExtractVector4\n        FlowGraphBlockNames.ExtractMatrix2D, FlowGraphBlockNames.ExtractMatrix3D, FlowGraphBlockNames.ExtractMatrix\n12. **Integer Arithmetic Nodes**\n    - Absolute Value (`math/abs`) FlowGraphBlockNames.Abs\n    - Sign (`math/sign`) FlowGraphBlockNames.Sign\n    - Negation (`math/neg`) FlowGraphBlockNames.Negation\n    - Addition (`math/add`) FlowGraphBlockNames.Add\n    - Subtraction (`math/sub`) FlowGraphBlockNames.Subtract\n    - Multiplication (`math/mul`) FlowGraphBlockNames.Multiply\n    - Division (`math/div`) FlowGraphBlockNames.Divide\n    - Remainder (`math/rem`) FlowGraphBlockNames.Modulo\n    - Minimum (`math/min`) FlowGraphBlockNames.Min\n    - Maximum (`math/max`) FlowGraphBlockNames.Max\n    - Clamp (`math/clamp`) FlowGraphBlockNames.Clamp\n13. **Integer Comparison Nodes**\n    - Equality (`math/eq`) FlowGraphBlockNames.Equality\n    - Less Than (`math/lt`) FlowGraphBlockNames.LessThan\n    - Less Than Or Equal To (`math/le`) FlowGraphBlockNames.LessThanOrEqual\n    - Greater Than (`math/gt`) FlowGraphBlockNames.GreaterThan\n    - Greater Than Or Equal To (`math/ge`) FlowGraphBlockNames.GreaterThanOrEqual\n14. **Integer Bitwise Nodes**\n    - Bitwise NOT (`math/not`) FlowGraphBlockNames.BitwiseNot\n    - Bitwise AND (`math/and`) FlowGraphBlockNames.BitwiseAnd\n    - Bitwise OR (`math/or`) FlowGraphBlockNames.BitwiseOr\n    - Bitwise XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor\n    - Right Shift (`math/asr`) FlowGraphBlockNames.BitwiseRightShift\n    - Left Shift (`math/lsl`) FlowGraphBlockNames.BitwiseLeftShift\n    - Count Leading Zeros (`math/clz`) FlowGraphBlockNames.LeadingZeros\n    - Count Trailing Zeros (`math/ctz`) FlowGraphBlockNames.TrailingZeros\n    - Count One Bits (`math/popcnt`) FlowGraphBlockNames.OneBitsCounter\n15. **Boolean Arithmetic Nodes**\n    - Equality (`math/eq`) FlowGraphBlockNames.Equality\n    - Boolean NOT (`math/not`) FlowGraphBlockNames.BitwiseNot\n    - Boolean AND (`math/and`) FlowGraphBlockNames.BitwiseAnd\n    - Boolean OR (`math/or`) FlowGraphBlockNames.BitwiseOr\n    - Boolean XOR (`math/xor`) FlowGraphBlockNames.BitwiseXor\n\n### Type Conversion Nodes\n1. **Boolean Conversion Nodes**\n   - Boolean to Integer (`type/boolToInt`) FlowGraphBlockNames.BooleanToInt\n   - Boolean to Float (`type/boolToFloat`) FlowGraphBlockNames.BooleanToFloat\n2. **Integer Conversion Nodes**\n   - Integer to Boolean (`type/intToBool`) FlowGraphBlockNames.IntToBoolean\n   - Integer to Float (`type/intToFloat`) FlowGraphBlockNames.IntToFloat\n3. **Float Conversion Nodes**\n   - Float to Boolean (`type/floatToBool`) FlowGraphBlockNames.FloatToBoolean\n   - Float to Integer (`type/floatToInt`) FlowGraphBlockNames.FloatToInt\n\n### Control Flow Nodes\n1. **Sync Nodes**\n   - Sequence (`flow/sequence`) FlowGraphBlockNames.Sequence\n   - Branch (`flow/branch`) FlowGraphBlockNames.Branch\n   - Switch (`flow/switch`) FlowGraphBlockNames.Switch\n   - While Loop (`flow/while`) FlowGraphBlockNames.WhileLoop\n   - For Loop (`flow/for`) FlowGraphBlockNames.ForLoop\n   - Do N (`flow/doN`) FlowGraphBlockNames.DoN\n   - Multi Gate (`flow/multiGate`) FlowGraphBlockNames.MultiGate\n   - Wait All (`flow/waitAll`) FlowGraphBlockNames.WaitAll\n   - Throttle (`flow/throttle`) FlowGraphBlockNames.Throttle\n2. **Delay Nodes**\n   - Set Delay (`flow/setDelay`) FlowGraphBlockNames.SetDelay\n   - Cancel Delay (`flow/cancelDelay`) FlowGraphBlockNames.CancelDelay\n\n### State Manipulation Nodes\n1. **Custom Variable Access**\n   - Variable Get (`variable/get`) FlowGraphBlockNames.GetVariable\n   - Variable Set (`variable/set`) FlowGraphBlockNames.SetVariable\n   - Variable Interpolate (`variable/interpolate`)\n2. **Object Model Access** // TODO fully test this!!!\n   - JSON Pointer Template Parsing (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Effective JSON Pointer Generation (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Get (`pointer/get`) [FlowGraphBlockNames.GetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Set (`pointer/set`) [FlowGraphBlockNames.SetProperty, FlowGraphBlockNames.JsonPointerParser]\n   - Pointer Interpolate (`pointer/interpolate`) [FlowGraphBlockNames.ValueInterpolation, FlowGraphBlockNames.JsonPointerParser, FlowGraphBlockNames.PlayAnimation, FlowGraphBlockNames.Easing]\n\n### Animation Control Nodes\n1. **Animation Play** (`animation/start`) FlowGraphBlockNames.PlayAnimation\n2. **Animation Stop** (`animation/stop`) FlowGraphBlockNames.StopAnimation \n3. **Animation Stop At** (`animation/stopAt`) FlowGraphBlockNames.StopAnimation \n\n### Event Nodes\n1. **Lifecycle Event Nodes**\n   - On Start (`event/onStart`) FlowGraphBlockNames.SceneReadyEvent\n   - On Tick (`event/onTick`) FlowGraphBlockNames.SceneTickEvent\n2. **Custom Event Nodes**\n   - Receive (`event/receive`) FlowGraphBlockNames.ReceiveCustomEvent\n   - Send (`event/send`) FlowGraphBlockNames.SendCustomEvent\n\n */\n","import { Vector3, Vector2 } from \"core/Maths/math.vector\";\n\n/**\n * Interface representing a generic flow graph matrix.\n */\nexport interface IFlowGraphMatrix<VectorType> {\n    /**\n     * The matrix elements stored in a row-major order.\n     */\n    m: number[];\n\n    /**\n     * Transforms a vector using this matrix.\n     *\n     * @param v - The vector to transform.\n     * @returns The transformed vector.\n     */\n    transformVector(v: VectorType): VectorType;\n\n    /**\n     * Transforms a vector using this matrix and stores the result in a reference vector.\n     *\n     * @param v - The vector to transform.\n     * @param result - The vector to store the result.\n     * @returns The transformed vector.\n     */\n    transformVectorToRef(v: VectorType, result: VectorType): VectorType;\n\n    /**\n     * Returns the matrix elements as an array.\n     *\n     * @returns The matrix elements as an array.\n     */\n    asArray(): number[];\n\n    /**\n     * Copies the matrix elements to an array.\n     *\n     * @param emptyArray - The array to copy the elements to.\n     * @returns The array with the matrix elements.\n     */\n    toArray(emptyArray: number[]): number[];\n\n    /**\n     * Sets the matrix elements from an array.\n     *\n     * @param array - The array containing the matrix elements.\n     * @returns The updated matrix.\n     */\n    fromArray(array: number[]): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Multiplies this matrix with another matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to multiply with.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    multiplyToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Multiplies this matrix with another matrix.\n     * To staz conform with the Matrix class, this does B * A\n     *\n     * @param other - The matrix to multiply with.\n     * @returns The result matrix.\n     */\n    multiply(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Divides this matrix by another matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to divide by.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    divideToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Divides this matrix by another matrix.\n     *\n     * @param other - The matrix to divide by.\n     * @returns The result matrix.\n     */\n    divide(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Adds another matrix to this matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to add.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    addToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Adds another matrix to this matrix.\n     *\n     * @param other - The matrix to add.\n     * @returns The result matrix.\n     */\n    add(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Subtracts another matrix from this matrix and stores the result in a reference matrix.\n     *\n     * @param other - The matrix to subtract.\n     * @param result - The matrix to store the result.\n     * @returns The result matrix.\n     */\n    subtractToRef(other: IFlowGraphMatrix<VectorType>, result: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Subtracts another matrix from this matrix.\n     *\n     * @param other - The matrix to subtract.\n     * @returns The result matrix.\n     */\n    subtract(other: IFlowGraphMatrix<VectorType>): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Transposes this matrix.\n     *\n     * @returns The transposed matrix.\n     */\n    transpose(): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Computes the determinant of this matrix.\n     *\n     * @returns The determinant of the matrix.\n     */\n    determinant(): number;\n\n    /**\n     * Computes the inverse of this matrix.\n     *\n     * @returns The inverse of the matrix.\n     * @throws Error if the matrix is not invertible.\n     */\n    inverse(): IFlowGraphMatrix<VectorType>;\n\n    /**\n     * Gets the class name of this matrix.\n     *\n     * @returns The class name.\n     */\n    getClassName(): string;\n\n    /**\n     * Checks if this matrix is equal to another matrix within an optional epsilon.\n     *\n     * @param other - The matrix to compare with.\n     * @param epsilon - The optional epsilon for comparison.\n     * @returns True if the matrices are equal, false otherwise.\n     */\n    equals(other: IFlowGraphMatrix<VectorType>, epsilon?: number): boolean;\n}\n\n// Note - the matrix classes are basically column-major, and work similarly to Babylon.js' Matrix class.\n\n/**\n * A 2x2 matrix.\n */\nexport class FlowGraphMatrix2D implements IFlowGraphMatrix<Vector2> {\n    /**\n     * @internal\n     */\n    public _m: number[];\n\n    constructor(m: number[] = [1, 0, 0, 1]) {\n        this._m = m;\n    }\n\n    public get m(): number[] {\n        return this._m;\n    }\n\n    public transformVector(v: Vector2): Vector2 {\n        return this.transformVectorToRef(v, new Vector2());\n    }\n\n    public transformVectorToRef(v: Vector2, result: Vector2): Vector2 {\n        result.x = v.x * this._m[0] + v.y * this._m[1];\n        result.y = v.x * this._m[2] + v.y * this._m[3];\n        return result;\n    }\n\n    public asArray(): number[] {\n        return this.toArray();\n    }\n\n    public toArray(emptyArray: number[] = []): number[] {\n        for (let i = 0; i < 4; i++) {\n            emptyArray[i] = this._m[i];\n        }\n        return emptyArray;\n    }\n\n    public fromArray(array: number[]): FlowGraphMatrix2D {\n        for (let i = 0; i < 4; i++) {\n            this._m[i] = array[i];\n        }\n        return this;\n    }\n\n    public multiplyToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const otherMatrix = other._m;\n        const thisMatrix = this._m;\n        const r = result._m;\n        // other * this\n        r[0] = otherMatrix[0] * thisMatrix[0] + otherMatrix[1] * thisMatrix[2];\n        r[1] = otherMatrix[0] * thisMatrix[1] + otherMatrix[1] * thisMatrix[3];\n        r[2] = otherMatrix[2] * thisMatrix[0] + otherMatrix[3] * thisMatrix[2];\n        r[3] = otherMatrix[2] * thisMatrix[1] + otherMatrix[3] * thisMatrix[3];\n\n        return result;\n    }\n\n    public multiply(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.multiplyToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public divideToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const m = this._m;\n        const o = other._m;\n        const r = result._m;\n\n        r[0] = m[0] / o[0];\n        r[1] = m[1] / o[1];\n        r[2] = m[2] / o[2];\n        r[3] = m[3] / o[3];\n\n        return result;\n    }\n\n    public divide(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.divideToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public addToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] + o[0];\n        r[1] = m[1] + o[1];\n        r[2] = m[2] + o[2];\n        r[3] = m[3] + o[3];\n\n        return result;\n    }\n\n    public add(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.addToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public subtractToRef(other: FlowGraphMatrix2D, result: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] - o[0];\n        r[1] = m[1] - o[1];\n        r[2] = m[2] - o[2];\n        r[3] = m[3] - o[3];\n\n        return result;\n    }\n\n    public subtract(other: FlowGraphMatrix2D): FlowGraphMatrix2D {\n        return this.subtractToRef(other, new FlowGraphMatrix2D());\n    }\n\n    public transpose(): FlowGraphMatrix2D {\n        const m = this._m;\n        return new FlowGraphMatrix2D([m[0], m[2], m[1], m[3]]);\n    }\n\n    public determinant(): number {\n        const m = this._m;\n        return m[0] * m[3] - m[1] * m[2];\n    }\n\n    public inverse(): FlowGraphMatrix2D {\n        const det = this.determinant();\n        if (det === 0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n        const m = this._m;\n        const invDet = 1 / det;\n        return new FlowGraphMatrix2D([m[3] * invDet, -m[1] * invDet, -m[2] * invDet, m[0] * invDet]);\n    }\n\n    public equals(other: IFlowGraphMatrix<Vector2>, epsilon: number = 0): boolean {\n        const m = this._m;\n        const o = other.m;\n        if (epsilon === 0) {\n            return m[0] === o[0] && m[1] === o[1] && m[2] === o[2] && m[3] === o[3];\n        }\n        return Math.abs(m[0] - o[0]) < epsilon && Math.abs(m[1] - o[1]) < epsilon && Math.abs(m[2] - o[2]) < epsilon && Math.abs(m[3] - o[3]) < epsilon;\n    }\n\n    public getClassName(): string {\n        return \"FlowGraphMatrix2D\";\n    }\n\n    public toString(): string {\n        return `FlowGraphMatrix2D(${this._m.join(\", \")})`;\n    }\n}\n\n/**\n * A 3x3 matrix.\n */\nexport class FlowGraphMatrix3D implements IFlowGraphMatrix<Vector3> {\n    /**\n     * @internal\n     */\n    public _m: number[];\n\n    constructor(array: number[] = [1, 0, 0, 0, 1, 0, 0, 0, 1]) {\n        this._m = array;\n    }\n\n    public get m(): number[] {\n        return this._m;\n    }\n\n    public transformVector(v: Vector3): Vector3 {\n        return this.transformVectorToRef(v, new Vector3());\n    }\n\n    public transformVectorToRef(v: Vector3, result: Vector3): Vector3 {\n        const m = this._m;\n        result.x = v.x * m[0] + v.y * m[1] + v.z * m[2];\n        result.y = v.x * m[3] + v.y * m[4] + v.z * m[5];\n        result.z = v.x * m[6] + v.y * m[7] + v.z * m[8];\n        return result;\n    }\n\n    public multiplyToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const otherMatrix = other._m;\n        const thisMatrix = this._m;\n        const r = result.m;\n\n        r[0] = otherMatrix[0] * thisMatrix[0] + otherMatrix[1] * thisMatrix[3] + otherMatrix[2] * thisMatrix[6];\n        r[1] = otherMatrix[0] * thisMatrix[1] + otherMatrix[1] * thisMatrix[4] + otherMatrix[2] * thisMatrix[7];\n        r[2] = otherMatrix[0] * thisMatrix[2] + otherMatrix[1] * thisMatrix[5] + otherMatrix[2] * thisMatrix[8];\n\n        r[3] = otherMatrix[3] * thisMatrix[0] + otherMatrix[4] * thisMatrix[3] + otherMatrix[5] * thisMatrix[6];\n        r[4] = otherMatrix[3] * thisMatrix[1] + otherMatrix[4] * thisMatrix[4] + otherMatrix[5] * thisMatrix[7];\n        r[5] = otherMatrix[3] * thisMatrix[2] + otherMatrix[4] * thisMatrix[5] + otherMatrix[5] * thisMatrix[8];\n\n        r[6] = otherMatrix[6] * thisMatrix[0] + otherMatrix[7] * thisMatrix[3] + otherMatrix[8] * thisMatrix[6];\n        r[7] = otherMatrix[6] * thisMatrix[1] + otherMatrix[7] * thisMatrix[4] + otherMatrix[8] * thisMatrix[7];\n        r[8] = otherMatrix[6] * thisMatrix[2] + otherMatrix[7] * thisMatrix[5] + otherMatrix[8] * thisMatrix[8];\n\n        return result;\n    }\n\n    public multiply(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.multiplyToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public divideToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] / o[0];\n        r[1] = m[1] / o[1];\n        r[2] = m[2] / o[2];\n        r[3] = m[3] / o[3];\n        r[4] = m[4] / o[4];\n        r[5] = m[5] / o[5];\n        r[6] = m[6] / o[6];\n        r[7] = m[7] / o[7];\n        r[8] = m[8] / o[8];\n\n        return result;\n    }\n\n    public divide(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.divideToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public addToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] + o[0];\n        r[1] = m[1] + o[1];\n        r[2] = m[2] + o[2];\n        r[3] = m[3] + o[3];\n        r[4] = m[4] + o[4];\n        r[5] = m[5] + o[5];\n        r[6] = m[6] + o[6];\n        r[7] = m[7] + o[7];\n        r[8] = m[8] + o[8];\n\n        return result;\n    }\n\n    public add(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.addToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public subtractToRef(other: FlowGraphMatrix3D, result: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        const m = this._m;\n        const o = other.m;\n        const r = result.m;\n\n        r[0] = m[0] - o[0];\n        r[1] = m[1] - o[1];\n        r[2] = m[2] - o[2];\n        r[3] = m[3] - o[3];\n        r[4] = m[4] - o[4];\n        r[5] = m[5] - o[5];\n        r[6] = m[6] - o[6];\n        r[7] = m[7] - o[7];\n        r[8] = m[8] - o[8];\n\n        return result;\n    }\n\n    public subtract(other: FlowGraphMatrix3D): FlowGraphMatrix3D {\n        return this.subtractToRef(other, new FlowGraphMatrix3D());\n    }\n\n    public toArray(emptyArray: number[] = []): number[] {\n        for (let i = 0; i < 9; i++) {\n            emptyArray[i] = this._m[i];\n        }\n        return emptyArray;\n    }\n\n    public asArray(): number[] {\n        return this.toArray();\n    }\n\n    public fromArray(array: number[]): FlowGraphMatrix3D {\n        for (let i = 0; i < 9; i++) {\n            this._m[i] = array[i];\n        }\n        return this;\n    }\n\n    public transpose(): FlowGraphMatrix3D {\n        const m = this._m;\n        return new FlowGraphMatrix3D([m[0], m[3], m[6], m[1], m[4], m[7], m[2], m[5], m[8]]);\n    }\n\n    public determinant(): number {\n        const m = this._m;\n        return m[0] * (m[4] * m[8] - m[5] * m[7]) - m[1] * (m[3] * m[8] - m[5] * m[6]) + m[2] * (m[3] * m[7] - m[4] * m[6]);\n    }\n\n    public inverse(): FlowGraphMatrix3D {\n        const det = this.determinant();\n        if (det === 0) {\n            throw new Error(\"Matrix is not invertible\");\n        }\n        const m = this._m;\n        const invDet = 1 / det;\n        return new FlowGraphMatrix3D([\n            (m[4] * m[8] - m[5] * m[7]) * invDet,\n            (m[2] * m[7] - m[1] * m[8]) * invDet,\n            (m[1] * m[5] - m[2] * m[4]) * invDet,\n            (m[5] * m[6] - m[3] * m[8]) * invDet,\n            (m[0] * m[8] - m[2] * m[6]) * invDet,\n            (m[2] * m[3] - m[0] * m[5]) * invDet,\n            (m[3] * m[7] - m[4] * m[6]) * invDet,\n            (m[1] * m[6] - m[0] * m[7]) * invDet,\n            (m[0] * m[4] - m[1] * m[3]) * invDet,\n        ]);\n    }\n\n    public equals(other: IFlowGraphMatrix<Vector3>, epsilon: number = 0): boolean {\n        const m = this._m;\n        const o = other.m;\n        // performance shortcut\n        if (epsilon === 0) {\n            return m[0] === o[0] && m[1] === o[1] && m[2] === o[2] && m[3] === o[3] && m[4] === o[4] && m[5] === o[5] && m[6] === o[6] && m[7] === o[7] && m[8] === o[8];\n        }\n        return (\n            Math.abs(m[0] - o[0]) < epsilon &&\n            Math.abs(m[1] - o[1]) < epsilon &&\n            Math.abs(m[2] - o[2]) < epsilon &&\n            Math.abs(m[3] - o[3]) < epsilon &&\n            Math.abs(m[4] - o[4]) < epsilon &&\n            Math.abs(m[5] - o[5]) < epsilon &&\n            Math.abs(m[6] - o[6]) < epsilon &&\n            Math.abs(m[7] - o[7]) < epsilon &&\n            Math.abs(m[8] - o[8]) < epsilon\n        );\n    }\n\n    public getClassName(): string {\n        return \"FlowGraphMatrix3D\";\n    }\n\n    public toString(): string {\n        return `FlowGraphMatrix3D(${this._m.join(\", \")})`;\n    }\n}\n","import { RegisterClass } from \"../../Misc/typeStore\";\r\n\r\n/**\r\n * Class that represents an integer value.\r\n */\r\nexport class FlowGraphInteger {\r\n    /**\r\n     * The value of the integer. Its type\r\n     * is a javascript number. Shouldn't be\r\n     * directly modified - it is populated by\r\n     * the constructor.\r\n     */\r\n    readonly value: number;\r\n\r\n    constructor(value: number) {\r\n        this.value = this._toInt(value);\r\n    }\r\n\r\n    /**\r\n     * Converts a float to an integer.\r\n     * @param n the float to convert\r\n     * @returns the result of n | 0 - converting it to a int\r\n     */\r\n    private _toInt(n: number): number {\r\n        return n | 0;\r\n    }\r\n\r\n    /**\r\n     * Adds two integers together.\r\n     * @param other the other integer to add\r\n     * @returns a FlowGraphInteger with the result of the addition\r\n     */\r\n    public add(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(this.value + other.value);\r\n    }\r\n\r\n    /**\r\n     * Subtracts two integers.\r\n     * @param other the other integer to subtract\r\n     * @returns a FlowGraphInteger with the result of the subtraction\r\n     */\r\n    public subtract(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(this.value - other.value);\r\n    }\r\n\r\n    /**\r\n     * Multiplies two integers.\r\n     * @param other the other integer to multiply\r\n     * @returns a FlowGraphInteger with the result of the multiplication\r\n     */\r\n    public multiply(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(Math.imul(this.value, other.value));\r\n    }\r\n\r\n    /**\r\n     * Divides two integers.\r\n     * @param other the other integer to divide\r\n     * @returns a FlowGraphInteger with the result of the division\r\n     */\r\n    public divide(other: FlowGraphInteger): FlowGraphInteger {\r\n        return new FlowGraphInteger(this.value / other.value);\r\n    }\r\n\r\n    /**\r\n     * The class name of this type.\r\n     * @returns\r\n     */\r\n    public getClassName() {\r\n        return FlowGraphInteger.ClassName;\r\n    }\r\n\r\n    /**\r\n     * Compares two integers for equality.\r\n     * @param other the other integer to compare\r\n     * @returns\r\n     */\r\n    public equals(other: FlowGraphInteger): boolean {\r\n        return this.value === other.value;\r\n    }\r\n\r\n    public static ClassName = \"FlowGraphInteger\";\r\n\r\n    /**\r\n     * Parses a FlowGraphInteger from a serialization object.\r\n     * @param value te number to parse\r\n     * @returns\r\n     */\r\n    public static FromValue(value: number): FlowGraphInteger {\r\n        return new FlowGraphInteger(value);\r\n    }\r\n\r\n    public toString(): string {\r\n        return this.value.toString();\r\n    }\r\n}\r\nRegisterClass(\"FlowGraphInteger\", FlowGraphInteger);\r\n","import { Vector2, Vector3, Vector4, Matrix, Quaternion } from \"../Maths/math.vector\";\r\nimport { Color3, Color4 } from \"../Maths/math.color\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"./CustomTypes/flowGraphMatrix\";\r\n\r\n/**\r\n * The types supported by the flow graph.\r\n */\r\nexport const enum FlowGraphTypes {\r\n    Any = \"any\",\r\n    String = \"string\",\r\n    Number = \"number\",\r\n    Boolean = \"boolean\",\r\n    Object = \"object\",\r\n    Integer = \"FlowGraphInteger\",\r\n    Vector2 = \"Vector2\",\r\n    Vector3 = \"Vector3\",\r\n    Vector4 = \"Vector4\",\r\n    Quaternion = \"Quaternion\",\r\n    Matrix = \"Matrix\",\r\n    Matrix2D = \"Matrix2D\",\r\n    Matrix3D = \"Matrix3D\",\r\n    Color3 = \"Color3\",\r\n    Color4 = \"Color4\",\r\n}\r\n\r\n/**\r\n * A rich type represents extra information about a type,\r\n * such as its name and a default value constructor.\r\n */\r\nexport class RichType<T> {\r\n    /**\r\n     * A function that can be used to transform a value of any type into a value of this rich type.\r\n     * This can be used, for example, between vector4 and quaternion.\r\n     */\r\n    public typeTransformer: (value: any) => T;\r\n\r\n    constructor(\r\n        /**\r\n         * The name given to the type.\r\n         */\r\n        public typeName: string,\r\n        /**\r\n         * The default value of the type.\r\n         */\r\n        public defaultValue: T,\r\n\r\n        /**\r\n         * [-1] The ANIMATIONTYPE of the type, if available\r\n         */\r\n        public animationType: number = -1\r\n    ) {}\r\n\r\n    /**\r\n     * Serializes this rich type into a serialization object.\r\n     * @param serializationObject the object to serialize to\r\n     */\r\n    serialize(serializationObject: any) {\r\n        serializationObject.typeName = this.typeName;\r\n        serializationObject.defaultValue = this.defaultValue;\r\n    }\r\n}\r\n\r\nexport const RichTypeAny: RichType<any> = new RichType(FlowGraphTypes.Any, undefined);\r\n\r\nexport const RichTypeString: RichType<string> = new RichType(FlowGraphTypes.String, \"\");\r\n\r\nexport const RichTypeNumber: RichType<number> = new RichType(FlowGraphTypes.Number, 0, Constants.ANIMATIONTYPE_FLOAT);\r\n\r\nexport const RichTypeBoolean: RichType<boolean> = new RichType(FlowGraphTypes.Boolean, false);\r\n\r\nexport const RichTypeVector2: RichType<Vector2> = new RichType(FlowGraphTypes.Vector2, Vector2.Zero(), Constants.ANIMATIONTYPE_VECTOR2);\r\n\r\nexport const RichTypeVector3: RichType<Vector3> = new RichType(FlowGraphTypes.Vector3, Vector3.Zero(), Constants.ANIMATIONTYPE_VECTOR3);\r\n\r\nexport const RichTypeVector4: RichType<Vector4> = new RichType(FlowGraphTypes.Vector4, Vector4.Zero());\r\n\r\nexport const RichTypeMatrix: RichType<Matrix> = new RichType(FlowGraphTypes.Matrix, Matrix.Identity(), Constants.ANIMATIONTYPE_MATRIX);\r\n\r\nexport const RichTypeMatrix2D: RichType<FlowGraphMatrix2D> = new RichType(FlowGraphTypes.Matrix2D, new FlowGraphMatrix2D());\r\n\r\nexport const RichTypeMatrix3D: RichType<FlowGraphMatrix3D> = new RichType(FlowGraphTypes.Matrix3D, new FlowGraphMatrix3D());\r\n\r\nexport const RichTypeColor3: RichType<Color3> = new RichType(FlowGraphTypes.Color3, Color3.Black(), Constants.ANIMATIONTYPE_COLOR3);\r\n\r\nexport const RichTypeColor4: RichType<Color4> = new RichType(FlowGraphTypes.Color4, new Color4(0, 0, 0, 0), Constants.ANIMATIONTYPE_COLOR4);\r\n\r\nexport const RichTypeQuaternion: RichType<Quaternion> = new RichType(FlowGraphTypes.Quaternion, Quaternion.Identity(), Constants.ANIMATIONTYPE_QUATERNION);\r\nRichTypeQuaternion.typeTransformer = (value: any) => {\r\n    if (value.getClassName) {\r\n        if (value.getClassName() === FlowGraphTypes.Vector4) {\r\n            return Quaternion.FromArray(value.asArray());\r\n        } else if (value.getClassName() === FlowGraphTypes.Vector3) {\r\n            return Quaternion.FromEulerVector(value);\r\n        } else if (value.getClassName() === FlowGraphTypes.Matrix) {\r\n            return Quaternion.FromRotationMatrix(value);\r\n        }\r\n    }\r\n    return value;\r\n};\r\nexport const RichTypeFlowGraphInteger: RichType<FlowGraphInteger> = new RichType(FlowGraphTypes.Integer, new FlowGraphInteger(0), Constants.ANIMATIONTYPE_FLOAT);\r\n\r\n/**\r\n * Given a value, try to deduce its rich type.\r\n * @param value the value to deduce the rich type from\r\n * @returns the value's rich type, or RichTypeAny if the type could not be deduced.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getRichTypeFromValue<T>(value: T): RichType<T> {\r\n    const anyValue = value as any;\r\n    switch (typeof value) {\r\n        case FlowGraphTypes.String:\r\n            return RichTypeString as RichType<T>;\r\n        case FlowGraphTypes.Number:\r\n            return RichTypeNumber as RichType<T>;\r\n        case FlowGraphTypes.Boolean:\r\n            return RichTypeBoolean as RichType<T>;\r\n        case FlowGraphTypes.Object:\r\n            if (anyValue.getClassName) {\r\n                switch (anyValue.getClassName() as string) {\r\n                    case FlowGraphTypes.Vector2:\r\n                        return RichTypeVector2 as RichType<T>;\r\n                    case FlowGraphTypes.Vector3:\r\n                        return RichTypeVector3 as RichType<T>;\r\n                    case FlowGraphTypes.Vector4:\r\n                        return RichTypeVector4 as RichType<T>;\r\n                    case FlowGraphTypes.Matrix:\r\n                        return RichTypeMatrix as RichType<T>;\r\n                    case FlowGraphTypes.Color3:\r\n                        return RichTypeColor3 as RichType<T>;\r\n                    case FlowGraphTypes.Color4:\r\n                        return RichTypeColor4 as RichType<T>;\r\n                    case FlowGraphTypes.Quaternion:\r\n                        return RichTypeQuaternion as RichType<T>;\r\n                    case FlowGraphTypes.Integer:\r\n                        return RichTypeFlowGraphInteger as RichType<T>;\r\n                    case FlowGraphTypes.Matrix2D:\r\n                        return RichTypeMatrix2D as RichType<T>;\r\n                    case FlowGraphTypes.Matrix3D:\r\n                        return RichTypeMatrix3D as RichType<T>;\r\n                }\r\n            }\r\n            return RichTypeAny as RichType<T>;\r\n        default:\r\n            return RichTypeAny as RichType<T>;\r\n    }\r\n}\r\n\r\n/**\r\n * Given a flow graph type, return the rich type that corresponds to it.\r\n * @param flowGraphType the flow graph type\r\n * @returns the rich type that corresponds to the flow graph type\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getRichTypeByFlowGraphType(flowGraphType?: string): RichType<any> {\r\n    switch (flowGraphType) {\r\n        case FlowGraphTypes.String:\r\n            return RichTypeString;\r\n        case FlowGraphTypes.Number:\r\n            return RichTypeNumber;\r\n        case FlowGraphTypes.Boolean:\r\n            return RichTypeBoolean;\r\n        case FlowGraphTypes.Vector2:\r\n            return RichTypeVector2;\r\n        case FlowGraphTypes.Vector3:\r\n            return RichTypeVector3;\r\n        case FlowGraphTypes.Vector4:\r\n            return RichTypeVector4;\r\n        case FlowGraphTypes.Matrix:\r\n            return RichTypeMatrix;\r\n        case FlowGraphTypes.Color3:\r\n            return RichTypeColor3;\r\n        case FlowGraphTypes.Color4:\r\n            return RichTypeColor4;\r\n        case FlowGraphTypes.Quaternion:\r\n            return RichTypeQuaternion;\r\n        case FlowGraphTypes.Integer:\r\n            return RichTypeFlowGraphInteger;\r\n        case FlowGraphTypes.Matrix2D:\r\n            return RichTypeMatrix2D;\r\n        case FlowGraphTypes.Matrix3D:\r\n            return RichTypeMatrix3D;\r\n        default:\r\n            return RichTypeAny;\r\n    }\r\n}\r\n\r\n/**\r\n * get the animation type for a given flow graph type\r\n * @param flowGraphType the flow graph type\r\n * @returns the animation type for this flow graph type\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getAnimationTypeByFlowGraphType(flowGraphType: FlowGraphTypes): number {\r\n    switch (flowGraphType) {\r\n        case FlowGraphTypes.Number:\r\n            return Constants.ANIMATIONTYPE_FLOAT;\r\n        case FlowGraphTypes.Vector2:\r\n            return Constants.ANIMATIONTYPE_VECTOR2;\r\n        case FlowGraphTypes.Vector3:\r\n            return Constants.ANIMATIONTYPE_VECTOR3;\r\n        case FlowGraphTypes.Matrix:\r\n            return Constants.ANIMATIONTYPE_MATRIX;\r\n        case FlowGraphTypes.Color3:\r\n            return Constants.ANIMATIONTYPE_COLOR3;\r\n        case FlowGraphTypes.Color4:\r\n            return Constants.ANIMATIONTYPE_COLOR4;\r\n        case FlowGraphTypes.Quaternion:\r\n            return Constants.ANIMATIONTYPE_QUATERNION;\r\n        default:\r\n            return Constants.ANIMATIONTYPE_FLOAT;\r\n    }\r\n}\r\n\r\n/**\r\n * Given an animation type, return the rich type that corresponds to it.\r\n * @param animationType the animation type\r\n * @returns the rich type that corresponds to the animation type\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getRichTypeByAnimationType(animationType: number): RichType<any> {\r\n    switch (animationType) {\r\n        case Constants.ANIMATIONTYPE_FLOAT:\r\n            return RichTypeNumber;\r\n        case Constants.ANIMATIONTYPE_VECTOR2:\r\n            return RichTypeVector2;\r\n        case Constants.ANIMATIONTYPE_VECTOR3:\r\n            return RichTypeVector3;\r\n        case Constants.ANIMATIONTYPE_MATRIX:\r\n            return RichTypeMatrix;\r\n        case Constants.ANIMATIONTYPE_COLOR3:\r\n            return RichTypeColor3;\r\n        case Constants.ANIMATIONTYPE_COLOR4:\r\n            return RichTypeColor4;\r\n        case Constants.ANIMATIONTYPE_QUATERNION:\r\n            return RichTypeQuaternion;\r\n        default:\r\n            return RichTypeAny;\r\n    }\r\n}\r\n"],"names":["getMappingForFullOperationName","fullOperationName","op","extension","split","getMappingForDeclaration","declaration","returnNoOpIfNotAvailable","mapping","gltfExtensionsToFlowGraphMapping","gltfToFlowGraphMapping","Warn","inputs","outputs","flows","inputValueSockets","values","key","name","outputValueSockets","Object","keys","forEach","blocks","addNewInteractivityFlowGraphMapping","BABYLON","message","out","timeSinceLastTick","gltfType","extraProcessor","gltfBlock","_mapping","parser","serializedObjects","configuration","length","Error","eventConfiguration","eventId","value","event","arrays","events","serializedObject","config","eventData","validation","interactivityGraph","valid","error","getSimpleInputMapping","a","roundHalfAwayFromZero","_gltfBlock","_declaration","_parser","useMatrixPerComponent","preventIntegerFloatArithmetic","type","find","undefined","types","flowGraphType","ValidateTypes","condition","b","angle","rotation","c","d","translation","scale","context","dataInputs","input","_connectionValues","uniqueId","axis","inputIsColumnMajor","e","f","g","h","i","j","k","l","m","n","o","p","socketIn","valueType","socketInA","socketInB","_arrays","outputSignalCount","signalOutputs","output","index","true","false","cases","isArray","inOptions","defaultValue","selection","default","every","caseValue","test","toString","uniqueCases","Set","Array","from","loopBody","initialIndex","startIndex","endIndex","incrementIndexWhenLoopDone","currentCount","isRandom","isLoop","inputFlows","reset","err","variable","isVariable","dataTransformer","getVariableName","variables","map","useSlerp","duration","p1","toBlock","p2","in","done","interBlockConnectors","inputBlockIndex","outputBlockIndex","serializedValueInterpolation","propertyIndex","staticVariables","animationType","serializedGetVariable","pointer","className","outputValue","animation","speed","startTime","time","_animationTargetFps","endTime","_context","globalGLTF","glTF","stopTime","treatCasesAsIntegers","inferType","reduce","acc","filter","FlowGraphMatrix2D","constructor","this","_m","transformVector","v","transformVectorToRef","result","x","y","asArray","toArray","emptyArray","fromArray","array","multiplyToRef","other","otherMatrix","thisMatrix","r","multiply","divideToRef","divide","addToRef","add","subtractToRef","subtract","transpose","determinant","inverse","det","invDet","equals","epsilon","Math","abs","getClassName","join","FlowGraphMatrix3D","z","FlowGraphInteger","_toInt","imul","ClassName","FromValue","FlowGraphTypes","RichType","typeName","serialize","serializationObject","RichTypeAny","RichTypeString","RichTypeNumber","ANIMATIONTYPE_FLOAT","RichTypeBoolean","RichTypeVector2","Zero","ANIMATIONTYPE_VECTOR2","RichTypeVector3","ANIMATIONTYPE_VECTOR3","RichTypeVector4","RichTypeMatrix","Identity","ANIMATIONTYPE_MATRIX","RichTypeMatrix2D","RichTypeMatrix3D","RichTypeColor3","Black","ANIMATIONTYPE_COLOR3","RichTypeColor4","ANIMATIONTYPE_COLOR4","RichTypeQuaternion","ANIMATIONTYPE_QUATERNION","typeTransformer","FromArray","FromEulerVector","FromRotationMatrix","RichTypeFlowGraphInteger","getRichTypeFromValue","anyValue","getRichTypeByFlowGraphType","getAnimationTypeByFlowGraphType","getRichTypeByAnimationType"],"ignoreList":[],"sourceRoot":""}