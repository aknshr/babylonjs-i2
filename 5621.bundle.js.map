{"version":3,"file":"5621.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Execution/Animation/flowGraphPlayAnimationBlock.ts?"],"sourcesContent":["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\r\nimport { RichTypeAny, RichTypeNumber, RichTypeBoolean } from \"../../../flowGraphRichTypes\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n\r\n/**\r\n * @experimental\r\n * A block that plays an animation on an animatable object.\r\n */\r\nexport class FlowGraphPlayAnimationBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * Input connection: The speed of the animation.\r\n     */\r\n    public readonly speed: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Should the animation loop?\r\n     * Not in glTF specs, but useful for the engine.\r\n     */\r\n    public readonly loop: FlowGraphDataConnection<boolean>;\r\n    /**\r\n     * Input connection: The starting frame of the animation.\r\n     */\r\n    public readonly from: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: The ending frame of the animation.\r\n     */\r\n    public readonly to: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The current frame of the animation.\r\n     */\r\n    public readonly currentFrame: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The current time of the animation.\r\n     */\r\n    public readonly currentTime: FlowGraphDataConnection<number>;\r\n\r\n    /**\r\n     * Output connection: The animatable that is currently running.\r\n     */\r\n    public readonly currentAnimationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input: Will be initialized if no animation group was provided in the configuration.\r\n     */\r\n    public readonly animationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input: If provided this animation will be used. Priority will be given to the animation group input.\r\n     */\r\n    public readonly animation: FlowGraphDataConnection<Animation | Animation[]>;\r\n\r\n    /**\r\n     * Input connection: The target object that will be animated. If animation group is provided this input will be ignored.\r\n     */\r\n    public readonly object: FlowGraphDataConnection<any>;\r\n\r\n    public constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        super(config, [\"animationLoop\", \"animationEnd\", \"animationGroupLoop\"]);\r\n\r\n        this.speed = this.registerDataInput(\"speed\", RichTypeNumber);\r\n        this.loop = this.registerDataInput(\"loop\", RichTypeBoolean);\r\n        this.from = this.registerDataInput(\"from\", RichTypeNumber, 0);\r\n        this.to = this.registerDataInput(\"to\", RichTypeNumber);\r\n\r\n        this.currentFrame = this.registerDataOutput(\"currentFrame\", RichTypeNumber);\r\n        this.currentTime = this.registerDataOutput(\"currentTime\", RichTypeNumber);\r\n\r\n        this.currentAnimationGroup = this.registerDataOutput(\"currentAnimationGroup\", RichTypeAny);\r\n        this.animationGroup = this.registerDataInput(\"animationGroup\", RichTypeAny, config?.animationGroup);\r\n        this.animation = this.registerDataInput(\"animation\", RichTypeAny);\r\n        this.object = this.registerDataInput(\"object\", RichTypeAny);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param context\r\n     */\r\n    public override _preparePendingTasks(context: FlowGraphContext): void {\r\n        const ag = this.animationGroup.getValue(context);\r\n        const animation = this.animation.getValue(context);\r\n        if (!ag && !animation) {\r\n            return this._reportError(context, \"No animation or animation group provided\");\r\n        } else {\r\n            // if an animation group was already created, dispose it and create a new one\r\n            const currentAnimationGroup = this.currentAnimationGroup.getValue(context);\r\n            if (currentAnimationGroup && currentAnimationGroup !== ag) {\r\n                currentAnimationGroup.dispose();\r\n            }\r\n            let animationGroupToUse = ag;\r\n            // check which animation to use. If no animationGroup was defined and an animation was provided, use the animation\r\n            if (animation && !animationGroupToUse) {\r\n                const target = this.object.getValue(context);\r\n                if (!target) {\r\n                    return this._reportError(context, \"No target object provided\");\r\n                }\r\n                const animationsArray = Array.isArray(animation) ? animation : [animation];\r\n                const name = animationsArray[0].name;\r\n                animationGroupToUse = new AnimationGroup(\"flowGraphAnimationGroup-\" + name + \"-\" + target.name, context.configuration.scene);\r\n                let isInterpolation = false;\r\n                const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []) as number[];\r\n                for (const anim of animationsArray) {\r\n                    animationGroupToUse.addTargetedAnimation(anim, target);\r\n                    if (interpolationAnimations.indexOf(anim.uniqueId) !== -1) {\r\n                        isInterpolation = true;\r\n                    }\r\n                }\r\n\r\n                if (isInterpolation) {\r\n                    this._checkInterpolationDuplications(context, animationsArray, target);\r\n                }\r\n            }\r\n            // not accepting 0\r\n            const speed = this.speed.getValue(context) || 1;\r\n            const from = this.from.getValue(context) ?? 0;\r\n            // not accepting 0\r\n            const to = this.to.getValue(context) || animationGroupToUse.to;\r\n            const loop = !isFinite(to) || this.loop.getValue(context);\r\n            this.currentAnimationGroup.setValue(animationGroupToUse, context);\r\n\r\n            const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n            // check if it already running\r\n            if (currentlyRunningAnimationGroups.indexOf(animationGroupToUse.uniqueId) !== -1) {\r\n                animationGroupToUse.stop();\r\n            }\r\n            try {\r\n                animationGroupToUse.start(loop, speed, from, to);\r\n                animationGroupToUse.onAnimationGroupEndObservable.add(() => this._onAnimationGroupEnd(context));\r\n                animationGroupToUse.onAnimationEndObservable.add(() => this._eventsSignalOutputs[\"animationEnd\"]._activateSignal(context));\r\n                animationGroupToUse.onAnimationLoopObservable.add(() => this._eventsSignalOutputs[\"animationLoop\"]._activateSignal(context));\r\n                animationGroupToUse.onAnimationGroupLoopObservable.add(() => this._eventsSignalOutputs[\"animationGroupLoop\"]._activateSignal(context));\r\n                currentlyRunningAnimationGroups.push(animationGroupToUse.uniqueId);\r\n                context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\r\n            } catch (e) {\r\n                this._reportError(context, e);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected override _reportError(context: FlowGraphContext, error: string | Error): void {\r\n        super._reportError(context, error);\r\n        this.currentFrame.setValue(-1, context);\r\n        this.currentTime.setValue(-1, context);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _executeOnTick(_context: FlowGraphContext): void {\r\n        const ag = this.currentAnimationGroup.getValue(_context);\r\n        if (ag) {\r\n            this.currentFrame.setValue(ag.getCurrentFrame(), _context);\r\n            this.currentTime.setValue(ag.animatables[0]?.elapsedTime ?? 0, _context);\r\n        }\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext): void {\r\n        this._startPendingTasks(context);\r\n    }\r\n\r\n    private _onAnimationGroupEnd(context: FlowGraphContext) {\r\n        this._removeFromCurrentlyRunning(context, this.currentAnimationGroup.getValue(context));\r\n        this._resetAfterCanceled(context);\r\n        this.done._activateSignal(context);\r\n    }\r\n\r\n    /**\r\n     * The idea behind this function is to check every running animation group and check if the targeted animations it uses are interpolation animations.\r\n     * If they are, we want to see that they don't collide with the current interpolation animations that are starting to play.\r\n     * If they do, we want to stop the already-running animation group.\r\n     * @internal\r\n     */\r\n    private _checkInterpolationDuplications(context: FlowGraphContext, animation: Animation[], target: any) {\r\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        for (const uniqueId of currentlyRunningAnimationGroups) {\r\n            const ag = context.assetsContext.animationGroups.find((ag) => ag.uniqueId === uniqueId);\r\n            if (ag) {\r\n                for (const anim of ag.targetedAnimations) {\r\n                    for (const animToCheck of animation) {\r\n                        if (anim.animation.targetProperty === animToCheck.targetProperty && anim.target === target) {\r\n                            this._stopAnimationGroup(context, ag);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _stopAnimationGroup(context: FlowGraphContext, animationGroup: AnimationGroup) {\r\n        // stop, while skipping the on AnimationEndObservable to avoid the \"done\" signal\r\n        animationGroup.stop(true);\r\n        animationGroup.dispose();\r\n        this._removeFromCurrentlyRunning(context, animationGroup);\r\n    }\r\n\r\n    private _removeFromCurrentlyRunning(context: FlowGraphContext, animationGroup: AnimationGroup) {\r\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        const idx = currentlyRunningAnimationGroups.indexOf(animationGroup.uniqueId);\r\n        if (idx !== -1) {\r\n            currentlyRunningAnimationGroups.splice(idx, 1);\r\n            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Stop any currently running animations.\r\n     */\r\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const ag = this.currentAnimationGroup.getValue(context);\r\n        if (ag) {\r\n            this._stopAnimationGroup(context, ag);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.PlayAnimation;\r\n    }\r\n}\r\n\r\nRegisterClass(FlowGraphBlockNames.PlayAnimation, FlowGraphPlayAnimationBlock);\r\n"],"names":["FlowGraphPlayAnimationBlock","config","super","this","speed","registerDataInput","loop","from","to","currentFrame","registerDataOutput","currentTime","currentAnimationGroup","animationGroup","animation","object","_preparePendingTasks","context","ag","getValue","_reportError","dispose","animationGroupToUse","target","animationsArray","Array","isArray","name","AnimationGroup","configuration","scene","isInterpolation","interpolationAnimations","_getGlobalContextVariable","anim","addTargetedAnimation","indexOf","uniqueId","_checkInterpolationDuplications","isFinite","setValue","currentlyRunningAnimationGroups","stop","start","onAnimationGroupEndObservable","add","_onAnimationGroupEnd","onAnimationEndObservable","_eventsSignalOutputs","_activateSignal","onAnimationLoopObservable","onAnimationGroupLoopObservable","push","_setGlobalContextVariable","e","error","_executeOnTick","_context","getCurrentFrame","animatables","elapsedTime","_execute","_startPendingTasks","_removeFromCurrentlyRunning","_resetAfterCanceled","done","assetsContext","animationGroups","find","targetedAnimations","animToCheck","targetProperty","_stopAnimationGroup","idx","splice","_cancelPendingTasks","getClassName"],"ignoreList":[],"sourceRoot":""}