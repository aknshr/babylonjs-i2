{"version":3,"file":"3776.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Data/flowGraphCachedOperationBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphPathConverterComponent.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.ts?"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { FlowGraphBlock } from \"../../flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../flowGraphDataConnection\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport { RichTypeBoolean } from \"../../flowGraphRichTypes\";\r\n\r\nconst CacheName = \"cachedOperationValue\";\r\nconst CacheExecIdName = \"cachedExecutionId\";\r\n\r\n/**\r\n * A block that will cache the result of an operation and deliver it as an output.\r\n */\r\nexport abstract class FlowGraphCachedOperationBlock<OutputT> extends FlowGraphBlock {\r\n    /**\r\n     * The output of the operation\r\n     */\r\n    public readonly value: FlowGraphDataConnection<OutputT>;\r\n\r\n    /**\r\n     * Output connection: Whether the value is valid.\r\n     */\r\n    public readonly isValid: FlowGraphDataConnection<boolean>;\r\n\r\n    constructor(outputRichType: RichType<OutputT>, config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n\r\n        this.value = this.registerDataOutput(\"value\", outputRichType);\r\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Operation to realize\r\n     * @param context the graph context\r\n     */\r\n    public abstract _doOperation(context: FlowGraphContext): OutputT | undefined;\r\n\r\n    public override _updateOutputs(context: FlowGraphContext) {\r\n        const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);\r\n        const cachedValue = context._getExecutionVariable<Nullable<OutputT>>(this, CacheName, null);\r\n        if (cachedValue !== undefined && cachedValue !== null && cachedExecutionId === context.executionId) {\r\n            this.isValid.setValue(true, context);\r\n            this.value.setValue(cachedValue, context);\r\n        } else {\r\n            try {\r\n                const calculatedValue = this._doOperation(context);\r\n                if (calculatedValue === undefined || calculatedValue === null) {\r\n                    this.isValid.setValue(false, context);\r\n                    return;\r\n                }\r\n                context._setExecutionVariable(this, CacheName, calculatedValue);\r\n                context._setExecutionVariable(this, CacheExecIdName, context.executionId);\r\n                this.value.setValue(calculatedValue, context);\r\n                this.isValid.setValue(true, context);\r\n            } catch (e) {\r\n                this.isValid.setValue(false, context);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { IObjectInfo, IPathToObjectConverter } from \"../ObjectModel/objectModelInterfaces\";\r\nimport type { FlowGraphBlock } from \"./flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"./flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"./flowGraphDataConnection\";\r\nimport { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\r\nimport { RichTypeFlowGraphInteger } from \"./flowGraphRichTypes\";\r\nimport type { IObjectAccessor } from \"./typeDefinitions\";\r\n\r\nconst PathHasTemplatesRegex = new RegExp(/\\/\\{(\\w+)\\}(?=\\/|$)/g);\r\n\r\n/**\r\n * @experimental\r\n * A component that converts a path to an object accessor.\r\n */\r\nexport class FlowGraphPathConverterComponent {\r\n    /**\r\n     * The templated inputs for the provided path.\r\n     */\r\n    public readonly templatedInputs: FlowGraphDataConnection<FlowGraphInteger>[] = [];\r\n    public constructor(\r\n        public path: string,\r\n        public ownerBlock: FlowGraphBlock\r\n    ) {\r\n        let match = PathHasTemplatesRegex.exec(path);\r\n        const templateSet = new Set<string>();\r\n        while (match) {\r\n            const [, matchGroup] = match;\r\n            if (templateSet.has(matchGroup)) {\r\n                throw new Error(\"Duplicate template variable detected.\");\r\n            }\r\n            templateSet.add(matchGroup);\r\n            this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger, new FlowGraphInteger(0)));\r\n            match = PathHasTemplatesRegex.exec(path);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the accessor for the path.\r\n     * @param pathConverter the path converter to use to convert the path to an object accessor.\r\n     * @param context the context to use.\r\n     * @returns the accessor for the path.\r\n     * @throws if the value for a templated input is invalid.\r\n     */\r\n    public getAccessor(pathConverter: IPathToObjectConverter<IObjectAccessor>, context: FlowGraphContext): IObjectInfo<IObjectAccessor> {\r\n        let finalPath = this.path;\r\n        for (const templatedInput of this.templatedInputs) {\r\n            const valueToReplace = templatedInput.getValue(context).value;\r\n            if (typeof valueToReplace !== \"number\" || valueToReplace < 0) {\r\n                throw new Error(\"Invalid value for templated input.\");\r\n            }\r\n            finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());\r\n        }\r\n        return pathConverter.convert(finalPath);\r\n    }\r\n}\r\n","import type { FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { FlowGraphPathConverterComponent } from \"core/FlowGraph/flowGraphPathConverterComponent\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport type { IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport type { Animation } from \"core/Animations/animation\";\nimport type { EasingFunction } from \"core/Animations/easing\";\nimport { Vector3, Vector4 } from \"core/Maths/math.vector\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\nimport { FlowGraphCachedOperationBlock } from \"../flowGraphCachedOperationBlock\";\n\n/**\n * Configuration for the JSON pointer parser block.\n */\nexport interface IFlowGraphJsonPointerParserBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The JSON pointer to parse.\n     */\n    jsonPointer: string;\n    /**\n     * The path converter to use to convert the path to an object accessor.\n     */\n    pathConverter: IPathToObjectConverter<IObjectAccessor>;\n\n    /**\n     * Whether to output the value of the property.\n     */\n    outputValue?: boolean;\n}\n\n/**\n * This block will take a JSON pointer and parse it to get the value from the JSON object.\n * The output is an object and a property name.\n * Optionally, the block can also output the value of the property. This is configurable.\n */\nexport class FlowGraphJsonPointerParserBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphCachedOperationBlock<P> {\n    /**\n     * Output connection: The object that contains the property.\n     */\n    public readonly object: FlowGraphDataConnection<O>;\n\n    /**\n     * Output connection: The property name.\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Output connection: A function that can be used to update the value of the property.\n     */\n    public readonly setterFunction: FlowGraphDataConnection<(target: O, propertyName: string, value: P, context: FlowGraphContext) => void>;\n\n    /**\n     * Output connection: A function that can be used to get the value of the property.\n     */\n    public readonly getterFunction: FlowGraphDataConnection<(target: O, propertyName: string, context: FlowGraphContext) => P | undefined>;\n\n    /**\n     * Output connection: A function that can be used to get the interpolation animation property info.\n     */\n    public readonly generateAnimationsFunction: FlowGraphDataConnection<() => (keys: any[], fps: number, easingFunction?: EasingFunction) => Animation[]>;\n\n    /**\n     * The component with the templated inputs for the provided path.\n     */\n    public readonly templateComponent: FlowGraphPathConverterComponent;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphJsonPointerParserBlockConfiguration\n    ) {\n        super(RichTypeAny, config);\n        this.object = this.registerDataOutput(\"object\", RichTypeAny);\n        this.propertyName = this.registerDataOutput(\"propertyName\", RichTypeAny);\n        this.setterFunction = this.registerDataOutput(\"setFunction\", RichTypeAny, this._setPropertyValue.bind(this));\n        this.getterFunction = this.registerDataOutput(\"getFunction\", RichTypeAny, this._getPropertyValue.bind(this));\n        this.generateAnimationsFunction = this.registerDataOutput(\"generateAnimationsFunction\", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));\n        this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);\n    }\n\n    public override _doOperation(context: FlowGraphContext): P {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const value = accessorContainer.info.get(accessorContainer.object) as P;\n        const object = accessorContainer.info.getTarget?.(accessorContainer.object);\n        const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);\n        if (!object) {\n            throw new Error(\"Object is undefined\");\n        } else {\n            this.object.setValue(object, context);\n            if (propertyName) {\n                this.propertyName.setValue(propertyName, context);\n            }\n        }\n        return value;\n    }\n\n    private _setPropertyValue(_target: O, _propertyName: string, value: P, context: FlowGraphContext): void {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        if (type.startsWith(\"Color\")) {\n            value = ToColor(value as Vector4, type) as unknown as P;\n        }\n        accessorContainer.info.set?.(value, accessorContainer.object);\n    }\n\n    private _getPropertyValue(_target: O, _propertyName: string, context: FlowGraphContext): P | undefined {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        const value = accessorContainer.info.get(accessorContainer.object);\n        if (type.startsWith(\"Color\")) {\n            return FromColor(value as Color3 | Color4) as unknown as P;\n        }\n        return value as P | undefined;\n    }\n\n    private _getInterpolationAnimationPropertyInfo(\n        _target: O,\n        _propertyName: string,\n        context: FlowGraphContext\n    ): (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => Animation[] {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => {\n            const animations: Animation[] = [];\n            // make sure keys are of the right type (in case of float3 color/vector)\n            const type = accessorContainer.info.type;\n            if (type.startsWith(\"Color\")) {\n                keys = keys.map((key) => {\n                    return {\n                        frame: key.frame,\n                        value: ToColor(key.value, type),\n                    };\n                });\n            }\n            accessorContainer.info.interpolation?.forEach((info, index) => {\n                const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || \"Animation-interpolation-\" + index;\n                // generate the keys based on interpolation info\n                let newKeys: any[] = keys;\n                if (animationType !== info.type) {\n                    // convert the keys to the right type\n                    newKeys = keys.map((key) => {\n                        return {\n                            frame: key.frame,\n                            value: info.getValue(undefined, key.value.asArray ? key.value.asArray() : [key.value], 0, 1),\n                        };\n                    });\n                }\n                const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);\n                for (const animation of animationData) {\n                    if (easingFunction) {\n                        animation.babylonAnimation.setEasingFunction(easingFunction);\n                    }\n                    animations.push(animation.babylonAnimation);\n                }\n            });\n\n            return animations;\n        };\n    }\n\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    public override getClassName(): string {\n        return FlowGraphBlockNames.JsonPointerParser;\n    }\n}\n\nfunction ToColor(value: any, expectedValue: string) {\n    if (value.getClassName().startsWith(\"Color\")) {\n        return value as unknown as Color3 | Color4;\n    }\n    if (expectedValue === \"Color3\") {\n        return new Color3(value.x, value.y, value.z);\n    } else if (expectedValue === \"Color4\") {\n        return new Color4(value.x, value.y, value.z, value.w);\n    }\n    return value;\n}\n\nfunction FromColor(value: Color3 | Color4): Vector3 | Vector4 {\n    if (value instanceof Color3) {\n        return new Vector3(value.r, value.g, value.b);\n    } else if (value instanceof Color4) {\n        return new Vector4(value.r, value.g, value.b, value.a);\n    }\n    throw new Error(\"Invalid color type\");\n}\n\nRegisterClass(FlowGraphBlockNames.JsonPointerParser, FlowGraphJsonPointerParserBlock);\n"],"names":["CacheName","CacheExecIdName","FlowGraphCachedOperationBlock","constructor","outputRichType","config","super","this","value","registerDataOutput","isValid","_updateOutputs","context","cachedExecutionId","_getExecutionVariable","cachedValue","executionId","setValue","calculatedValue","_doOperation","_setExecutionVariable","e","PathHasTemplatesRegex","RegExp","FlowGraphPathConverterComponent","path","ownerBlock","templatedInputs","match","exec","templateSet","Set","matchGroup","has","Error","add","push","registerDataInput","getAccessor","pathConverter","finalPath","templatedInput","valueToReplace","getValue","replace","name","toString","convert","FlowGraphJsonPointerParserBlock","object","propertyName","setterFunction","_setPropertyValue","bind","getterFunction","_getPropertyValue","generateAnimationsFunction","_getInterpolationAnimationPropertyInfo","templateComponent","jsonPointer","accessorContainer","info","get","getTarget","getPropertyName","_target","_propertyName","type","startsWith","ToColor","set","r","g","b","a","FromColor","keys","fps","animationType","easingFunction","animations","map","key","frame","interpolation","forEach","index","newKeys","undefined","asArray","animationData","buildAnimations","animation","babylonAnimation","setEasingFunction","getClassName","expectedValue","x","y","z","w"],"ignoreList":[],"sourceRoot":""}