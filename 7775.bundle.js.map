{"version":3,"file":"7775.bundle.js","mappings":"yOAeO,MAAMA,UAA+B,IAoBxC,WAAAC,CAAYC,GACRC,MAAMD,GACNE,KAAKC,OAASD,KAAKE,qBAAqB,UACxCF,KAAKG,SAAWH,KAAKI,kBAAkB,WAAY,MACnDJ,KAAKK,eAAiBL,KAAKM,mBAAmB,iBAAkB,KAA0B,IAAI,KAAkB,GACpH,CAEgB,oBAAAC,CAAqBC,GACjC,MAAML,EAAWH,KAAKG,SAASM,SAASD,GACxC,GAAIL,EAAW,GAAKO,MAAMP,KAAcQ,SAASR,GAC7C,OAAOH,KAAKY,aAAaJ,EAAS,sCAKtC,GAD6BA,EAAQK,0BAA0B,eAAgB,IAC3DjB,EAAuBkB,sBACvC,OAAOd,KAAKY,aAAaJ,EAAS,+BAGtC,MAAMH,EAAyBG,EAAQK,0BAA0B,kBAAmB,GAG9EE,EAASP,EAAQQ,sBAAsBhB,KAAM,gBAAiB,IAC9DiB,EAAQT,EAAQU,cAAcD,MAC9BE,EAAuB,IAAI,KAAc,CAC3CC,QAAoB,IAAXjB,EACTkB,kBAAmBJ,EAAMK,yBACzBC,QAAS,IAAMvB,KAAKwB,SAASL,EAAOX,KAExCW,EAAMM,QACN,MAAMC,EAAWrB,EAAiB,EAClCL,KAAKK,eAAesB,SAAS,IAAI,IAAiBD,GAAWlB,GAC7DA,EAAQoB,0BAA0B,iBAAkBF,GAEpDX,EAAOW,GAAYP,EACnBX,EAAQqB,sBAAsB7B,KAAM,gBAAiBe,GACrDf,KAAK8B,oBAAoBtB,EAC7B,CAEgB,mBAAAuB,CAAoBvB,GAChC,MAAMO,EAASP,EAAQQ,sBAAsBhB,KAAM,gBAAiB,IACpE,IAAK,MAAMmB,KAASJ,EAChBI,GAAOa,UAEXxB,EAAQyB,yBAAyBjC,KAAM,iBACvCA,KAAKK,eAAesB,SAAS,IAAI,KAAkB,GAAInB,GACvDR,KAAK8B,oBAAoBtB,EAC7B,CAEO,QAAA0B,CAAS1B,EAA2B2B,GACnCA,IAAkBnC,KAAKC,QAIvBD,KAAKO,qBAAqBC,GAC1BR,KAAKoC,IAAIC,gBAAgB7B,IAJzBR,KAAK+B,oBAAoBvB,EAMjC,CAEgB,YAAA8B,GACZ,MAAO,wBACX,CAEQ,QAAAd,CAASL,EAAsBX,GACnC,MAAMO,EAASP,EAAQQ,sBAAsBhB,KAAM,gBAAiB,IAC9DuC,EAAQxB,EAAOyB,QAAQrB,IACd,IAAXoB,EACAxB,EAAO0B,OAAOF,EAAO,GAErB,IAAOG,KAAK,iFAEhBlC,EAAQmC,oBAAoB3C,MAC5BA,KAAK4C,KAAKP,gBAAgB7B,GAE1BR,KAAK8B,oBAAoBtB,EAC7B,CAEQ,mBAAAsB,CAAoBtB,GACxB,MAAMO,EAASP,EAAQQ,sBAAsBhB,KAAM,gBAAiB,IAC9D6C,EAAerC,EAAQK,0BAA0B,gBAAiB,IAExE,IAAK,IAAIiC,EAAI,EAAGA,EAAI/B,EAAOgC,OAAQD,IAAK,CACpC,IAAK/B,EAAO+B,GACR,SAEJ,MAAM3B,EAAQJ,EAAO+B,GACjBD,EAAaC,IAAMD,EAAaC,KAAO3B,EACvC,IAAOuB,KAAK,iFAEZG,EAAaC,GAAK3B,CAE1B,CACAX,EAAQoB,0BAA0B,gBAAiBiB,EACvD,EA7Gc,EAAA/B,sBAAwB,KAgH1C,QAAc,yBAA8BlB,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.ts?"],"sourcesContent":["import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport { RichTypeFlowGraphInteger, RichTypeNumber } from \"../../../flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\nimport { Logger } from \"../../../../Misc/logger\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\n\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    /**\n     * The maximum number of parallel delays that can be set per node.\n     */\n    public static MaxParallelDelayCount = 100;\n    /**\n     * Input signal: If activated the delayed activations set by this block will be canceled.\n     */\n    public readonly cancel: FlowGraphSignalConnection;\n\n    /**\n     * Input connection: The duration of the delay in seconds.\n     */\n    public readonly duration: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: The last delay index that was set.\n     */\n    public readonly lastDelayIndex: FlowGraphDataConnection<FlowGraphInteger>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));\n    }\n\n    public override _preparePendingTasks(context: FlowGraphContext): void {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n\n        // active delays are global to the context\n        const activeDelays: number = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex: number = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const scene = context.configuration.scene;\n        const timer: AdvancedTimer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(new FlowGraphInteger(newIndex), context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n        this._updateGlobalTimers(context);\n    }\n\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(new FlowGraphInteger(-1), context);\n        this._updateGlobalTimers(context);\n    }\n\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        } else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetDelay;\n    }\n\n    private _onEnded(timer: AdvancedTimer, context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        } else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n\n        this._updateGlobalTimers(context);\n    }\n\n    private _updateGlobalTimers(context: FlowGraphContext) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", [] as AdvancedTimer[]);\n        const globalTimers = context._getGlobalContextVariable(\"pendingDelays\", [] as AdvancedTimer[]);\n        // there should NEVER be the same index in the global and local timers, unless they are equal\n        for (let i = 0; i < timers.length; i++) {\n            if (!timers[i]) {\n                continue;\n            }\n            const timer = timers[i];\n            if (globalTimers[i] && globalTimers[i] !== timer) {\n                Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n            } else {\n                globalTimers[i] = timer;\n            }\n        }\n        context._setGlobalContextVariable(\"pendingDelays\", globalTimers);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetDelay, FlowGraphSetDelayBlock);\n"],"names":["FlowGraphSetDelayBlock","constructor","config","super","this","cancel","_registerSignalInput","duration","registerDataInput","lastDelayIndex","registerDataOutput","_preparePendingTasks","context","getValue","isNaN","isFinite","_reportError","_getGlobalContextVariable","MaxParallelDelayCount","timers","_getExecutionVariable","scene","configuration","timer","timeout","contextObservable","onBeforeRenderObservable","onEnded","_onEnded","start","newIndex","setValue","_setGlobalContextVariable","_setExecutionVariable","_updateGlobalTimers","_cancelPendingTasks","dispose","_deleteExecutionVariable","_execute","callingSignal","out","_activateSignal","getClassName","index","indexOf","splice","Warn","_removePendingBlock","done","globalTimers","i","length"],"ignoreList":[],"sourceRoot":""}