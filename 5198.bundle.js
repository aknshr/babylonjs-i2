"use strict";(self.webpackChunk_dev_inspector_v2=self.webpackChunk_dev_inspector_v2||[]).push([[5198],{75198:(e,t,s)=>{s.r(t),s.d(t,{ExportServiceDefinition:()=>k,default:()=>P});var o=s(11798),r=s(87542),i=s(15667),a=s(74421),n=s(95611),l=s(19567),c=s(93819),m=s(14491),d=s(83031);let p=[];const g=(e,t)=>{e.doNotSerialize||(t.vertexData.push(e.serializeVerticeData()),p[e.id]=!0)},u=(e,t)=>{const s={},o=e._geometry;return o&&(e.getScene().getGeometryById(o.id)||g(o,t.geometries)),e.serialize&&e.serialize(s),s},h=(e,t)=>{if(e._isMesh){const s=e;if(s.delayLoadState===n.Y.DELAYLOADSTATE_LOADED||s.delayLoadState===n.Y.DELAYLOADSTATE_NONE){const e=e=>{t.materials=t.materials||[],s.material&&!t.materials.some((e=>e.id===s.material.id))&&t.materials.push(e.serialize())};if(s.material&&!s.material.doNotSerialize)if(s.material instanceof l.F){if(t.multiMaterials=t.multiMaterials||[],!t.multiMaterials.some((e=>e.id===s.material.id))){t.multiMaterials.push(s.material.serialize());for(const t of s.material.subMaterials)t&&e(t)}}else e(s.material);else s.material||e(s.getScene().defaultMaterial);const o=s._geometry;o&&(t.geometries||(t.geometries={},t.geometries.boxes=[],t.geometries.spheres=[],t.geometries.cylinders=[],t.geometries.toruses=[],t.geometries.grounds=[],t.geometries.planes=[],t.geometries.torusKnots=[],t.geometries.vertexData=[]),g(o,t.geometries)),s.skeleton&&!s.skeleton.doNotSerialize&&(t.skeletons=t.skeletons||[],t.skeletons.push(s.skeleton.serialize())),t.meshes=t.meshes||[],t.meshes.push(u(s,t))}}else if("TransformNode"===e.getClassName()){const s=e;t.transformNodes.push(s.serialize())}else if(-1!==e.getClassName().indexOf("Camera")){const s=e;t.cameras.push(s.serialize())}else if(-1!==e.getClassName().indexOf("Light")){const s=e;t.lights.push(s.serialize())}};class f{static ClearCache(){p=[]}static Serialize(e){return f._Serialize(e)}static _Serialize(e,t=!0){const s={};if(t&&!e.getEngine()._features.supportSyncTextureRead&&m.g.ForceSerializeBuffers&&d.V.Warn("The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead."),f.ClearCache(),s.useDelayedTextureLoading=e.useDelayedTextureLoading,s.autoClear=e.autoClear,s.clearColor=e.clearColor.asArray(),s.ambientColor=e.ambientColor.asArray(),s.gravity=e.gravity.asArray(),s.collisionsEnabled=e.collisionsEnabled,s.useRightHandedSystem=e.useRightHandedSystem,void 0!==e.fogMode&&null!==e.fogMode&&(s.fogMode=e.fogMode),void 0!==e.fogColor&&null!==e.fogColor&&(s.fogColor=e.fogColor.asArray()),void 0!==e.fogStart&&null!==e.fogStart&&(s.fogStart=e.fogStart),void 0!==e.fogEnd&&null!==e.fogEnd&&(s.fogEnd=e.fogEnd),void 0!==e.fogDensity&&null!==e.fogDensity&&(s.fogDensity=e.fogDensity),e.isPhysicsEnabled&&e.isPhysicsEnabled()){const t=e.getPhysicsEngine();t&&(s.physicsEnabled=!0,s.physicsGravity=t.gravity.asArray(),s.physicsEngine=t.getPhysicsPluginName())}e.metadata&&(s.metadata=e.metadata),s.morphTargetManagers=[];for(const t of e.meshes){const e=t.morphTargetManager;e&&s.morphTargetManagers.push(e.serialize())}let o,r,i;for(s.lights=[],o=0;o<e.lights.length;o++)r=e.lights[o],r.doNotSerialize||s.lights.push(r.serialize());for(s.cameras=[],o=0;o<e.cameras.length;o++){const t=e.cameras[o];t.doNotSerialize||s.cameras.push(t.serialize())}if(e.activeCamera&&(s.activeCameraID=e.activeCamera.id),c.p.AppendSerializedAnimations(e,s),e.animationGroups&&e.animationGroups.length>0){s.animationGroups=[];for(let t=0;t<e.animationGroups.length;t++){const o=e.animationGroups[t];s.animationGroups.push(o.serialize())}}if(e.reflectionProbes&&e.reflectionProbes.length>0)for(s.reflectionProbes=[],o=0;o<e.reflectionProbes.length;o++){const t=e.reflectionProbes[o];s.reflectionProbes.push(t.serialize())}for(s.materials=[],s.multiMaterials=[],o=0;o<e.materials.length;o++)i=e.materials[o],i.doNotSerialize||s.materials.push(i.serialize());for(s.multiMaterials=[],o=0;o<e.multiMaterials.length;o++){const t=e.multiMaterials[o];s.multiMaterials.push(t.serialize())}for(e.environmentTexture&&(e.environmentTexture._files?s.environmentTexture=e.environmentTexture.serialize():(s.environmentTexture=e.environmentTexture.name,s.environmentTextureRotationY=e.environmentTexture.rotationY)),s.environmentIntensity=e.environmentIntensity,s.iblIntensity=e.iblIntensity,s.skeletons=[],o=0;o<e.skeletons.length;o++){const t=e.skeletons[o];t.doNotSerialize||s.skeletons.push(t.serialize())}for(s.transformNodes=[],o=0;o<e.transformNodes.length;o++)e.transformNodes[o].doNotSerialize||s.transformNodes.push(e.transformNodes[o].serialize());s.geometries={},s.geometries.boxes=[],s.geometries.spheres=[],s.geometries.cylinders=[],s.geometries.toruses=[],s.geometries.grounds=[],s.geometries.planes=[],s.geometries.torusKnots=[],s.geometries.vertexData=[],p=[];const l=e.getGeometries();for(o=0;o<l.length;o++){const e=l[o];e.isReady()&&g(e,s.geometries)}for(s.meshes=[],o=0;o<e.meshes.length;o++){const t=e.meshes[o];if(t instanceof a.e){const e=t;e.doNotSerialize||e.delayLoadState!==n.Y.DELAYLOADSTATE_LOADED&&e.delayLoadState!==n.Y.DELAYLOADSTATE_NONE||s.meshes.push(u(e,s))}}for(s.particleSystems=[],o=0;o<e.particleSystems.length;o++){const t=e.particleSystems[o];t.doNotSerialize||s.particleSystems.push(t.serialize(!1))}for(s.postProcesses=[],o=0;o<e.postProcesses.length;o++){const t=e.postProcesses[o];t.doNotSerialize||s.postProcesses.push(t.serialize())}e.actionManager&&(s.actions=e.actionManager.serialize("scene"));for(const t of e._serializableComponents)t.serialize(s);if(e.spriteManagers)for(s.spriteManagers=[],o=0;o<e.spriteManagers.length;o++){const t=e.spriteManagers[o];t.doNotSerialize||s.spriteManagers.push(t.serialize(!0))}return s}static async SerializeAsync(e){const t=f._Serialize(e,!1),s=[];return this._CollectPromises(t,s),await Promise.all(s),t}static _CollectPromises(e,t){if(Array.isArray(e))for(let s=0;s<e.length;++s){const o=e[s];o instanceof Promise?t.push(o.then((t=>e[s]=t))):(o instanceof Object||Array.isArray(o))&&this._CollectPromises(o,t)}else if(e instanceof Object)for(const s in e)if(Object.prototype.hasOwnProperty.call(e,s)){const o=e[s];o instanceof Promise?t.push(o.then((t=>e[s]=t))):(o instanceof Object||Array.isArray(o))&&this._CollectPromises(o,t)}}static SerializeMesh(e,t=!1,s=!1){const o={meshes:[],transformNodes:[],cameras:[],lights:[]};if(f.ClearCache(),e=e instanceof Array?e:[e],t||s)for(let o=0;o<e.length;++o){if(s){const t=e[o].getDescendants();for(const s of t)e.indexOf(s)<0&&!s.doNotSerialize&&e.push(s)}t&&e[o].parent&&e.indexOf(e[o].parent)<0&&!e[o].parent.doNotSerialize&&e.push(e[o].parent)}for(const t of e)h(t,o);return o}}var x=s(21148),y=s(66748),b=s(41766),S=s(72632),C=s(20697),v=s(45426),T=s(14390),z=s(5919),E=s(98003),D=s(76295),N=s(35647);const L=[{label:"PNG",value:0,imageType:"image/png"},{label:"WebP",value:1,imageType:"image/webp"}],A=({scene:e})=>{const[t,s]=(0,b.useState)({imageTypeIndex:0,imageQuality:.8,iblDiffuse:!1}),r=(0,b.useCallback)((async()=>{const t=JSON.stringify(f.Serialize(e)),s=new Blob([t],{type:"octet/stream"});x.S0.Download(s,"scene.babylon")}),[e]),a=(0,b.useCallback)((async()=>{if(e.environmentTexture)try{const s=await y.qY.CreateEnvTextureAsync(e.environmentTexture,{imageType:L[t.imageTypeIndex].imageType,imageQuality:t.imageQuality,disableIrradianceTexture:!t.iblDiffuse}),o=new Blob([s],{type:"octet/stream"});x.S0.Download(o,"environment.env")}catch(e){d.V.Error(e),alert(e)}}),[e,t]);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(S.h,{label:"Export to Babylon",icon:N.mdFB,onClick:r}),!e.getEngine().premultipliedAlpha&&e.environmentTexture&&e.environmentTexture._prefiltered&&e.activeCamera&&(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(S.h,{label:"Generate .env texture",icon:N.mdFB,onClick:a}),e.environmentTexture.irradianceTexture&&(0,o.jsx)(z.w,{label:"Diffuse Texture",description:"Export diffuse texture for IBL",value:t.iblDiffuse,onChange:e=>{s((t=>({...t,iblDiffuse:e})))}},"iblDiffuse"),(0,o.jsx)(i.aD,{label:"Image type",options:L,value:t.imageTypeIndex,onChange:e=>{s((t=>({...t,imageTypeIndex:e})))}}),(0,o.jsx)(D.S,{visible:t.imageTypeIndex>0,children:(0,o.jsx)(C.f,{label:"Quality",value:t.imageQuality,onChange:e=>s((t=>({...t,imageQuality:e}))),min:0,max:1})})]})]})},M=(0,E.c)((async()=>{const{GLTF2Export:e}=await Promise.resolve().then(s.bind(s,22790));return t=>{const[s,r]=(0,b.useState)(!1),[i,n]=(0,b.useState)({exportDisabledNodes:!1,exportSkyboxes:!1,exportCameras:!1,exportLights:!1,dracoCompression:!1}),l=(0,b.useCallback)((async()=>{r(!0);try{(await e.GLBAsync(t.scene,"scene",{meshCompressionMethod:i.dracoCompression?"Draco":void 0,shouldExportNode:e=>(e=>{if(!i.exportDisabledNodes&&!e.isEnabled())return!1;if(!i.exportSkyboxes&&e instanceof a.e&&e.material){const t=e.material.reflectionTexture;if(t&&t.coordinatesMode===m.g.SKYBOX_MODE)return!1}return!(!i.exportCameras&&e instanceof v.i||!i.exportLights&&e instanceof T.v)})(e)})).downloadFiles()}catch(e){d.V.Error(`Failed to export GLB: ${e}`)}finally{r(!1)}}),[i,t.scene]);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(z.w,{label:"Export Disabled Nodes",description:"Whether to export nodes that are disabled in the scene.",value:i.exportDisabledNodes,onChange:e=>n({...i,exportDisabledNodes:e})},"GLTFExportDisabledNodes"),(0,o.jsx)(z.w,{label:"Export Skyboxes",description:"Whether to export skybox nodes in the scene.",value:i.exportSkyboxes,onChange:e=>n({...i,exportSkyboxes:e})},"GLTFExportSkyboxes"),(0,o.jsx)(z.w,{label:"Export Cameras",description:"Whether to export cameras in the scene.",value:i.exportCameras,onChange:e=>n({...i,exportCameras:e})},"GLTFExportCameras"),(0,o.jsx)(z.w,{label:"Export Lights",description:"Whether to export lights in the scene.",value:i.exportLights,onChange:e=>n({...i,exportLights:e})},"GLTFExportLights"),(0,o.jsx)(z.w,{label:"Draco Compression",description:"Whether to apply Draco compression to geometry.",value:i.dracoCompression,onChange:e=>n({...i,dracoCompression:e})},"GLTFDracoCompression"),(0,o.jsx)(S.h,{label:"Export to GLB",icon:N.mdFB,onClick:l,disabled:s})]})}})),k={friendlyName:"Export Tools",consumes:[r.L],factory:e=>{const t=[];return t.push(e.addSectionContent({key:"glTF Export",section:"glTF Export",component:({context:e})=>(0,o.jsx)(M,{scene:e})})),t.push(e.addSectionContent({key:"Babylon Export",section:"Babylon Export",component:({context:e})=>(0,o.jsx)(A,{scene:e})})),{dispose:()=>{t.forEach((e=>e.dispose()))}}}},P={serviceDefinitions:[k]}}}]);
//# sourceMappingURL=5198.bundle.js.map