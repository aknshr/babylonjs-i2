{"version":3,"file":"9895.bundle.js","mappings":"oOAiDO,MAAMA,UAAuC,IA8ChD,WAAAC,CAAYC,EAAoD,CAAC,GAC7DC,MAAMD,GANM,KAAAE,UAGV,GAIF,MAAMC,EAC+B,iBAA1BH,GAAQI,eACT,QAA2BJ,EAAOI,gBAClC,QAA2BJ,GAAQI,eAAiB,IAAUC,qBAElEC,EAAoBN,GAAQO,gBAAkB,EAC9CC,EAAWC,KAAKC,kBAAkB,aAAc,KAAgB,GAChEC,EAAQF,KAAKC,kBAAkB,UAAWP,GAChDM,KAAKP,UAAUU,KAAK,CAAEJ,WAAUG,UAChC,IAAK,IAAIE,EAAI,EAAGA,EAAIP,EAAoB,EAAGO,IAAK,CAC5C,MAAML,EAAWC,KAAKC,kBAAkB,YAAYG,IAAK,KAAgBA,IAAMP,EAAoBN,EAAOQ,cAAWM,GAC/GH,EAAQF,KAAKC,kBAAkB,SAASG,IAAKV,GACnDM,KAAKP,UAAUU,KAAK,CAAEJ,WAAUG,SACpC,CACAF,KAAKM,aAAeN,KAAKP,UAAU,GAAGS,MACtCF,KAAKO,SAAWP,KAAKP,UAAUI,GAAmBK,MAClDF,KAAKQ,eAAiBR,KAAKC,kBAAkB,iBAAkB,MAC/DD,KAAKS,UAAYT,KAAKU,mBAAmB,YAAa,MACtDV,KAAKW,aAAeX,KAAKC,kBAAkB,eAAgB,KAAaV,GAAQoB,cAChFX,KAAKY,qBAAuBZ,KAAKC,kBAAkB,uBAAwB,KAC/E,CAEgB,cAAAY,CAAeC,GAC3B,MAAMC,EAA0BD,EAAQE,0BAA0B,0BAA2B,IACvFL,EAAeX,KAAKW,aAAaM,SAASH,GAC1CN,EAAiBR,KAAKQ,eAAeS,SAASH,GAC9CL,EAAYT,KAAKkB,iBAAiBJ,EAASH,EAAcH,GAM/D,GAFAR,KAAKS,UAAUU,SAASV,EAAWK,GAE/BM,MAAMC,QAAQZ,GACd,IAAK,MAAMa,KAAQb,EACfM,EAAwBZ,KAAKmB,EAAKC,eAGtCR,EAAwBZ,KAAKM,EAAUc,UAE3CT,EAAQU,0BAA0B,0BAA2BT,EACjE,CAEQ,gBAAAG,CAAiBJ,EAA2BH,EAAiCH,GACjF,MAAMd,EAAOM,KAAKM,aAAamB,SACzBC,EAAsC,GAEtCC,EAAe3B,KAAKM,aAAaW,SAASH,IAAYpB,EAAKkC,aACjEF,EAAKvB,KAAK,CAAE0B,MAAO,EAAG3B,MAAOyB,IAC7B,MAAM9B,EAAoBG,KAAKT,QAAQM,mBAAqB,EAC5D,IAAK,IAAIO,EAAI,EAAGA,EAAIP,EAAoB,EAAGO,IAAK,CAC5C,MAAML,EAAWC,KAAKP,UAAUW,GAAGL,UAAUkB,SAASH,GACtD,IAAIZ,EAAQF,KAAKP,UAAUW,GAAGF,OAAOe,SAASH,GAC1CV,IAAMP,EAAoB,IAC1BK,EAAQA,GAASR,EAAKkC,mBAETvB,IAAbN,GAA0BG,GAE1BwB,EAAKvB,KAAK,CAAE0B,MAAkB,GAAX9B,EAAeG,SAE1C,CACA,MAAMU,EAAuBZ,KAAKY,qBAAqBK,SAASH,GAChE,GAAIF,EACA,OAAOA,EAAqB,KAAM,KAAME,EAAjCF,CAA0Cc,EAAM,GAAIhC,EAAKC,cAAea,GAEnF,GAA4B,iBAAjBG,EAA2B,CAClC,MAAMF,EAAY,KAAUqB,gBAAgBnB,EAAcjB,EAAKC,cAAe,GAAIa,GAElF,OADAC,EAAUsB,QAAQL,GACX,CAACjB,EACZ,CAMI,OALmBE,EAAaqB,KAAKC,IACjC,MAAMxB,EAAY,KAAUqB,gBAAgBG,EAAMvC,EAAKC,cAAe,GAAIa,GAE1E,OADAC,EAAUsB,QAAQL,GACXjB,IAInB,CAEgB,YAAAyB,GACZ,MAAO,6BACX,GAGJ,QAAc,8BAAwC7C,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Execution/Animation/flowGraphInterpolationBlock.ts?"],"sourcesContent":["import type { EasingFunction } from \"core/Animations/easing\";\nimport { Constants } from \"core/Engines/constants\";\nimport { FlowGraphBlock, type IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport type { FlowGraphTypes } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { getRichTypeByAnimationType, getRichTypeByFlowGraphType, RichTypeAny, RichTypeNumber } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { Animation } from \"core/Animations/animation\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\n\n/**\n * Configuration for the interpolation block.\n */\nexport interface IFlowGraphInterpolationBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The number of keyframes to interpolate between.\n     * Will default to 1 if not provided (i.e. from currentValue to a provided value in the time provided)\n     */\n    keyFramesCount?: number;\n\n    /**\n     * The duration of the interpolation.\n     */\n    duration?: number;\n\n    /**\n     * The name of the property that will be interpolated.\n     */\n    propertyName?: string | string[];\n\n    /**\n     * The type of the animation to create.\n     * Default is ANIMATIONTYPE_FLOAT\n     * This cannot be changed after construction, so make sure to pass the right value.\n     */\n    animationType?: number | FlowGraphTypes;\n}\n\n/**\n * This block is responsible for interpolating between two values.\n * The babylon concept used is Animation, and it is the output of this block.\n *\n * Note that values will be parsed when the in connection is triggered. until then changing the value will not trigger a new interpolation.\n *\n * Internally this block uses the Animation class.\n *\n * Note that if the interpolation is already running a signal will be sent to stop the animation group running it.\n */\nexport class FlowGraphInterpolationBlock<T> extends FlowGraphBlock {\n    /**\n     * Input connection: The value to interpolate from.\n     * Optional. If not provided, the current value will be used.\n     * Note that if provided, every time the animation is created this value will be used!\n     */\n    public readonly initialValue: FlowGraphDataConnection<T>;\n\n    /**\n     * Input connection: The value to interpolate to.\n     * Optional. This can also be set using the KeyFrames input!\n     * If provided it will be set to the last keyframe value.\n     */\n    public readonly endValue: FlowGraphDataConnection<T>;\n\n    /**\n     * output connection: The animation that will be created when in is triggered.\n     */\n    public readonly animation: FlowGraphDataConnection<Animation | Animation[]>;\n\n    /**\n     * Input connection: An optional easing function to use for the interpolation.\n     */\n    public readonly easingFunction: FlowGraphDataConnection<EasingFunction>;\n\n    /**\n     * Input connection: The name of the property that will be set\n     */\n    public readonly propertyName: FlowGraphDataConnection<string | string[]>;\n\n    /**\n     * If provided, this function will be used to create the animation object(s).\n     */\n    public readonly customBuildAnimation: FlowGraphDataConnection<\n        (target: any, propertname: any, context: FlowGraphContext) => (keys: any[], fps: number, animationType: number, easingFunction?: EasingFunction) => Animation | Animation[]\n    >;\n\n    /**\n     * The keyframes to interpolate between.\n     * Each keyframe has a duration input and a value input.\n     */\n    public readonly keyFrames: {\n        duration: FlowGraphDataConnection<number>;\n        value: FlowGraphDataConnection<T>;\n    }[] = [];\n\n    constructor(config: IFlowGraphInterpolationBlockConfiguration = {}) {\n        super(config);\n        const type =\n            typeof config?.animationType === \"string\"\n                ? getRichTypeByFlowGraphType(config.animationType)\n                : getRichTypeByAnimationType(config?.animationType ?? Constants.ANIMATIONTYPE_FLOAT);\n\n        const numberOfKeyFrames = config?.keyFramesCount ?? 1;\n        const duration = this.registerDataInput(`duration_0`, RichTypeNumber, 0);\n        const value = this.registerDataInput(`value_0`, type);\n        this.keyFrames.push({ duration, value });\n        for (let i = 1; i < numberOfKeyFrames + 1; i++) {\n            const duration = this.registerDataInput(`duration_${i}`, RichTypeNumber, i === numberOfKeyFrames ? config.duration : undefined);\n            const value = this.registerDataInput(`value_${i}`, type);\n            this.keyFrames.push({ duration, value });\n        }\n        this.initialValue = this.keyFrames[0].value;\n        this.endValue = this.keyFrames[numberOfKeyFrames].value;\n        this.easingFunction = this.registerDataInput(\"easingFunction\", RichTypeAny);\n        this.animation = this.registerDataOutput(\"animation\", RichTypeAny);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config?.propertyName);\n        this.customBuildAnimation = this.registerDataInput(\"customBuildAnimation\", RichTypeAny);\n    }\n\n    public override _updateOutputs(context: FlowGraphContext): void {\n        const interpolationAnimations = context._getGlobalContextVariable(\"interpolationAnimations\", []) as number[];\n        const propertyName = this.propertyName.getValue(context);\n        const easingFunction = this.easingFunction.getValue(context);\n        const animation = this._createAnimation(context, propertyName, easingFunction);\n        // If an old animation exists, it will be ignored here.\n        // This is because if the animation is running and they both have the same target, the old will be stopped.\n        // This doesn't happen here, it happens in the play animation block.\n        this.animation.setValue(animation, context);\n        // to make sure no 2 interpolations are running on the same target, we will mark the animation in the context\n        if (Array.isArray(animation)) {\n            for (const anim of animation) {\n                interpolationAnimations.push(anim.uniqueId);\n            }\n        } else {\n            interpolationAnimations.push(animation.uniqueId);\n        }\n        context._setGlobalContextVariable(\"interpolationAnimations\", interpolationAnimations);\n    }\n\n    private _createAnimation(context: FlowGraphContext, propertyName: string | string[], easingFunction: EasingFunction): Animation | Animation[] {\n        const type = this.initialValue.richType;\n        const keys: { frame: number; value: T }[] = [];\n        // add initial value\n        const currentValue = this.initialValue.getValue(context) || type.defaultValue;\n        keys.push({ frame: 0, value: currentValue });\n        const numberOfKeyFrames = this.config?.numberOfKeyFrames ?? 1;\n        for (let i = 1; i < numberOfKeyFrames + 1; i++) {\n            const duration = this.keyFrames[i].duration?.getValue(context);\n            let value = this.keyFrames[i].value?.getValue(context);\n            if (i === numberOfKeyFrames - 1) {\n                value = value || type.defaultValue;\n            }\n            if (duration !== undefined && value) {\n                // convert duration to frames, based on 60 fps\n                keys.push({ frame: duration * 60, value });\n            }\n        }\n        const customBuildAnimation = this.customBuildAnimation.getValue(context);\n        if (customBuildAnimation) {\n            return customBuildAnimation(null, null, context)(keys, 60, type.animationType, easingFunction);\n        }\n        if (typeof propertyName === \"string\") {\n            const animation = Animation.CreateAnimation(propertyName, type.animationType, 60, easingFunction);\n            animation.setKeys(keys);\n            return [animation];\n        } else {\n            const animations = propertyName.map((name) => {\n                const animation = Animation.CreateAnimation(name, type.animationType, 60, easingFunction);\n                animation.setKeys(keys);\n                return animation;\n            });\n            return animations;\n        }\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.ValueInterpolation;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.ValueInterpolation, FlowGraphInterpolationBlock);\n\n// #L54P2C\n"],"names":["FlowGraphInterpolationBlock","constructor","config","super","keyFrames","type","animationType","ANIMATIONTYPE_FLOAT","numberOfKeyFrames","keyFramesCount","duration","this","registerDataInput","value","push","i","undefined","initialValue","endValue","easingFunction","animation","registerDataOutput","propertyName","customBuildAnimation","_updateOutputs","context","interpolationAnimations","_getGlobalContextVariable","getValue","_createAnimation","setValue","Array","isArray","anim","uniqueId","_setGlobalContextVariable","richType","keys","currentValue","defaultValue","frame","CreateAnimation","setKeys","map","name","getClassName"],"ignoreList":[],"sourceRoot":""}