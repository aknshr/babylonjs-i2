{"version":3,"file":"7049.bundle.js","mappings":"0NAiDO,MAAMA,UAAsC,IAkB/C,YAAmBC,GACfC,MAAMD,GAHe,KAAAE,KAAI,aAIzBC,KAAKC,UAAYD,KAAKE,mBAAmB,YAAa,MACtDF,KAAKG,WAAaH,KAAKI,kBAAkB,aAAc,KAAaP,GAAQM,YAC5EH,KAAKK,iBAAmBL,KAAKE,mBAAmB,mBAAoB,KACxE,CAEgB,aAAAI,CAAcC,EAA2BC,GACrD,MAAMC,EAAOT,KAAKG,WAAWO,SAASH,GAItC,OAHAP,KAAKK,iBAAiBM,SAASH,EAAQC,KAAMF,GAC7CP,KAAKC,UAAUU,SAASH,EAAQP,UAAWM,OACzBC,EAAQI,QAAQ,QAAgBJ,EAAQC,KAAMA,MAC7CD,EAAQC,OAASA,IAAQ,QAAgBD,EAAQC,KAAMA,MACtET,KAAKa,SAASN,GACNP,KAAKH,QAAQiB,iBAG7B,CACgB,oBAAAC,CAAqBC,GAErC,CACgB,mBAAAC,CAAoBD,GAEpC,CACgB,YAAAE,GACZ,MAAO,+BACX,GAGJ,QAAc,gCAAqCtB,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Event/flowGraphPointerOutEventBlock.ts?"],"sourcesContent":["import type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport { FlowGraphEventBlock } from \"core/FlowGraph/flowGraphEventBlock\";\nimport { FlowGraphEventType } from \"core/FlowGraph/flowGraphEventType\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport type { IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport { RichTypeAny, RichTypeNumber } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { _IsDescendantOf } from \"core/FlowGraph/utils\";\n\n/**\n * Configuration for the pointer out event block.\n */\nexport interface IFlowGraphPointerOutEventBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * Should this mesh block propagation of the event.\n     */\n    stopPropagation?: boolean;\n\n    /**\n     * The mesh to listen to. Can also be set by the asset input.\n     */\n    targetMesh?: AbstractMesh;\n}\n\n/**\n * Payload for the pointer out event.\n */\nexport interface IFlowGraphPointerOutEventPayload {\n    /**\n     * The pointer id.\n     */\n    pointerId: number;\n    /**\n     * The mesh that was picked.\n     */\n    mesh: AbstractMesh;\n\n    /**\n     * If populated, the hover event moved to this mesh from the `mesh` variable\n     */\n    over?: AbstractMesh;\n}\n\n/**\n * A pointe out event block.\n * This block can be used as an entry pointer to when a pointer is out of a specific target mesh.\n */\nexport class FlowGraphPointerOutEventBlock extends FlowGraphEventBlock {\n    /**\n     * Output connection: The pointer id.\n     */\n    public readonly pointerId: FlowGraphDataConnection<number>;\n\n    /**\n     * Input connection: The mesh to listen to.\n     */\n    public readonly targetMesh: FlowGraphDataConnection<AbstractMesh>;\n\n    /**\n     * Output connection: The mesh that the pointer is out of.\n     */\n    public readonly meshOutOfPointer: FlowGraphDataConnection<AbstractMesh>;\n\n    public override readonly type: FlowGraphEventType = FlowGraphEventType.PointerOut;\n\n    public constructor(config?: IFlowGraphPointerOutEventBlockConfiguration) {\n        super(config);\n        this.pointerId = this.registerDataOutput(\"pointerId\", RichTypeNumber);\n        this.targetMesh = this.registerDataInput(\"targetMesh\", RichTypeAny, config?.targetMesh);\n        this.meshOutOfPointer = this.registerDataOutput(\"meshOutOfPointer\", RichTypeAny);\n    }\n\n    public override _executeEvent(context: FlowGraphContext, payload: IFlowGraphPointerOutEventPayload): boolean {\n        const mesh = this.targetMesh.getValue(context);\n        this.meshOutOfPointer.setValue(payload.mesh, context);\n        this.pointerId.setValue(payload.pointerId, context);\n        const skipEvent = payload.over && _IsDescendantOf(payload.mesh, mesh);\n        if (!skipEvent && (payload.mesh === mesh || _IsDescendantOf(payload.mesh, mesh))) {\n            this._execute(context);\n            return !this.config?.stopPropagation;\n        }\n        return true;\n    }\n    public override _preparePendingTasks(_context: FlowGraphContext): void {\n        // no-op\n    }\n    public override _cancelPendingTasks(_context: FlowGraphContext): void {\n        // no-op\n    }\n    public override getClassName() {\n        return FlowGraphBlockNames.PointerOutEvent;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.PointerOutEvent, FlowGraphPointerOutEventBlock);\n"],"names":["FlowGraphPointerOutEventBlock","config","super","type","this","pointerId","registerDataOutput","targetMesh","registerDataInput","meshOutOfPointer","_executeEvent","context","payload","mesh","getValue","setValue","over","_execute","stopPropagation","_preparePendingTasks","_context","_cancelPendingTasks","getClassName"],"ignoreList":[],"sourceRoot":""}