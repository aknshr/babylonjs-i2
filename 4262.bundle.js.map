{"version":3,"file":"4262.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/BVH/bvhLoader.ts?","webpack://@dev/inspector-v2/../loaders/src/BVH/bvhFileLoader.ts?"],"sourcesContent":["import type { IAnimationKey } from \"core/Animations\";\nimport { Animation } from \"core/Animations/animation\";\nimport { Bone } from \"core/Bones/bone\";\nimport { Skeleton } from \"core/Bones/skeleton\";\nimport { Matrix, Quaternion, Vector3 } from \"core/Maths/math.vector\";\nimport type { Scene } from \"core/scene\";\nimport type { Nullable } from \"core/types\";\nimport type { BVHLoadingOptions } from \"./bvhLoadingOptions\";\nimport { Tools } from \"core/Misc/tools\";\nimport type { AssetContainer } from \"core/assetContainer\";\n\nconst _XPosition = \"Xposition\";\nconst _YPosition = \"Yposition\";\nconst _ZPosition = \"Zposition\";\nconst _XRotation = \"Xrotation\";\nconst _YRotation = \"Yrotation\";\nconst _ZRotation = \"Zrotation\";\n\nconst _HierarchyNode = \"HIERARCHY\";\nconst _MotionNode = \"MOTION\";\n\nclass LoaderContext {\n    loopMode: number = Animation.ANIMATIONLOOPMODE_CYCLE;\n    list: IBVHNode[] = [];\n    root: IBVHNode = CreateBVHNode();\n    numFrames: number = 0;\n    frameRate: number = 0;\n    skeleton: Skeleton;\n\n    constructor(skeleton: Skeleton) {\n        this.skeleton = skeleton;\n    }\n}\n\ninterface IBVHNode {\n    name: string;\n    type: string;\n    offset: Vector3;\n    channels: string[];\n    children: IBVHNode[];\n    frames: IBVHKeyFrame[];\n    parent: Nullable<IBVHNode>;\n}\n\ninterface IBVHKeyFrame {\n    frame: number;\n    position: Vector3;\n    rotation: Quaternion;\n}\n\nfunction CreateBVHNode(): IBVHNode {\n    return {\n        name: \"\",\n        type: \"\",\n        offset: new Vector3(),\n        channels: [],\n        children: [],\n        frames: [],\n        parent: null,\n    };\n}\n\nfunction CreateBVHKeyFrame(): IBVHKeyFrame {\n    return {\n        frame: 0,\n        position: new Vector3(),\n        rotation: new Quaternion(),\n    };\n}\n\n/**\n * Converts the BVH node's offset to a Babylon matrix\n * @param node - The BVH node to convert\n * @returns The converted matrix\n */\nfunction BoneOffset(node: IBVHNode): Matrix {\n    const x = node.offset.x;\n    const y = node.offset.y;\n    const z = node.offset.z;\n    return Matrix.Translation(x, y, z);\n}\n\n/**\n * Creates animations for the BVH node\n * @param node - The BVH node to create animations for\n * @param context - The loader context\n * @returns The created animations\n */\nfunction CreateAnimations(node: IBVHNode, context: LoaderContext): Animation[] {\n    if (node.frames.length === 0) {\n        return [];\n    }\n\n    const animations: Animation[] = [];\n\n    // Create position animation if there are position channels\n    const hasPosition = node.channels.some((c) => c === _XPosition || c === _YPosition || c === _ZPosition);\n\n    // Create rotation animation if there are rotation channels\n    const hasRotation = node.channels.some((c) => c === _XRotation || c === _YRotation || c === _ZRotation);\n\n    const posAnim = new Animation(`${node.name}_pos`, \"position\", context.frameRate, Animation.ANIMATIONTYPE_VECTOR3, context.loopMode);\n\n    const rotAnim = new Animation(`${node.name}_rot`, \"rotationQuaternion\", context.frameRate, Animation.ANIMATIONTYPE_QUATERNION, context.loopMode);\n\n    const posKeys: IAnimationKey[] = [];\n    const rotKeys: IAnimationKey[] = [];\n\n    for (let i = 0; i < node.frames.length; i++) {\n        const frame = node.frames[i];\n\n        if (hasPosition && frame.position) {\n            posKeys.push({\n                frame: frame.frame,\n                value: frame.position.clone(),\n            });\n        }\n\n        if (hasRotation) {\n            rotKeys.push({\n                frame: frame.frame,\n                value: frame.rotation.clone(),\n            });\n        }\n    }\n\n    if (posKeys.length > 0) {\n        posAnim.setKeys(posKeys);\n        animations.push(posAnim);\n    }\n\n    if (rotKeys.length > 0) {\n        rotAnim.setKeys(rotKeys);\n        animations.push(rotAnim);\n    }\n\n    return animations;\n}\n\n/**\n * Converts a BVH node to a Babylon bone\n * @param node - The BVH node to convert\n * @param parent - The parent bone\n * @param context - The loader context\n */\nfunction ConvertNode(node: IBVHNode, parent: Nullable<Bone>, context: LoaderContext) {\n    const matrix = BoneOffset(node);\n    const bone = new Bone(node.name, context.skeleton, parent, matrix);\n\n    // Create animation for this bone\n    const animations = CreateAnimations(node, context);\n    for (const animation of animations) {\n        if (animation.getKeys() && animation.getKeys().length > 0) {\n            bone.animations.push(animation);\n        }\n    }\n\n    for (const child of node.children) {\n        ConvertNode(child, bone, context);\n    }\n}\n\n/**\n * Recursively reads data from a single frame into the bone hierarchy.\n * The bone hierarchy has to be structured in the same order as the BVH file.\n * keyframe data is stored in bone.frames.\n * @param data - splitted string array (frame values), values are shift()ed\n * @param frameNumber - playback time for this keyframe\n * @param bone - the bone to read frame data from\n * @param tokenIndex - the index of the token to read\n */\nfunction ReadFrameData(data: string[], frameNumber: number, bone: IBVHNode, tokenIndex: { i: number }) {\n    if (bone.type === \"ENDSITE\") {\n        // end sites have no motion data\n        return;\n    }\n\n    // add keyframe\n    const keyframe = CreateBVHKeyFrame();\n    keyframe.frame = frameNumber;\n    keyframe.position = new Vector3();\n    keyframe.rotation = new Quaternion();\n\n    bone.frames.push(keyframe);\n\n    let combinedRotation = Matrix.Identity();\n\n    // parse values for each channel in node\n    for (let i = 0; i < bone.channels.length; ++i) {\n        const channel = bone.channels[i];\n        const value = data[tokenIndex.i++];\n        if (!value) {\n            continue;\n        }\n        const parsedValue = parseFloat(value.trim());\n        if (channel.endsWith(\"position\")) {\n            switch (channel) {\n                case _XPosition:\n                    keyframe.position.x = parsedValue;\n                    break;\n                case _YPosition:\n                    keyframe.position.y = parsedValue;\n                    break;\n                case _ZPosition:\n                    keyframe.position.z = parsedValue;\n                    break;\n            }\n        } else if (channel.endsWith(\"rotation\")) {\n            const angle = Tools.ToRadians(parsedValue);\n            let rotationMatrix: Matrix;\n            switch (channel) {\n                case _XRotation:\n                    rotationMatrix = Matrix.RotationX(angle);\n                    break;\n                case _YRotation:\n                    rotationMatrix = Matrix.RotationY(angle);\n                    break;\n                case _ZRotation:\n                    rotationMatrix = Matrix.RotationZ(angle);\n                    break;\n            }\n            combinedRotation = rotationMatrix!.multiply(combinedRotation);\n        }\n    }\n\n    Quaternion.FromRotationMatrixToRef(combinedRotation, keyframe.rotation);\n\n    // parse child nodes\n    for (const child of bone.children) {\n        ReadFrameData(data, frameNumber, child, tokenIndex);\n    }\n}\n\n/**\n * Recursively parses the HIERARCHY section of the BVH file\n * @param lines - all lines of the file. lines are consumed as we go along\n * @param firstLine - line containing the node type and name e.g. \"JOINT hip\"\n * @param parent - the parent node for hierarchy\n * @param context - the loader context containing the list of nodes and other data\n * @returns a BVH node including children\n */\nfunction ReadNode(lines: string[], firstLine: string, parent: Nullable<IBVHNode>, context: LoaderContext): IBVHNode {\n    const node = CreateBVHNode();\n    node.parent = parent;\n    context.list.push(node);\n\n    // parse node type and name.\n    let tokens: string[] | undefined = firstLine.trim().split(/\\s+/);\n\n    if (tokens[0].toUpperCase() === \"END\" && tokens[1].toUpperCase() === \"SITE\") {\n        node.type = \"ENDSITE\";\n        node.name = \"ENDSITE\"; // bvh end sites have no name\n    } else {\n        node.name = tokens[1];\n        node.type = tokens[0].toUpperCase();\n    }\n\n    // opening bracket\n    if (lines.shift()?.trim() != \"{\") {\n        throw new Error(\"Expected opening { after type & name\");\n    }\n\n    // parse OFFSET\n    const tokensSplit = lines.shift()?.trim().split(/\\s+/);\n    if (!tokensSplit) {\n        throw new Error(\"Unexpected end of file: missing OFFSET\");\n    }\n    tokens = tokensSplit;\n\n    if (tokens[0].toUpperCase() != \"OFFSET\") {\n        throw new Error(\"Expected OFFSET, but got: \" + tokens[0]);\n    }\n    if (tokens.length != 4) {\n        throw new Error(\"OFFSET: Invalid number of values\");\n    }\n\n    const offset = new Vector3(parseFloat(tokens[1]), parseFloat(tokens[2]), parseFloat(tokens[3]));\n\n    if (isNaN(offset.x) || isNaN(offset.y) || isNaN(offset.z)) {\n        throw new Error(\"OFFSET: Invalid values\");\n    }\n\n    node.offset = offset;\n\n    // parse CHANNELS definitions\n    if (node.type != \"ENDSITE\") {\n        tokens = lines.shift()?.trim().split(/\\s+/);\n        if (!tokens) {\n            throw new Error(\"Unexpected end of file: missing CHANNELS\");\n        }\n\n        if (tokens[0].toUpperCase() != \"CHANNELS\") {\n            throw new Error(\"Expected CHANNELS definition\");\n        }\n\n        const numChannels = parseInt(tokens[1]);\n        // Skip CHANNELS and the number of channels\n        node.channels = tokens.splice(2, numChannels);\n        node.children = [];\n    }\n\n    // read children\n    while (lines.length > 0) {\n        const line = lines.shift()?.trim();\n\n        if (line === \"}\") {\n            // Finish reading the node\n            return node;\n        } else if (line) {\n            node.children.push(ReadNode(lines, line, node, context));\n        }\n    }\n\n    throw new Error(\"Unexpected end of file: missing closing brace\");\n}\n\n/**\n * Reads a BVH file, returns a skeleton\n * @param text - The BVH file content\n * @param scene - The scene to add the skeleton to\n * @param assetContainer - The asset container to add the skeleton to\n * @param loadingOptions - The loading options\n * @returns The skeleton\n */\nexport function ReadBvh(text: string, scene: Scene, assetContainer: Nullable<AssetContainer>, loadingOptions: BVHLoadingOptions): Skeleton {\n    const lines = text.split(\"\\n\");\n\n    const { loopMode } = loadingOptions;\n\n    scene._blockEntityCollection = !!assetContainer;\n    const skeleton = new Skeleton(\"\", \"\", scene);\n    skeleton._parentContainer = assetContainer;\n    scene._blockEntityCollection = false;\n\n    const context = new LoaderContext(skeleton);\n    context.loopMode = loopMode;\n\n    // read model structure\n    const firstLine = lines.shift();\n    if (!firstLine || firstLine.trim().toUpperCase() !== _HierarchyNode) {\n        throw new Error(\"HIERARCHY expected\");\n    }\n\n    const nodeLine = lines.shift();\n    if (!nodeLine) {\n        throw new Error(\"Unexpected end of file after HIERARCHY\");\n    }\n    const root = ReadNode(lines, nodeLine.trim(), null, context);\n\n    // read motion data\n    const motionLine = lines.shift();\n    if (!motionLine || motionLine.trim().toUpperCase() !== _MotionNode) {\n        throw new Error(\"MOTION expected\");\n    }\n\n    const framesLine = lines.shift();\n    if (!framesLine) {\n        throw new Error(\"Unexpected end of file before frame count\");\n    }\n    const framesTokens = framesLine.trim().split(/[\\s]+/);\n    if (framesTokens.length < 2) {\n        throw new Error(\"Invalid frame count line\");\n    }\n\n    // number of frames\n    const numFrames = parseInt(framesTokens[1]);\n    if (isNaN(numFrames)) {\n        throw new Error(\"Failed to read number of frames.\");\n    }\n    context.numFrames = numFrames;\n\n    // frame time\n    const frameTimeLine = lines.shift();\n    if (!frameTimeLine) {\n        throw new Error(\"Unexpected end of file before frame time\");\n    }\n    const frameTimeTokens = frameTimeLine.trim().split(/[\\s]+/);\n    if (frameTimeTokens.length < 3) {\n        throw new Error(\"Invalid frame time line\");\n    }\n    const frameTime = parseFloat(frameTimeTokens[2]);\n    if (isNaN(frameTime)) {\n        throw new Error(\"Failed to read frame time.\");\n    }\n    if (frameTime <= 0) {\n        throw new Error(\"Failed to read frame time. Invalid value \" + frameTime);\n    }\n\n    context.frameRate = 1 / frameTime;\n\n    // read frame data line by line\n    for (let i = 0; i < numFrames; ++i) {\n        const frameLine = lines.shift();\n        if (!frameLine) {\n            continue;\n        }\n        const tokens = frameLine.trim().split(/[\\s]+/) || [];\n        ReadFrameData(tokens, i, root, { i: 0 });\n    }\n\n    context.root = root;\n\n    ConvertNode(context.root, null, context);\n\n    context.skeleton.returnToRest();\n    return context.skeleton;\n}\n","import type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { Animation } from \"core/Animations/animation\";\nimport type { Scene } from \"core/scene\";\nimport type { BVHLoadingOptions } from \"./bvhLoadingOptions\";\nimport { BVHFileLoaderMetadata } from \"./bvhFileLoader.metadata\";\nimport { ReadBvh } from \"./bvhLoader\";\n\ndeclare module \"core/Loading/sceneLoader\" {\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\n    export interface SceneLoaderPluginOptions {\n        /**\n         * Defines options for the bvh loader.\n         */\n        [BVHFileLoaderMetadata.name]: Partial<BVHLoadingOptions>;\n    }\n}\n\n/**\n * @experimental\n * BVH file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class BVHFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\n    /**\n     * Name of the loader (\"bvh\")\n     */\n    public readonly name = BVHFileLoaderMetadata.name;\n\n    /** @internal */\n    public readonly extensions = BVHFileLoaderMetadata.extensions;\n\n    private readonly _loadingOptions: BVHLoadingOptions;\n\n    /**\n     * Creates loader for bvh motion files\n     * @param loadingOptions - Options for the bvh loader\n     */\n    constructor(loadingOptions?: Partial<Readonly<BVHLoadingOptions>>) {\n        this._loadingOptions = { ...BVHFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\n    }\n\n    private static get _DefaultLoadingOptions(): BVHLoadingOptions {\n        return {\n            loopMode: Animation.ANIMATIONLOOPMODE_CYCLE,\n        };\n    }\n\n    /** @internal */\n    public createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\n        return new BVHFileLoader(options[BVHFileLoaderMetadata.name]);\n    }\n\n    /**\n     * If the data string can be loaded directly.\n     * @param data - direct load data\n     * @returns if the data can be loaded directly\n     */\n    public canDirectLoad(data: string): boolean {\n        return this.isBvhHeader(data);\n    }\n\n    public isBvhHeader(text: string): boolean {\n        return text.split(\"\\n\")[0] == \"HIERARCHY\";\n    }\n\n    public isNotBvhHeader(text: string): boolean {\n        return !this.isBvhHeader(text);\n    }\n\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param _meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the bvh data to load\n     * @returns a promise containing the loaded skeletons and animations\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public importMeshAsync(_meshesNames: string | readonly string[] | null | undefined, scene: Scene, data: unknown): Promise<ISceneLoaderAsyncResult> {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data as string)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        try {\n            const skeleton = ReadBvh(data, scene, null, this._loadingOptions);\n            return Promise.resolve({\n                meshes: [],\n                particleSystems: [],\n                skeletons: [skeleton],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            } as ISceneLoaderAsyncResult);\n        } catch (e) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(e);\n        }\n    }\n\n    /**\n     * Imports all objects from the loaded bvh data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the bvh data to load\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\n    public loadAsync(scene: Scene, data: unknown): Promise<void> {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data as string)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data).then(() => {\n            // return void\n        });\n    }\n\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    public loadAssetContainerAsync(scene: Scene, data: unknown): Promise<AssetContainer> {\n        if (typeof data !== \"string\") {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects string data.\");\n        }\n        if (this.isNotBvhHeader(data as string)) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(\"BVH loader expects HIERARCHY header.\");\n        }\n        const assetContainer = new AssetContainer(scene);\n        try {\n            const skeleton = ReadBvh(data, scene, assetContainer, this._loadingOptions);\n            assetContainer.skeletons.push(skeleton);\n            return Promise.resolve(assetContainer);\n        } catch (e) {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            return Promise.reject(e);\n        }\n    }\n}\n\nRegisterSceneLoaderPlugin(new BVHFileLoader());\n"],"names":["_XPosition","_YPosition","_ZPosition","_XRotation","_YRotation","_ZRotation","LoaderContext","constructor","skeleton","loopMode","ANIMATIONLOOPMODE_CYCLE","list","root","CreateBVHNode","numFrames","frameRate","this","name","type","offset","channels","children","frames","parent","ConvertNode","node","context","matrix","x","y","z","Translation","BoneOffset","bone","animations","length","hasPosition","some","c","hasRotation","posAnim","ANIMATIONTYPE_VECTOR3","rotAnim","ANIMATIONTYPE_QUATERNION","posKeys","rotKeys","i","frame","position","push","value","clone","rotation","setKeys","CreateAnimations","animation","getKeys","child","ReadFrameData","data","frameNumber","tokenIndex","keyframe","combinedRotation","Identity","channel","parsedValue","parseFloat","trim","endsWith","angle","ToRadians","rotationMatrix","RotationX","RotationY","RotationZ","multiply","FromRotationMatrixToRef","ReadNode","lines","firstLine","tokens","split","toUpperCase","shift","Error","tokensSplit","isNaN","numChannels","parseInt","splice","line","ReadBvh","text","scene","assetContainer","loadingOptions","_blockEntityCollection","_parentContainer","nodeLine","motionLine","framesLine","framesTokens","frameTimeLine","frameTimeTokens","frameTime","frameLine","returnToRest","BVHFileLoader","extensions","_loadingOptions","_DefaultLoadingOptions","createPlugin","options","canDirectLoad","isBvhHeader","isNotBvhHeader","importMeshAsync","_meshesNames","Promise","reject","resolve","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","e","loadAsync","then","loadAssetContainerAsync"],"ignoreList":[],"sourceRoot":""}