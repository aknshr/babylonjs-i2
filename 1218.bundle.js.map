{"version":3,"file":"1218.bundle.js","mappings":"yUAWO,SAASA,EAAWC,EAAcC,EAAsBC,EAAgBC,GAC3E,OAAO,KAAQC,UAAUH,EAAQC,GAAQG,aAAaF,EAC1D,CAIO,SAASG,EAAcN,EAAcC,EAAsBC,EAAgBC,GAC9E,OAAO,KAAWC,UAAUH,EAAQC,GAAQG,aAAaF,EAC7D,CAIO,SAASI,EAAWC,EAAeP,EAAsBC,EAAgBC,GAC5E,MAAMM,EAAQ,IAAIC,MAAcF,EAAOG,kBACvC,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAC9BH,EAAMG,GAAKX,EAAOC,KAAYC,EAGlC,OAAOM,CACX,CAGO,MAAeK,EAElB,YACoBC,EACAC,EACAC,EACAC,GAHA,KAAAH,KAAAA,EACA,KAAAC,KAAAA,EACA,KAAAC,SAAAA,EACA,KAAAC,UAAAA,CACjB,CAEO,eAAAC,CAAgBH,EAAcI,EAAaC,GACjD,MAAMC,EAAmB,IAAI,KAAUN,EAAMO,KAAKP,KAAMI,EAAKG,KAAKR,MAElE,OADAO,EAAiBE,QAAQH,GAAM,GACxBC,CACX,EAOG,MAAMG,UAA2CX,EAE7C,eAAAY,CAAgBlB,EAAeQ,EAAcI,EAAaC,GAC7D,MAAMM,EAAuF,GAE7F,OADAA,EAAkBC,KAAK,CAAEC,kBAAmBrB,EAAOsB,sBAAwBR,iBAAkBC,KAAKJ,gBAAgBH,EAAMI,EAAKC,KACtHM,CACX,EAIG,MAAMI,UAAoCjB,EACtC,eAAAY,CAAgBlB,EAAeQ,EAAcI,EAAaC,GAC7D,MAAMM,EAAuF,GAC7F,GAAInB,EAAOG,iBACP,IAAK,IAAIqB,EAAc,EAAGA,EAAcxB,EAAOG,iBAAkBqB,IAAe,CAC5E,MAAMV,EAAmB,IAAI,KAAU,GAAGN,KAAQgB,IAAeT,KAAKP,KAAMI,EAAKG,KAAKR,MAYtF,GAXAO,EAAiBE,QACbH,EAAKY,KAAKC,IAAQ,CACdC,MAAOD,EAAIC,MACXC,UAAWF,EAAIE,UAAYF,EAAIE,UAAUJ,QAAeK,EACxD5B,MAAOyB,EAAIzB,MAAMuB,GACjBM,WAAYJ,EAAII,WAAaJ,EAAII,WAAWN,QAAeK,EAC3DE,cAAeL,EAAIK,mBAEvB,GAGA/B,EAAOgC,wBACP,IAAK,MAAMC,KAAejC,EAAOgC,wBAC7B,GAAIC,EAAYC,mBAAoB,CAChC,MAAMC,EAAcF,EAAYC,mBAAmBE,UAAUZ,GACvDa,EAAwBvB,EAAiBwB,QAC/CH,EAAYI,WAAWnB,KAAKiB,GAC5BlB,EAAkBC,KAAK,CAAEC,kBAAmBc,EAAarB,iBAAkBuB,GAC/E,CAGZ,CAEJ,OAAOlB,CACX,GAGJ,QAAuB,wBAAyB,CAAC,IAAIF,EAAmC,KAAUuB,sBAAuB,WAAYjD,GAAY,IAAM,OACvJ,QAAuB,qBAAsB,CAAC,IAAI0B,EAAmC,KAAUwB,yBAA0B,qBAAsB3C,GAAe,IAAM,OACpK,QAAuB,kBAAmB,CAAC,IAAImB,EAAmC,KAAUuB,sBAAuB,UAAWjD,GAAY,IAAM,OAChJ,QAAuB,oBAAqB,CAAC,IAAIgC,EAA4B,KAAUmB,oBAAqB,YAAa3C,GAAaC,GAAWA,EAAOG,oB","sources":["webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/glTFLoaderAnimation.ts?"],"sourcesContent":["import { Animation } from \"core/Animations/animation\";\r\nimport { Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport type { INode } from \"./glTFLoaderInterfaces\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport { SetInterpolationForKey } from \"./Extensions/objectModelMapping\";\r\n\r\n/** @internal */\r\nexport type GetValueFn = (target: any, source: Float32Array, offset: number, scale: number) => any;\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getVector3(_target: any, source: Float32Array, offset: number, scale: number): Vector3 {\r\n    return Vector3.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getQuaternion(_target: any, source: Float32Array, offset: number, scale: number): Quaternion {\r\n    return Quaternion.FromArray(source, offset).scaleInPlace(scale);\r\n}\r\n\r\n/** @internal */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport function getWeights(target: INode, source: Float32Array, offset: number, scale: number): Array<number> {\r\n    const value = new Array<number>(target._numMorphTargets!);\r\n    for (let i = 0; i < value.length; i++) {\r\n        value[i] = source[offset++] * scale;\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class AnimationPropertyInfo {\r\n    /** @internal */\r\n    public constructor(\r\n        public readonly type: number,\r\n        public readonly name: string,\r\n        public readonly getValue: GetValueFn,\r\n        public readonly getStride: (target: any) => number\r\n    ) {}\r\n\r\n    protected _buildAnimation(name: string, fps: number, keys: any[]): Animation {\r\n        const babylonAnimation = new Animation(name, this.name, fps, this.type);\r\n        babylonAnimation.setKeys(keys, true);\r\n        return babylonAnimation;\r\n    }\r\n\r\n    /** @internal */\r\n    public abstract buildAnimations(target: any, name: string, fps: number, keys: any[]): { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[];\r\n}\r\n\r\n/** @internal */\r\nexport class TransformNodeAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    /** @internal */\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        babylonAnimations.push({ babylonAnimatable: target._babylonTransformNode!, babylonAnimation: this._buildAnimation(name, fps, keys) });\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class WeightAnimationPropertyInfo extends AnimationPropertyInfo {\r\n    public buildAnimations(target: INode, name: string, fps: number, keys: any[]) {\r\n        const babylonAnimations: { babylonAnimatable: IAnimatable; babylonAnimation: Animation }[] = [];\r\n        if (target._numMorphTargets) {\r\n            for (let targetIndex = 0; targetIndex < target._numMorphTargets; targetIndex++) {\r\n                const babylonAnimation = new Animation(`${name}_${targetIndex}`, this.name, fps, this.type);\r\n                babylonAnimation.setKeys(\r\n                    keys.map((key) => ({\r\n                        frame: key.frame,\r\n                        inTangent: key.inTangent ? key.inTangent[targetIndex] : undefined,\r\n                        value: key.value[targetIndex],\r\n                        outTangent: key.outTangent ? key.outTangent[targetIndex] : undefined,\r\n                        interpolation: key.interpolation,\r\n                    })),\r\n                    true\r\n                );\r\n\r\n                if (target._primitiveBabylonMeshes) {\r\n                    for (const babylonMesh of target._primitiveBabylonMeshes) {\r\n                        if (babylonMesh.morphTargetManager) {\r\n                            const morphTarget = babylonMesh.morphTargetManager.getTarget(targetIndex);\r\n                            const babylonAnimationClone = babylonAnimation.clone();\r\n                            morphTarget.animations.push(babylonAnimationClone);\r\n                            babylonAnimations.push({ babylonAnimatable: morphTarget, babylonAnimation: babylonAnimationClone });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return babylonAnimations;\r\n    }\r\n}\r\n\r\nSetInterpolationForKey(\"/nodes/{}/translation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"position\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/rotation\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_QUATERNION, \"rotationQuaternion\", getQuaternion, () => 4)]);\r\nSetInterpolationForKey(\"/nodes/{}/scale\", [new TransformNodeAnimationPropertyInfo(Animation.ANIMATIONTYPE_VECTOR3, \"scaling\", getVector3, () => 3)]);\r\nSetInterpolationForKey(\"/nodes/{}/weights\", [new WeightAnimationPropertyInfo(Animation.ANIMATIONTYPE_FLOAT, \"influence\", getWeights, (target) => target._numMorphTargets!)]);\r\n"],"names":["getVector3","_target","source","offset","scale","FromArray","scaleInPlace","getQuaternion","getWeights","target","value","Array","_numMorphTargets","i","length","AnimationPropertyInfo","type","name","getValue","getStride","_buildAnimation","fps","keys","babylonAnimation","this","setKeys","TransformNodeAnimationPropertyInfo","buildAnimations","babylonAnimations","push","babylonAnimatable","_babylonTransformNode","WeightAnimationPropertyInfo","targetIndex","map","key","frame","inTangent","undefined","outTangent","interpolation","_primitiveBabylonMeshes","babylonMesh","morphTargetManager","morphTarget","getTarget","babylonAnimationClone","clone","animations","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_FLOAT"],"ignoreList":[],"sourceRoot":""}