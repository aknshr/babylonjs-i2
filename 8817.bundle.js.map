{"version":3,"file":"8817.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/gltfPathToObjectConverter.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/objectModelMapping.ts?"],"sourcesContent":["import type { IObjectInfo, IPathToObjectConverter } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport type { IGLTF } from \"../glTFLoaderInterfaces\";\r\nimport type { IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\r\n\r\n/**\r\n * Adding an exception here will break traversing through the glTF object tree.\r\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\r\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\r\n */\r\nexport const OptionalPathExceptionsList: {\r\n    regex: RegExp;\r\n}[] = [\r\n    {\r\n        // get the node as object when reading an extension\r\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\r\n    },\r\n];\r\n\r\n/**\r\n * A converter that takes a glTF Object Model JSON Pointer\r\n * and transforms it into an ObjectAccessorContainer, allowing\r\n * objects referenced in the glTF to be associated with their\r\n * respective Babylon.js objects.\r\n */\r\nexport class GLTFPathToObjectConverter<T, BabylonType, BabylonValue> implements IPathToObjectConverter<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n    public constructor(\r\n        private _gltf: IGLTF,\r\n        private _infoTree: any\r\n    ) {}\r\n\r\n    /**\r\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\r\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\r\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\r\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\r\n     * <assetIndex> := <digit> | <name>\r\n     * <propertyPath> := <extensionPath> | <standardPath>\r\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\r\n     * <standardPath> := <name> | <name>/<standardPath>\r\n     * <name> := W+\r\n     * <digit> := D+\r\n     *\r\n     * Examples:\r\n     *  - \"/nodes/0/rotation\"\r\n     * - \"/nodes.length\"\r\n     *  - \"/materials/2/emissiveFactor\"\r\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\r\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\r\n     *\r\n     * @param path The path to convert\r\n     * @returns The object and info associated with the path\r\n     */\r\n    public convert(path: string): IObjectInfo<IObjectAccessor<T, BabylonType, BabylonValue>> {\r\n        let objectTree: any = this._gltf;\r\n        let infoTree: any = this._infoTree;\r\n        let target: any = undefined;\r\n\r\n        if (!path.startsWith(\"/\")) {\r\n            throw new Error(\"Path must start with a /\");\r\n        }\r\n        const parts = path.split(\"/\");\r\n        parts.shift();\r\n\r\n        //if the last part has \".length\" in it, separate that as an extra part\r\n        if (parts[parts.length - 1].includes(\".length\")) {\r\n            const lastPart = parts[parts.length - 1];\r\n            const split = lastPart.split(\".\");\r\n            parts.pop();\r\n            parts.push(...split);\r\n        }\r\n\r\n        let ignoreObjectTree = false;\r\n\r\n        for (const part of parts) {\r\n            const isLength = part === \"length\";\r\n            if (isLength && !infoTree.__array__) {\r\n                throw new Error(`Path ${path} is invalid`);\r\n            }\r\n            if (infoTree.__ignoreObjectTree__) {\r\n                ignoreObjectTree = true;\r\n            }\r\n            if (infoTree.__array__ && !isLength) {\r\n                infoTree = infoTree.__array__;\r\n            } else {\r\n                infoTree = infoTree[part];\r\n                if (!infoTree) {\r\n                    throw new Error(`Path ${path} is invalid`);\r\n                }\r\n            }\r\n            if (!ignoreObjectTree) {\r\n                if (objectTree === undefined) {\r\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\r\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\r\n                    if (!exception) {\r\n                        throw new Error(`Path ${path} is invalid`);\r\n                    }\r\n                } else if (!isLength) {\r\n                    objectTree = objectTree?.[part];\r\n                }\r\n            }\r\n\r\n            if (infoTree.__target__ || isLength) {\r\n                target = objectTree;\r\n            }\r\n        }\r\n\r\n        return {\r\n            object: target,\r\n            info: infoTree,\r\n        };\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\n\nimport type { TransformNode } from \"core/Meshes/transformNode\";\nimport type { IAnimation, ICamera, IGLTF, IKHRLightsPunctual_Light, IEXTLightsArea_Light, IMaterial, IMesh, INode } from \"../glTFLoaderInterfaces\";\nimport type { Vector3 } from \"core/Maths/math.vector\";\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport type { Color3 } from \"core/Maths/math.color\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\nimport type { Light } from \"core/Lights/light\";\nimport type { Nullable } from \"core/types\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport type { IEXTLightsImageBased_LightImageBased } from \"babylonjs-gltf2interface\";\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\nimport type { IInterpolationPropertyInfo, IObjectAccessor } from \"core/FlowGraph/typeDefinitions\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\nimport type { Mesh } from \"core/Meshes/mesh\";\nimport type { RectAreaLight } from \"core/Lights/rectAreaLight\";\n\nexport interface IGLTFObjectModelTree {\n    cameras: IGLTFObjectModelTreeCamerasObject;\n    nodes: IGLTFObjectModelTreeNodesObject;\n    materials: IGLTFObjectModelTreeMaterialsObject;\n    extensions: IGLTFObjectModelTreeExtensionsObject;\n    animations: {\n        length: IObjectAccessor<IAnimation[], AnimationGroup[], number>;\n        __array__: {};\n    };\n    meshes: {\n        length: IObjectAccessor<IMesh[], (Mesh | undefined)[], number>;\n        __array__: {};\n    };\n}\n\nexport interface IGLTFObjectModelTreeNodesObject<GLTFTargetType = INode, BabylonTargetType = TransformNode> {\n    length: IObjectAccessor<GLTFTargetType[], BabylonTargetType[], number>;\n    __array__: {\n        __target__: boolean;\n        translation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        rotation: IObjectAccessor<GLTFTargetType, BabylonTargetType, Quaternion>;\n        scale: IObjectAccessor<GLTFTargetType, BabylonTargetType, Vector3>;\n        matrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        globalMatrix: IObjectAccessor<GLTFTargetType, BabylonTargetType, Matrix>;\n        weights: {\n            length: IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n            __array__: { __target__: boolean } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number>;\n        } & IObjectAccessor<GLTFTargetType, BabylonTargetType, number[]>;\n        extensions: {\n            EXT_lights_ies?: {\n                multiplier: IObjectAccessor<INode, Light, number>;\n                color: IObjectAccessor<INode, Light, Color3>;\n            };\n            KHR_node_visibility?: {\n                visible: IObjectAccessor<INode, Mesh, boolean>;\n            };\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeCamerasObject {\n    __array__: {\n        __target__: boolean;\n        orthographic: {\n            xmag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            ymag: IObjectAccessor<ICamera, ICamera, Vector2>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n        };\n        perspective: {\n            yfov: IObjectAccessor<ICamera, ICamera, number>;\n            zfar: IObjectAccessor<ICamera, ICamera, number>;\n            znear: IObjectAccessor<ICamera, ICamera, number>;\n            aspectRatio: IObjectAccessor<ICamera, ICamera, Nullable<number>>;\n        };\n    };\n}\n\nexport interface IGLTFObjectModelTreeMaterialsObject {\n    __array__: {\n        __target__: boolean;\n        pbrMetallicRoughness: {\n            baseColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color4>;\n            metallicFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            roughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<number>>;\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: ITextureDefinition;\n                };\n            };\n        };\n        emissiveFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n        normalTexture: {\n            scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        occlusionTexture: {\n            strength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: ITextureDefinition;\n            };\n        };\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyRotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_clearcoat: {\n                clearcoatFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatNormalTexture: {\n                    scale: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_dispersion: {\n                dispersion: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_emissive_strength: {\n                emissiveStrength: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_ior: {\n                ior: IObjectAccessor<IMaterial, PBRMaterial, number>;\n            };\n            KHR_materials_iridescence: {\n                iridescenceFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceIor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMinimum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceThicknessMaximum: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_sheen: {\n                sheenColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                sheenRoughnessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_specular: {\n                specularFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                specularColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_transmission: {\n                transmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n                diffuseTransmissionColorFactor: IObjectAccessor<IMaterial, PBRMaterial, Nullable<Color3>>;\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n            KHR_materials_volume: {\n                thicknessFactor: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                attenuationColor: IObjectAccessor<IMaterial, PBRMaterial, Color3>;\n                attenuationDistance: IObjectAccessor<IMaterial, PBRMaterial, number>;\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: ITextureDefinition;\n                    };\n                };\n            };\n        };\n    };\n}\n\ninterface ITextureDefinition {\n    offset: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n    rotation: IObjectAccessor<IMaterial, PBRMaterial, number>;\n    scale: IObjectAccessor<IMaterial, PBRMaterial, Vector2>;\n}\n\nexport interface IGLTFObjectModelTreeMeshesObject {}\n\nexport interface IGLTFObjectModelTreeExtensionsObject {\n    KHR_lights_punctual: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n            __array__: {\n                __target__: boolean;\n                color: IObjectAccessor<IKHRLightsPunctual_Light, Light, Color3>;\n                intensity: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                range: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                spot: {\n                    innerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                    outerConeAngle: IObjectAccessor<IKHRLightsPunctual_Light, Light, number>;\n                };\n            };\n        };\n    };\n    EXT_lights_area: {\n        lights: {\n            length: IObjectAccessor<IEXTLightsArea_Light[], Light[], number>;\n            __array__: {\n                __target__: boolean;\n                color: IObjectAccessor<IEXTLightsArea_Light, Light, Color3>;\n                intensity: IObjectAccessor<IEXTLightsArea_Light, Light, number>;\n                size: IObjectAccessor<IEXTLightsArea_Light, Light, number>;\n                rect: {\n                    aspect: IObjectAccessor<IEXTLightsArea_Light, Light, number>;\n                };\n            };\n        };\n    };\n    EXT_lights_ies: {\n        lights: {\n            length: IObjectAccessor<IKHRLightsPunctual_Light[], Light[], number>;\n        };\n    };\n    EXT_lights_image_based: {\n        lights: {\n            __array__: {\n                __target__: boolean;\n                intensity: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, number>;\n                rotation: IObjectAccessor<IEXTLightsImageBased_LightImageBased, BaseTexture, Quaternion>;\n            };\n            length: IObjectAccessor<IEXTLightsImageBased_LightImageBased[], BaseTexture[], number>;\n        };\n    };\n}\n\nconst nodesTree: IGLTFObjectModelTreeNodesObject = {\n    length: {\n        type: \"number\",\n        get: (nodes: INode[]) => nodes.length,\n        getTarget: (nodes: INode[]) => nodes.map((node) => node._babylonTransformNode!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.position,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node: INode) => node._babylonTransformNode?.rotationQuaternion!,\n            set: (value: Quaternion, node: INode) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node: INode) => node._babylonTransformNode?.scaling,\n            set: (value: Vector3, node: INode) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node: INode) => node._numMorphTargets,\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node: INode, index?: number) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node: INode) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node: INode, index?: number) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node: INode) => Matrix.Compose(node._babylonTransformNode?.scaling!, node._babylonTransformNode?.rotationQuaternion!, node._babylonTransformNode?.position!),\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node: INode) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate =\n                    node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                } else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node: INode) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node: INode) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node: INode) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node: INode) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n            KHR_node_visibility: {\n                visible: {\n                    type: \"boolean\",\n                    get: (node: INode) => {\n                        return node._primitiveBabylonMeshes ? node._primitiveBabylonMeshes[0].isVisible : false;\n                    },\n                    getTarget: () => undefined, // TODO: what should this return?\n                    set: (value: boolean, node: INode) => {\n                        if (node._primitiveBabylonMeshes) {\n                            node._primitiveBabylonMeshes.forEach((mesh) => (mesh.isVisible = value));\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations: IAnimation[]) => animations.length,\n        getTarget: (animations: IAnimation[]) => animations.map((animation) => animation._babylonAnimationGroup!),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes: IMesh[]) => meshes.length,\n        getTarget: (meshes: IMesh[]) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\n\nconst camerasTree: IGLTFObjectModelTreeCamerasObject = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera: ICamera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value: Vector2, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.fov,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.maxZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera: ICamera) => camera._babylonCamera?.minZ,\n                set: (value: number, camera: ICamera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera: ICamera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\n\nconst materialsTree: IGLTFObjectModelTreeMaterialsObject = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value: Color3, material, index?, payload?) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value: number, material, index?, payload?) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value: number, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value: Color4, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index?, payload?) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index?, payload?) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value: number, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index?, payload?) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index?, payload?) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index?, payload?) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture!.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\n\nconst extensionsTree: IGLTFObjectModelTreeExtensionsObject = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse,\n                    set: (value: Color3, light: IKHRLightsPunctual_Light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.intensity,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light: IKHRLightsPunctual_Light) => light._babylonLight?.range,\n                    set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.innerAngle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).innerAngle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light: IKHRLightsPunctual_Light) => (light._babylonLight as SpotLight)?.angle,\n                        set: (value: number, light: IKHRLightsPunctual_Light) => (light._babylonLight ? ((light._babylonLight as SpotLight).angle = value) : undefined),\n                        getTarget: (light: IKHRLightsPunctual_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IKHRLightsPunctual_Light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_area: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IEXTLightsArea_Light[]) => lights.length,\n                getTarget: (lights: IEXTLightsArea_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IEXTLightsArea_Light[]) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light: IEXTLightsArea_Light) => light._babylonLight?.diffuse,\n                    set: (value: Color3, light: IEXTLightsArea_Light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light: IEXTLightsArea_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IEXTLightsArea_Light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light: IEXTLightsArea_Light) => light._babylonLight?.intensity,\n                    set: (value: number, light: IEXTLightsArea_Light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light: IEXTLightsArea_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IEXTLightsArea_Light) => \"intensity\"],\n                },\n                size: {\n                    type: \"number\",\n                    get: (light: IEXTLightsArea_Light) => (light._babylonLight as RectAreaLight)?.height,\n                    set: (value: number, light: IEXTLightsArea_Light) => (light._babylonLight ? ((light._babylonLight as RectAreaLight).height = value) : undefined),\n                    getTarget: (light: IEXTLightsArea_Light) => light._babylonLight,\n                    getPropertyName: [(_light: IEXTLightsArea_Light) => \"size\"],\n                },\n                rect: {\n                    aspect: {\n                        type: \"number\",\n                        get: (light: IEXTLightsArea_Light) => (light._babylonLight as RectAreaLight)?.width / (light._babylonLight as RectAreaLight)?.height,\n                        set: (value: number, light: IEXTLightsArea_Light) =>\n                            light._babylonLight ? ((light._babylonLight as RectAreaLight).width = value * (light._babylonLight as RectAreaLight).height) : undefined,\n                        getTarget: (light: IEXTLightsArea_Light) => light._babylonLight,\n                        getPropertyName: [(_light: IEXTLightsArea_Light) => \"aspect\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights: IKHRLightsPunctual_Light[]) => lights.length,\n                getTarget: (lights: IKHRLightsPunctual_Light[]) => lights.map((light) => light._babylonLight!),\n                getPropertyName: [(_lights: IKHRLightsPunctual_Light[]) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture!),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\n\nfunction GetTexture(material: IMaterial, payload: any, textureType: keyof PBRMaterial, textureInObject?: string) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material: IMaterial, _index?: number, payload?: any) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial as PBRMaterial;\n}\nfunction GenerateTextureMap(textureType: keyof PBRMaterial, textureInObject?: string): ITextureDefinition {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index?, payload?) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index?, payload?) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index?, payload?) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\n\nconst objectModelMapping: IGLTFObjectModelTree = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf: IGLTF) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key: string): IObjectAccessor | undefined {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key: string, interpolation?: IInterpolationPropertyInfo[]): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        (current as IObjectAccessor).interpolation = interpolation;\n    }\n}\n\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey<GLTFTargetType = any, BabylonTargetType = any, BabylonValueType = any>(\n    key: string,\n    accessor: IObjectAccessor<GLTFTargetType, BabylonTargetType, BabylonValueType>\n): void {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping as any;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n"],"names":["OptionalPathExceptionsList","regex","RegExp","GLTFPathToObjectConverter","_gltf","_infoTree","convert","path","target","objectTree","this","infoTree","startsWith","Error","parts","split","shift","length","includes","pop","push","ignoreObjectTree","part","isLength","__array__","__ignoreObjectTree__","undefined","find","e","test","__target__","object","info","GetTexture","material","payload","textureType","textureInObject","babylonMaterial","GetMaterial","_index","_data","fillMode","MATERIAL_TriangleFillMode","GenerateTextureMap","offset","componentsCount","type","get","texture","uOffset","vOffset","getTarget","set","value","x","y","getPropertyName","rotation","wAng","scale","uScale","vScale","index","objectModelMapping","cameras","orthographic","xmag","camera","_babylonCamera","orthoLeft","orthoRight","ymag","orthoBottom","orthoTop","zfar","maxZ","znear","minZ","perspective","aspectRatio","getEngine","getAspectRatio","isReadOnly","yfov","fov","nodes","map","node","_babylonTransformNode","translation","position","copyFrom","rotationQuaternion","scaling","weights","_numMorphTargets","_primitiveBabylonMeshes","morphTargetManager","influence","matrix","Compose","globalMatrix","Identity","rootNode","parent","forceUpdate","_isDirty","rootMatrix","computeWorldMatrix","invert","multiplyToRef","extensions","EXT_lights_ies","multiplier","getChildren","child","intensity","light","color","diffuse","KHR_node_visibility","visible","isVisible","forEach","mesh","materials","emissiveFactor","emissiveColor","emissiveTexture","KHR_texture_transform","normalTexture","level","occlusionTexture","strength","ambientTextureStrength","mat","pbrMetallicRoughness","baseColorFactor","FromColor3","albedoColor","alpha","r","g","b","a","baseColorTexture","metallicFactor","metallic","roughnessFactor","roughness","metallicRoughnessTexture","KHR_materials_anisotropy","anisotropyStrength","anisotropy","anisotropyRotation","angle","anisotropyTexture","KHR_materials_clearcoat","clearcoatFactor","clearCoat","clearcoatRoughnessFactor","clearcoatTexture","clearcoatNormalTexture","bumpTexture","clearcoatRoughnessTexture","KHR_materials_dispersion","dispersion","subSurface","KHR_materials_emissive_strength","emissiveStrength","emissiveIntensity","KHR_materials_ior","ior","indexOfRefraction","KHR_materials_iridescence","iridescenceFactor","iridescence","iridescenceIor","iridescenceTexture","iridescenceThicknessMaximum","maximumThickness","iridescenceThicknessMinimum","minimumThickness","iridescenceThicknessTexture","KHR_materials_sheen","sheenColorFactor","sheen","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","KHR_materials_specular","specularFactor","metallicF0Factor","specularColorFactor","metallicReflectanceColor","specularTexture","specularColorTexture","KHR_materials_transmission","transmissionFactor","refractionIntensity","transmissionTexture","KHR_materials_diffuse_transmission","diffuseTransmissionFactor","translucencyIntensity","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","diffuseTransmissionColorTexture","KHR_materials_volume","attenuationColor","tintColor","attenuationDistance","tintColorAtDistance","thicknessFactor","thicknessTexture","KHR_lights_punctual","lights","_babylonLight","_lights","_light","range","spot","innerConeAngle","innerAngle","outerConeAngle","EXT_lights_area","size","height","rect","aspect","width","EXT_lights_image_based","_babylonTexture","FromRotationMatrix","getReflectionTextureMatrix","getScene","useRightHandedSystem","Inverse","FromQuaternionToRef","animations","animation","_babylonAnimationGroup","meshes","primitives","_instanceData","babylonSourceMesh","GetPathToObjectConverter","gltf","GetMappingForKey","key","keyParts","replace","current","SetInterpolationForKey","interpolation","AddObjectAccessorToKey","accessor","Object","assign"],"ignoreList":[],"sourceRoot":""}