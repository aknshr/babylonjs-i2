{"version":3,"file":"3163.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/MSFT_lod.ts?"],"sourcesContent":["/* eslint-disable github/no-then */\r\nimport type { Nullable } from \"core/types\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { INode, IMaterial, IBuffer, IScene } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\r\nimport type { IProperty, IMSFTLOD } from \"babylonjs-gltf2interface\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\nconst NAME = \"MSFT_lod\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the MSFT_lod extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"MSFT_lod\"]: Partial<{\r\n            /**\r\n             * Maximum number of LODs to load, starting from the lowest LOD.\r\n             */\r\n            maxLODsToLoad: number;\r\n        }>;\r\n    }\r\n}\r\n\r\ninterface IBufferInfo {\r\n    start: number;\r\n    end: number;\r\n    loaded: Deferred<ArrayBufferView>;\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class MSFT_lod implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 100;\r\n\r\n    /**\r\n     * Maximum number of LODs to load, starting from the lowest LOD.\r\n     */\r\n    public maxLODsToLoad = 10;\r\n\r\n    /**\r\n     * Observable raised when all node LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onNodeLODsLoadedObservable = new Observable<number>();\r\n\r\n    /**\r\n     * Observable raised when all material LODs of one level are loaded.\r\n     * The event data is the index of the loaded LOD starting from zero.\r\n     * Dispose the loader to cancel the loading of the next level of LODs.\r\n     */\r\n    public onMaterialLODsLoadedObservable = new Observable<number>();\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    private _bufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _nodeIndexLOD: Nullable<number> = null;\r\n    private _nodeSignalLODs = new Array<Deferred<void>>();\r\n    private _nodePromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _nodeBufferLODs = new Array<IBufferInfo>();\r\n\r\n    private _materialIndexLOD: Nullable<number> = null;\r\n    private _materialSignalLODs = new Array<Deferred<void>>();\r\n    private _materialPromiseLODs = new Array<Array<Promise<any>>>();\r\n    private _materialBufferLODs = new Array<IBufferInfo>();\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        // Options takes precedence. The maxLODsToLoad extension property is retained for back compat.\r\n        // For new extensions, they should only use options.\r\n        this.maxLODsToLoad = this._loader.parent.extensionOptions[NAME]?.maxLODsToLoad ?? this.maxLODsToLoad;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n\r\n        this._nodeIndexLOD = null;\r\n        this._nodeSignalLODs.length = 0;\r\n        this._nodePromiseLODs.length = 0;\r\n        this._nodeBufferLODs.length = 0;\r\n\r\n        this._materialIndexLOD = null;\r\n        this._materialSignalLODs.length = 0;\r\n        this._materialPromiseLODs.length = 0;\r\n        this._materialBufferLODs.length = 0;\r\n\r\n        this.onMaterialLODsLoadedObservable.clear();\r\n        this.onNodeLODsLoadedObservable.clear();\r\n    }\r\n\r\n    /** @internal */\r\n    public onReady(): void {\r\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\r\n                    if (this._nodeSignalLODs[indexLOD]) {\r\n                        this._nodeSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n\r\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\r\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\r\n                if (indexLOD !== 0) {\r\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\r\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\r\n                }\r\n\r\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\r\n\r\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\r\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\r\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\r\n                    if (this._materialSignalLODs[indexLOD]) {\r\n                        this._materialSignalLODs[indexLOD].resolve();\r\n                    }\r\n                }\r\n            });\r\n\r\n            this._loader._completePromises.push(promise);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        const promise = this._loader.loadSceneAsync(context, scene);\r\n        this._loadBufferLOD(this._bufferLODs, 0);\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, TransformNode>(context, node, this.name, async (extensionContext, extension) => {\r\n            let firstPromise: Promise<TransformNode>;\r\n\r\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\r\n                const nodeLOD = nodeLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._nodeIndexLOD = indexLOD;\r\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\r\n                }\r\n\r\n                const assignWrap = (babylonTransformNode: TransformNode) => {\r\n                    assign(babylonTransformNode);\r\n                    babylonTransformNode.setEnabled(false);\r\n                };\r\n\r\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\r\n                    if (indexLOD !== 0) {\r\n                        // TODO: should not rely on _babylonTransformNode\r\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\r\n                        if (previousNodeLOD._babylonTransformNode) {\r\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\r\n                            delete previousNodeLOD._babylonTransformNode;\r\n                        }\r\n                    }\r\n\r\n                    babylonMesh.setEnabled(true);\r\n                    return babylonMesh;\r\n                });\r\n\r\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._nodeIndexLOD = null;\r\n                    this._nodePromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return await firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        // Don't load material LODs if already loading a node LOD.\r\n        if (this._nodeIndexLOD) {\r\n            return null;\r\n        }\r\n\r\n        return GLTFLoader.LoadExtensionAsync<IMSFTLOD, Material>(context, material, this.name, async (extensionContext, extension) => {\r\n            let firstPromise: Promise<Material>;\r\n\r\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\r\n            this._loader.logOpen(`${extensionContext}`);\r\n\r\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\r\n                const materialLOD = materialLODs[indexLOD];\r\n\r\n                if (indexLOD !== 0) {\r\n                    this._materialIndexLOD = indexLOD;\r\n                }\r\n\r\n                const promise = this._loader\r\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                        if (indexLOD === 0) {\r\n                            assign(babylonMaterial);\r\n                        }\r\n                    })\r\n                    .then((babylonMaterial) => {\r\n                        if (indexLOD !== 0) {\r\n                            assign(babylonMaterial);\r\n\r\n                            // TODO: should not rely on _data\r\n                            const previousDataLOD = materialLODs[indexLOD - 1]._data!;\r\n                            if (previousDataLOD[babylonDrawMode]) {\r\n                                this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\r\n                                delete previousDataLOD[babylonDrawMode];\r\n                            }\r\n                        }\r\n\r\n                        return babylonMaterial;\r\n                    });\r\n\r\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\r\n\r\n                if (indexLOD === 0) {\r\n                    firstPromise = promise;\r\n                } else {\r\n                    this._materialIndexLOD = null;\r\n                    this._materialPromiseLODs[indexLOD].push(promise);\r\n                }\r\n            }\r\n\r\n            this._loader.logClose();\r\n            return await firstPromise!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public _loadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        // Defer the loading of uris if loading a node or material LOD.\r\n        if (this._nodeIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._nodeIndexLOD - 1;\r\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(async () => {\r\n                return await this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        } else if (this._materialIndexLOD !== null) {\r\n            this._loader.log(`deferred`);\r\n            const previousIndexLOD = this._materialIndexLOD - 1;\r\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred<void>();\r\n            return this._materialSignalLODs[previousIndexLOD].promise.then(async () => {\r\n                return await this._loader.loadUriAsync(context, property, uri);\r\n            });\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\r\n            if (!this._loader.bin) {\r\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n            }\r\n\r\n            const loadAsync = async (bufferLODs: Array<IBufferInfo>, indexLOD: number) => {\r\n                const start = byteOffset;\r\n                const end = start + byteLength - 1;\r\n                let bufferLOD = bufferLODs[indexLOD];\r\n                if (bufferLOD) {\r\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\r\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\r\n                } else {\r\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\r\n                    bufferLODs[indexLOD] = bufferLOD;\r\n                }\r\n\r\n                return await bufferLOD.loaded.promise.then((data) => {\r\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\r\n                });\r\n            };\r\n\r\n            this._loader.log(`deferred`);\r\n\r\n            if (this._nodeIndexLOD !== null) {\r\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\r\n            } else if (this._materialIndexLOD !== null) {\r\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\r\n            } else {\r\n                return loadAsync(this._bufferLODs, 0);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _loadBufferLOD(bufferLODs: Array<IBufferInfo>, indexLOD: number): void {\r\n        const bufferLOD = bufferLODs[indexLOD];\r\n        if (bufferLOD) {\r\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\r\n            this._loader.bin!.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then(\r\n                (data) => {\r\n                    bufferLOD.loaded.resolve(data);\r\n                },\r\n                (error) => {\r\n                    bufferLOD.loaded.reject(error);\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns an array of LOD properties from lowest to highest.\r\n     * @param context\r\n     * @param property\r\n     * @param array\r\n     * @param ids\r\n     */\r\n    private _getLODs<T>(context: string, property: T, array: ArrayLike<T> | undefined, ids: number[]): T[] {\r\n        if (this.maxLODsToLoad <= 0) {\r\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\r\n        }\r\n\r\n        const properties: T[] = [];\r\n\r\n        for (let i = ids.length - 1; i >= 0; i--) {\r\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\r\n            if (properties.length === this.maxLODsToLoad) {\r\n                return properties;\r\n            }\r\n        }\r\n\r\n        properties.push(property);\r\n        return properties;\r\n    }\r\n\r\n    private _disposeTransformNode(babylonTransformNode: TransformNode): void {\r\n        const babylonMaterials: Material[] = [];\r\n        const babylonMaterial = (babylonTransformNode as Mesh).material;\r\n        if (babylonMaterial) {\r\n            babylonMaterials.push(babylonMaterial);\r\n        }\r\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\r\n            if (babylonMesh.material) {\r\n                babylonMaterials.push(babylonMesh.material);\r\n            }\r\n        }\r\n\r\n        babylonTransformNode.dispose();\r\n\r\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\r\n        this._disposeMaterials(babylonMaterialsToDispose);\r\n    }\r\n\r\n    private _disposeMaterials(babylonMaterials: Material[]): void {\r\n        const babylonTextures: { [uniqueId: number]: BaseTexture } = {};\r\n\r\n        for (const babylonMaterial of babylonMaterials) {\r\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\r\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\r\n            }\r\n\r\n            babylonMaterial.dispose();\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\r\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\r\n                    delete babylonTextures[uniqueId];\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const uniqueId in babylonTextures) {\r\n            babylonTextures[uniqueId].dispose();\r\n        }\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_lod(loader));\r\n"],"names":["NAME","MSFT_lod","constructor","loader","name","order","maxLODsToLoad","onNodeLODsLoadedObservable","onMaterialLODsLoadedObservable","_bufferLODs","Array","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","this","_loader","parent","extensionOptions","enabled","isExtensionUsed","dispose","length","clear","onReady","indexLOD","promise","Promise","all","then","endPerformanceCounter","log","notifyObservers","startPerformanceCounter","_loadBufferLOD","resolve","_completePromises","push","loadSceneAsync","context","scene","loadNodeAsync","node","assign","LoadExtensionAsync","async","extensionContext","extension","firstPromise","nodeLODs","_getLODs","gltf","nodes","ids","logOpen","nodeLOD","assignWrap","babylonTransformNode","setEnabled","index","babylonMesh","previousNodeLOD","_babylonTransformNode","_disposeTransformNode","logClose","_loadMaterialAsync","material","babylonDrawMode","materialLODs","materials","materialLOD","babylonMaterial","previousDataLOD","_data","_disposeMaterials","_loadUriAsync","property","uri","previousIndexLOD","loadUriAsync","loadBufferAsync","buffer","byteOffset","byteLength","useRangeRequests","bin","Error","loadAsync","bufferLODs","start","end","bufferLOD","Math","min","max","loaded","data","Uint8Array","readAsync","error","reject","array","properties","i","Get","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","filter","babylonScene","meshes","every","mesh","babylonTextures","babylonTexture","getActiveTextures","uniqueId","hasTexture"],"ignoreList":[],"sourceRoot":""}