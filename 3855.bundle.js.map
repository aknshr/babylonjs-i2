{"version":3,"file":"3855.bundle.js","mappings":"wZAgBO,MAAMA,EAwFT,oBAAWC,CAAiBC,GACpBA,EACAC,KAAKC,iBAELD,KAAKC,gBACDD,KAAKC,eAAiB,IACtBD,KAAKC,cAAgB,EAErBD,KAAKE,mBAAmBF,KAAKG,0BAC7BH,KAAKG,0BAA2B,GAG5C,CAEA,oBAAWL,GACP,OAAOE,KAAKC,cAAgB,CAChC,CAMA,YAAmBG,EAAyB,MAOxC,GAzGI,KAAAC,SAAW,IAAIC,MACf,KAAAC,iCAAmC,IAAID,MACvC,KAAAE,kCAAoC,IAAIF,MACxC,KAAAG,eAAiB,IAAI,IAAwB,IAG7C,KAAAC,oBAAqB,EACrB,KAAAC,kBAAmB,EACnB,KAAAC,mBAAoB,EACpB,KAAAC,cAAe,EACf,KAAAC,eAAgB,EAChB,KAAAC,iBAAkB,EAClB,KAAAC,aAAe,EACf,KAAAC,UAAY,EACZ,KAAAC,gBAAkB,IAAIZ,MACtB,KAAAa,0BAA2B,EAC3B,KAAAlB,cAAgB,EAChB,KAAAmB,kBAAmB,EACnB,KAAAjB,0BAA2B,EAG5B,KAAAkB,qBAAuB,EAGvB,KAAAC,cAAgB,EAGhB,KAAAC,eAAiB,EAMjB,KAAAC,iBAA8C,KAQ9C,KAAAC,qBAAsB,EAKtB,KAAAC,wBAAyB,EAKzB,KAAAC,sBAAuB,EAKvB,KAAAC,uBAAwB,EAKxB,KAAAC,kBAAmB,EAKnB,KAAAC,mBAAoB,EAKpB,KAAAC,qBAAsB,EA6CrB,KAAAC,mBAAqB,EAyJrB,KAAAC,2BAA4B,EAiC7B,KAAAC,SAAgB,KAsCf,KAAAC,qBAAsB,EACtB,KAAAC,uBAAwB,EAlPvBhC,IACDA,EAAQ,IAAYiC,kBAGxBrC,KAAKsC,OAASlC,EAEVJ,KAAKsC,OAAQ,CACbtC,KAAKsC,OAAOC,sBAAsBvC,MAElCA,KAAKiB,UAAYjB,KAAKsC,OAAOE,cAE7B,MAAMC,EAAazC,KAAKsC,OAAOI,YAAYC,UAC3C3C,KAAKmB,yBACDsB,EAAWG,kBAAoBH,EAAWI,cAAgBJ,EAAWK,2BAA6B,GAAKL,EAAWM,4BAA8B,CACxJ,CACJ,CAaA,qBAAWC,GACP,OAAInD,EAAmBoD,kCAAoC,GAAKjD,KAAKkD,yBAC1DrD,EAAmBoD,kCAEvBjD,KAAKgC,kBAChB,CAEA,qBAAWgB,CAAkBG,GACrBnD,KAAKgC,qBAAuBmB,IAIhCnD,KAAKgC,mBAAqBmB,EAC1BnD,KAAKoB,kBAAmB,EACxBpB,KAAKE,qBACT,CAKA,YAAWkD,GACP,OAAOpD,KAAKiB,SAChB,CAKA,eAAWoC,GACP,OAAOrD,KAAKgB,YAChB,CAKA,qBAAWsC,GACP,OAAOtD,KAAKU,oBAAsBV,KAAK0B,sBAC3C,CAKA,mBAAW6B,GACP,OAAOvD,KAAKW,kBAAoBX,KAAK2B,oBACzC,CAKA,oBAAW6B,GACP,OAAOxD,KAAKY,mBAAqBZ,KAAK4B,qBAC1C,CAKA,eAAW6B,GACP,OAAOzD,KAAKa,cAAgBb,KAAK6B,gBACrC,CAKA,gBAAW6B,GACP,OAAO1D,KAAKc,eAAiBd,KAAK8B,iBACtC,CAKA,kBAAW6B,GACP,OAAO3D,KAAKe,iBAAmBf,KAAK+B,mBACxC,CAKA,gBAAW6B,GACP,OAAO5D,KAAKU,kBAChB,CAKA,cAAWmD,GACP,OAAO7D,KAAKW,gBAChB,CAKA,eAAWmD,GACP,OAAO9D,KAAKY,iBAChB,CAKA,UAAWmD,GACP,OAAO/D,KAAKa,YAChB,CAKA,WAAWmD,GACP,OAAOhE,KAAKc,aAChB,CAKA,aAAWmD,GACP,OAAOjE,KAAKe,eAChB,CAKA,cAAWmD,GACP,OAAOlE,KAAKK,SAAS8D,MACzB,CAKA,kBAAWC,GAIP,OAHIpE,KAAKmC,qBACLnC,KAAKE,qBAEFF,KAAKS,eAAe0D,MAC/B,CAKA,cAAWE,GAIP,OAHIrE,KAAKmC,qBACLnC,KAAKE,qBAEFF,KAAKsE,WAChB,CAOA,4BAAWC,GACP,OAAOvE,KAAKiC,yBAChB,CAEA,4BAAWsC,CAAyBpB,GAC5BnD,KAAKiC,4BAA8BkB,IAGvCnD,KAAKiC,0BAA4BkB,EACjCnD,KAAKoB,kBAAmB,EACxBpB,KAAKE,qBACT,CAKA,4BAAWgD,GACP,OACIrD,EAAmB2E,sBACnBxE,KAAKuE,0BACLvE,KAAKmB,2BACJnB,KAAKsC,QAAQI,YAAYC,UAAU8B,yBAE5C,CAYO,eAAAC,CAAgBC,GAInB,OAHI3E,KAAKmC,qBACLnC,KAAKE,qBAEFF,KAAKS,eAAemE,KAAKD,EACpC,CAOO,SAAAE,CAAUF,GACb,OAAO3E,KAAKK,SAASsE,EACzB,CAOO,eAAAG,CAAgBC,GACnB,IAAK,MAAMC,KAAUhF,KAAKK,SACtB,GAAI2E,EAAOD,OAASA,EAChB,OAAOC,EAIf,OAAO,IACX,CASO,SAAAC,CAAUD,GACbhF,KAAKK,SAAS6E,KAAKF,GACnBhF,KAAKO,iCAAiC2E,KAClCF,EAAOG,mBAAmBC,KAAKC,IACvBrF,KAAKF,kBAAoBuF,IACzBrF,KAAKG,0BAA2B,GAEpCH,KAAKmC,qBAAsB,EAC3BnC,KAAKoC,sBAAwBpC,KAAKoC,uBAAyBiD,MAGnErF,KAAKQ,kCAAkC0E,KACnCF,EAAOM,qBAAqBF,KAAI,KAC5BpF,KAAKoB,kBAAmB,EACxBpB,KAAKE,yBAGbF,KAAKoB,kBAAmB,EACxBpB,KAAKE,oBACT,CAMO,YAAAqF,CAAaP,GAChB,MAAML,EAAQ3E,KAAKK,SAASmF,QAAQR,GAChCL,GAAS,IACT3E,KAAKK,SAASoF,OAAOd,EAAO,GAE5BK,EAAOG,mBAAmBO,OAAO1F,KAAKO,iCAAiCkF,OAAOd,EAAO,GAAG,IACxFK,EAAOM,qBAAqBI,OAAO1F,KAAKQ,kCAAkCiF,OAAOd,EAAO,GAAG,IAC3F3E,KAAKoB,kBAAmB,EACxBpB,KAAKE,sBAGLF,KAAKsC,QACLtC,KAAKsC,OAAOqD,cAAcX,EAElC,CAKO,KAAAY,CAAMC,GACL7F,KAAKmC,qBACLnC,KAAKE,qBAET2F,EAAOC,UAAU,yBAA0B9F,KAAKqB,qBAAsBrB,KAAKsB,cAAetB,KAAKuB,gBAC/FsE,EAAOE,cAAc,4BAA6B/F,KAAKgG,4BACvDH,EAAOI,WAAW,eAAgBjG,KAAKkG,qBACvCL,EAAOM,SAAS,mBAAoBnG,KAAKoE,eAC7C,CAMO,KAAAgC,GACH,MAAMC,EAAO,IAAIxG,EAAmBG,KAAKsC,QACzC+D,EAAKvG,kBAAmB,EAExB,IAAK,MAAMkF,KAAUhF,KAAKK,SACtBgG,EAAKpB,UAAUD,EAAOoB,SAY1B,OAVAC,EAAKvG,kBAAmB,EAExBuG,EAAK3E,uBAAyB1B,KAAK0B,uBACnC2E,EAAK1E,qBAAuB3B,KAAK2B,qBACjC0E,EAAKzE,sBAAwB5B,KAAK4B,sBAClCyE,EAAKxE,iBAAmB7B,KAAK6B,iBAC7BwE,EAAKvE,kBAAoB9B,KAAK8B,kBAC9BuE,EAAKtE,oBAAsB/B,KAAK+B,oBAChCsE,EAAKnE,SAAWlC,KAAKkC,SAEdmE,CACX,CAMO,SAAAC,GACH,MAAMC,EAA2B,CAAC,EAElCA,EAAoBC,GAAKxG,KAAKoD,SAE9BmD,EAAoBE,QAAU,GAC9B,IAAK,MAAMzB,KAAUhF,KAAKK,SACtBkG,EAAoBE,QAAQvB,KAAKF,EAAOsB,aAO5C,OAJItG,KAAKkC,WACLqE,EAAoBrE,SAAWlC,KAAKkC,UAGjCqE,CACX,CAEQ,kBAAArG,CAAmBmF,GAAa,GACpC,GAAIrF,KAAKF,iBACL,OAGJuF,EAAaA,GAAcrF,KAAKoC,sBAEhCpC,KAAKoC,uBAAwB,EAC7BpC,KAAKmC,qBAAsB,EAE3B,MAAMuE,IAA8B1G,KAAKkG,oBACnChD,EAA2BlD,KAAKkD,0BAElClD,KAAKoB,kBAAoBsF,IAA8BxD,KACvDlD,KAAKoB,kBAAmB,EACxBpB,KAAK2G,eAGT,IAAIC,EAAiB,EACrB5G,KAAKS,eAAeoG,QAEf7G,KAAKgG,4BAA8BhG,KAAKgG,2BAA2B7B,SAAWnE,KAAKK,SAAS8D,SAC7FnE,KAAKgG,2BAA6B,IAAIc,aAAa9G,KAAKK,SAAS8D,SAGrE,IAAI4C,GAAe,EACnB,IAAK,MAAM/B,KAAUhF,KAAKK,SAEtB,GADA0G,IACyB,IAArB/B,EAAOgC,YAAmBhH,KAAKyB,oBAAnC,CAIA,GAAIzB,KAAKS,eAAe0D,QAAUtE,EAAmBoH,6CAA+CjH,KAAKkD,yBACrG,MAGJlD,KAAKS,eAAeyE,KAAKF,GACzBhF,KAAKgG,2BAA2BY,GAAkBG,EAClD/G,KAAKkB,gBAAgB0F,KAAoB5B,EAAOgC,SARhD,CAWAhH,KAAKgG,2BAA2B7B,SAAWyC,IAC3C5G,KAAKgG,2BAA6BhG,KAAKgG,2BAA2BkB,MAAM,EAAGN,IAG1E5G,KAAKsE,aAAetE,KAAKsE,YAAYH,SAAWyC,IACjD5G,KAAKsE,YAAc,IAAIwC,aAAaF,IAGxC,IAAK,IAAIjC,EAAQ,EAAGA,EAAQiC,EAAgBjC,IACxC3E,KAAKsE,YAAYK,GAAS3E,KAAKkB,gBAAgByD,GAGnD,GAAIU,GAAcrF,KAAKsC,OACnB,IAAK,MAAM6E,KAAQnH,KAAKsC,OAAO8E,OACjBD,EAAME,qBAAuBrH,OAC/BkD,EACAiE,EAAKG,kCAEEH,EAAMI,sCAKjC,CAKO,WAAAZ,GACH,IAAK3G,KAAKsC,QAAUtC,KAAKF,iBACrB,OAGJ,MAAM0H,EAASxH,KAAKsC,OAAOI,YAE3B1C,KAAKU,oBAAqB,EAC1BV,KAAKW,kBAAmB,EACxBX,KAAKY,mBAAoB,EACzBZ,KAAKa,cAAe,EACpBb,KAAKc,eAAgB,EACrBd,KAAKe,iBAAkB,EACvBf,KAAKgB,aAAe,EAEpBhB,KAAKkG,qBAAqBuB,UAC1BzH,KAAKkG,oBAAsB,KAEvBlG,KAAKkD,0BAA4BlD,KAAKK,SAAS8D,OAASqD,EAAO7E,UAAUI,8BACzE/C,KAAKuE,0BAA2B,GAGpC,IAAK,MAAMS,KAAUhF,KAAKK,SAAU,CAChCL,KAAKU,mBAAqBV,KAAKU,oBAAsBsE,EAAOpB,aAC5D5D,KAAKW,iBAAmBX,KAAKW,kBAAoBqE,EAAOnB,WACxD7D,KAAKY,kBAAoBZ,KAAKY,mBAAqBoE,EAAOlB,YAC1D9D,KAAKa,aAAeb,KAAKa,cAAgBmE,EAAOjB,OAChD/D,KAAKc,cAAgBd,KAAKc,eAAiBkE,EAAOhB,QAClDhE,KAAKe,gBAAkBf,KAAKe,iBAAmBiE,EAAOf,UAEtD,MAAMZ,EAAc2B,EAAO3B,YAC3B,GAA0B,IAAtBrD,KAAKgB,aACLhB,KAAKgB,aAAeqC,OACjB,GAAIrD,KAAKgB,eAAiBqC,EAI7B,YAHA,IAAOqE,MACH,6FAA6F1H,KAAKgB,0CAA0CgE,EAAOD,UAAU1B,IAIzK,CAEA,GAAIrD,KAAKkD,yBAA0B,CAC/BlD,KAAKqB,qBAAuB,EAE5BrB,KAAKU,oBAAsBV,KAAKqB,uBAChCrB,KAAKW,kBAAoBX,KAAKqB,uBAC9BrB,KAAKY,mBAAqBZ,KAAKqB,uBAC/BrB,KAAKa,cAAgBb,KAAKqB,uBAC1BrB,KAAKc,eAAiBd,KAAKqB,uBAC3BrB,KAAKe,iBAAmBf,KAAKqB,uBAE7BrB,KAAKsB,cAAgBtB,KAAKgB,aAAehB,KAAKqB,sBAAwB,EACtErB,KAAKuB,eAAiB,EAEtB,MAAMoG,EAAiBH,EAAO7E,UAAUgF,eACpC3H,KAAKsB,cAAgBqG,IACrB3H,KAAKuB,eAAiBqG,KAAKC,KAAK7H,KAAKsB,cAAgBqG,GACrD3H,KAAKsB,cAAgBqG,GAGzB,MAAMG,EAAc9H,KAAKK,SAAS8D,OAC5BS,EAAO,IAAIkC,aAAagB,EAAc9H,KAAKsB,cAAgBtB,KAAKuB,eAAiB,GAEvF,IAAIwG,EAAS,EACb,IAAK,IAAIpD,EAAQ,EAAGA,EAAQmD,EAAanD,IAAS,CAC9C,MAAMK,EAAShF,KAAKK,SAASsE,GAEvBqD,EAAYhD,EAAOiD,eACnBC,EAAUlD,EAAOmD,aACjBC,EAAMpD,EAAOqD,SACbC,EAAWtD,EAAOuD,cAClBC,EAAOxD,EAAOyD,UACdC,EAAS1D,EAAO2D,YAEtBZ,EAASpD,EAAQ3E,KAAKsB,cAAgBtB,KAAKuB,eAAiB,EAC5D,IAAK,IAAIqH,EAAS,EAAGA,EAAS5I,KAAKgB,aAAc4H,IACzC5I,KAAKU,oBAAsBsH,IAC3BpD,EAAKmD,GAAUC,EAAmB,EAATY,GACzBhE,EAAKmD,EAAS,GAAKC,EAAmB,EAATY,EAAa,GAC1ChE,EAAKmD,EAAS,GAAKC,EAAmB,EAATY,EAAa,GAC1Cb,GAAU,GAGV/H,KAAKW,kBAAoBuH,IACzBtD,EAAKmD,GAAUG,EAAiB,EAATU,GACvBhE,EAAKmD,EAAS,GAAKG,EAAiB,EAATU,EAAa,GACxChE,EAAKmD,EAAS,GAAKG,EAAiB,EAATU,EAAa,GACxCb,GAAU,GAGV/H,KAAKa,cAAgBuH,IACrBxD,EAAKmD,GAAUK,EAAa,EAATQ,GACnBhE,EAAKmD,EAAS,GAAKK,EAAa,EAATQ,EAAa,GACpCb,GAAU,GAGV/H,KAAKY,mBAAqB0H,IAC1B1D,EAAKmD,GAAUO,EAAkB,EAATM,GACxBhE,EAAKmD,EAAS,GAAKO,EAAkB,EAATM,EAAa,GACzChE,EAAKmD,EAAS,GAAKO,EAAkB,EAATM,EAAa,GACzCb,GAAU,GAGV/H,KAAKc,eAAiB0H,IACtB5D,EAAKmD,GAAUS,EAAc,EAATI,GACpBhE,EAAKmD,EAAS,GAAKS,EAAc,EAATI,EAAa,GACrCb,GAAU,GAGV/H,KAAKe,iBAAmB2H,IACxB9D,EAAKmD,GAAUW,EAAgB,EAATE,GACtBhE,EAAKmD,EAAS,GAAKW,EAAgB,EAATE,EAAa,GACvChE,EAAKmD,EAAS,GAAKW,EAAgB,EAATE,EAAa,GACvChE,EAAKmD,EAAS,GAAKW,EAAgB,EAATE,EAAa,GACvCb,GAAU,EAGtB,CAEA/H,KAAKkG,oBAAsB,IAAkB2C,kBACzCjE,EACA5E,KAAKsB,cACLtB,KAAKuB,eACLuG,EACA9H,KAAKsC,QACL,GACA,EACA,IAAUwG,6BACV,IAAUC,mBAEd/I,KAAKkG,oBAAoBnB,KAAO,iBAAiB/E,KAAKoD,UAC1D,CAGA,IAAK,MAAM+D,KAAQnH,KAAKsC,OAAO8E,OACjBD,EAAME,qBAAuBrH,MAC5BmH,EAAMI,qCAGzB,CAKO,OAAAE,GASH,GARIzH,KAAKkG,qBACLlG,KAAKkG,oBAAoBuB,UAG7BzH,KAAKkG,oBAAsB,KAC3BlG,KAAKkC,SAAW,KAGZlC,KAAKsC,OAAQ,CAGb,GAFAtC,KAAKsC,OAAO0G,yBAAyBhJ,MAEjCA,KAAKwB,iBAAkB,CACvB,MAAMmD,EAAQ3E,KAAKwB,iBAAiByH,oBAAoBzD,QAAQxF,MAC5D2E,GAAS,GACT3E,KAAKwB,iBAAiByH,oBAAoBxD,OAAOd,EAAO,GAE5D3E,KAAKwB,iBAAmB,IAC5B,CAEA,IAAK,MAAM0H,KAASlJ,KAAKK,SACrBL,KAAKsC,OAAOqD,cAAcuD,EAElC,CACJ,CAUO,YAAOC,CAAM5C,EAA0BnG,GAC1C,MAAMgJ,EAAS,IAAIvJ,EAAmBO,GAEtC,IAAK,MAAMiJ,KAAc9C,EAAoBE,QACzC2C,EAAOnE,UAAU,EAAAqE,EAAYH,MAAME,EAAYjJ,IAOnD,OAJImG,EAAoBrE,WACpBkH,EAAOlH,SAAWqE,EAAoBrE,UAGnCkH,CACX,EA3sBc,EAAA5E,sBAAuB,EAGvB,EAAAyC,2CAA6C,EAK7C,EAAAhE,kCAAoC,E,+CCH/C,MAAMsG,EAkBT,WAAAC,CAAYC,GATL,KAAAC,WAAa,EAUhB1J,KAAKyJ,OAASA,CAClB,CAOO,eAAME,CAAUC,GACnB,MAAMhF,QAAa5E,KAAKyJ,OAAOI,UAAU7J,KAAK0J,WAAYE,GAC1D5J,KAAK8J,UAAY,IAAIC,SAASnF,EAAK6E,OAAQ7E,EAAK8E,WAAY9E,EAAKgF,YACjE5J,KAAKgK,gBAAkB,CAC3B,CAMO,UAAAC,GACH,MAAM9G,EAAQnD,KAAK8J,UAAUI,UAAUlK,KAAKgK,iBAAiB,GAG7D,OAFAhK,KAAKgK,iBAAmB,EACxBhK,KAAK0J,YAAc,EACZvG,CACX,CAOO,cAAAgH,CAAeP,GAClB,MAAMzG,EAAQ,IAAIiH,WAAWpK,KAAK8J,UAAUL,OAAQzJ,KAAK8J,UAAUJ,WAAa1J,KAAKgK,gBAAiBJ,GAGtG,OAFA5J,KAAKgK,iBAAmBJ,EACxB5J,KAAK0J,YAAcE,EACZzG,CACX,CAOO,UAAAkH,CAAWT,GACd,OAAO,QAAO5J,KAAKmK,eAAeP,GACtC,CAMO,SAAAU,CAAUV,GACb5J,KAAKgK,iBAAmBJ,EACxB5J,KAAK0J,YAAcE,CACvB,EChFJ,SAASW,EACL3F,EACA4F,EACAC,EACAC,GAEA,MAAMC,EAAwC,CAC1CC,yBAA0BF,GAO9B,OAJID,IACAE,EAAQE,IAAkB,UAAZL,EAAsBC,EAAWD,EAAUC,GAGtDK,YAAYC,OAAOnG,GAAQoG,cAAcC,cAAcrG,EAAM+F,GAAWK,cAAcE,eAAetG,EAAM+F,EACtH,CAKA,SAASQ,IACL,MAAMC,EAAmG,GAEzGC,UAAaC,IACT,MAAM1G,EAAO0G,EAAQ1G,KACrB,OAAQA,EAAK4B,IACT,IAAK,OACD+E,cAAc3G,EAAK4G,KACnB,MAEJ,IAAK,WACDjB,EACI3F,EAAKA,KACLA,EAAK4F,QACL5F,EAAK6F,UACJI,GACG,IAAIY,SAAQ,CAACC,EAASC,KAClB,MAAMhH,EAAQyG,EAAyBjH,OACvCiH,EAAyBlG,KAAK,CAAEwG,UAASC,WACzCC,YAAY,CAAEpF,GAAI,sBAAuB7B,MAAOA,EAAOkG,IAAKA,SAEtEgB,MACG1I,IACGyI,YAAY,CAAEpF,GAAI,mBAAoBrD,MAAOA,OAEhD2I,IACGF,YAAY,CAAEpF,GAAI,kBAAmBsF,OAAQA,OAGrD,MAEJ,IAAK,8BACDV,EAAyBxG,EAAKD,OAAO+G,QAAQ9G,EAAKzB,OAClD,MAEJ,IAAK,6BACDiI,EAAyBxG,EAAKD,OAAOgH,OAAO/G,EAAKkH,SAKjE,CAeO,MAAMC,EAkBF,oBAAOxB,CACV3F,EACA4F,EACAC,EACAC,GAEA,MAAsB,mBAAXsB,OACA,IAAIP,SAAQ,CAACC,EAASC,KACzB,MAAMM,EAAgB,GAAG1B,KAAiBY,OACpCe,EAAgBC,IAAIC,gBAAgB,IAAIC,KAAK,CAACJ,GAAgB,CAAEK,KAAM,4BACtEC,EAAS,IAAIP,OAAOE,GAEpBM,EAAWC,IACbF,EAAOG,oBAAoB,QAASF,GACpCD,EAAOG,oBAAoB,UAAWC,GAEtChB,EAAOc,IAGLE,EAAarB,IACf,MAAM1G,EAAO0G,EAAQ1G,KACrB,OAAQA,EAAK4B,IACT,IAAK,sBACDkE,EAAoB9F,EAAKiG,KAAKgB,MACzB1I,IACGoJ,EAAOX,YAAY,CAAEpF,GAAI,8BAA+B7B,MAAOC,EAAKD,MAAOxB,MAAOA,GAAS,CAACA,EAAMsG,YAErGqC,IACGS,EAAOX,YAAY,CAAEpF,GAAI,6BAA8B7B,MAAOC,EAAKD,MAAOmH,OAAQA,OAG1F,MAEJ,IAAK,mBACDS,EAAOG,oBAAoB,QAASF,GACpCD,EAAOG,oBAAoB,UAAWC,GACtCjB,EAAQ9G,EAAKzB,OACboJ,EAAOK,YACP,MAEJ,IAAK,kBACDL,EAAOG,oBAAoB,QAASF,GACpCD,EAAOG,oBAAoB,UAAWC,GAEtChB,EAAO/G,EAAKkH,QACZS,EAAOK,cAUnB,GALAL,EAAOM,iBAAiB,QAASL,GACjCD,EAAOM,iBAAiB,UAAWF,GAEnCJ,EAAOX,YAAY,CAAEpF,GAAI,OAAQgF,IAAK,KAAMsB,oBAAoB9M,KAAK+M,cAAcvB,OAE/EV,YAAYC,OAAOnG,GAAO,CAE1B,MAAMoI,EAAapI,EAAKsC,QACxBqF,EAAOX,YAAY,CAAEpF,GAAI,WAAY5B,KAAMoI,EAAYxC,QAASA,EAASC,SAAUA,GAAY,CAACuC,EAAWvD,QAC/G,MACI8C,EAAOX,YAAY,CAAEpF,GAAI,WAAY5B,KAAMA,EAAM4F,QAASA,EAASC,SAAUA,QAIhFzK,KAAKiN,qBACNjN,KAAKiN,mBAAqB,KAAMC,uBAAuBlN,KAAK+M,cAAcvB,MAGvExL,KAAKiN,mBAAmBpB,MAAK,IACzBtB,EAAc3F,EAAM4F,EAASC,EAAUC,KAG1D,EAtFc,EAAAqC,cAA8C,CACxDvB,IAAK,GAAG,KAAM2B,oC,ICfVC,EAeAC,EAwDAC,E,iCAlGZ,SAASzD,EAAU0D,EAA0B7D,EAAoBE,GAC7D,IACI,OAAO6B,QAAQC,QAAQ,IAAItB,WAAWmD,EAAa7D,EAAYE,GACnE,CAAE,MAAO4D,GACL,OAAO/B,QAAQE,OAAO6B,EAC1B,CACJ,EAqBA,SAAYJ,GAIR,mBAKA,8CACH,CAVD,CAAYA,IAAAA,EAA8B,KAe1C,SAAYC,GAIR,mBAKA,qBAKA,gBACH,CAfD,CAAYA,IAAAA,EAA4B,KAwDxC,SAAYC,GAIR,yBAKA,qBAKA,0BACH,CAfD,CAAYA,IAAAA,EAAe,KAiD3B,MAAMG,EAAN,cAIW,KAAAC,0BAA2B,EAM3B,KAAAC,+BAAgC,EAKhC,KAAAC,mBAAqBP,EAA6BQ,MAKlD,KAAAC,kBAAmB,EAKnB,KAAAC,yBAA0B,EAK1B,KAAAC,qBAAuBZ,EAA+Ba,KAKtD,KAAAC,iBAAkB,EAKlB,KAAAC,kBAAmB,EAKnB,KAAAC,kBAAmB,EAMnB,KAAAC,oBAAqB,EAKrB,KAAAC,mBAAoB,EAKpB,KAAAC,WAAY,EAKZ,KAAAC,eAAgB,EAKhB,KAAAC,UAAY,GAOZ,KAAAC,wBAAyB,EAKzB,KAAAC,cAAe,EAMf,KAAAC,qBAAsB,EAOtB,KAAAC,kBAAmB,EAKnB,KAAAC,gBAAiB,EAKjB,KAAAC,UAAW,EAMX,KAAAC,YAAa,EAKb,KAAAC,2BAA4B,CACvC,EAOO,MAAMC,EAA2B,IAAIzB,EAE5C,MAAe0B,UAA0B1B,EAAzC,c,oBAoEW,KAAA2B,iBAOH,CAAC,EA4CE,KAAAC,mBAAsB7D,GAAgBC,QAAQC,QAAQF,EACjE,CAtHc,QAAA8D,CAAS3E,GACXA,IACA3K,KAAK0N,yBAA2B/C,EAAQ+C,0BAA4B1N,KAAK0N,yBACzE1N,KAAK2N,8BAAgChD,EAAQgD,+BAAiC3N,KAAK2N,8BACnF3N,KAAK4N,mBAAqBjD,EAAQiD,oBAAsB5N,KAAK4N,mBAC7D5N,KAAKuP,2BAA6B5E,EAAQ4E,4BAA8BvP,KAAKuP,2BAC7EvP,KAAK8N,iBAAmBnD,EAAQmD,kBAAoB9N,KAAK8N,iBACzD9N,KAAK+N,wBAA0BpD,EAAQoD,yBAA2B/N,KAAK+N,wBACvE/N,KAAKgO,qBAAuBrD,EAAQqD,sBAAwBhO,KAAKgO,qBACjEhO,KAAKkO,gBAAkBvD,EAAQuD,iBAAmBlO,KAAKkO,gBACvDlO,KAAKwP,eAAiB7E,EAAQ6E,eAC9BxP,KAAKoP,iBAAmBzE,EAAQyE,kBAAoBpP,KAAKoP,iBACzDpP,KAAKmO,iBAAmBxD,EAAQwD,kBAAoBnO,KAAKmO,iBACzDnO,KAAKoO,iBAAmBzD,EAAQyD,kBAAoBpO,KAAKoO,iBACzDpO,KAAKqO,mBAAqB1D,EAAQ0D,oBAAsBrO,KAAKqO,mBAC7DrO,KAAKsO,kBAAoB3D,EAAQ2D,mBAAqBtO,KAAKsO,kBAC3DtO,KAAKuO,UAAY5D,EAAQ4D,WAAavO,KAAKuO,UAC3CvO,KAAKyP,eAAiB9E,EAAQ8E,gBAAkBzP,KAAKyP,eACrDzP,KAAK0P,eAAiB/E,EAAQ+E,eAC9B1P,KAAK2P,iBAAmBhF,EAAQgF,iBAChC3P,KAAK4P,aAAejF,EAAQiF,aAC5B5P,KAAK6P,SAAWlF,EAAQkF,SACxB7P,KAAK8P,aAAenF,EAAQmF,aAC5B9P,KAAK+P,gBAAkBpF,EAAQoF,gBAC/B/P,KAAKgQ,YAAcrF,EAAQqF,YAC3BhQ,KAAKqP,mBAAqB1E,EAAQ0E,oBAAsBrP,KAAKqP,mBAC7DrP,KAAKwO,cAAgB7D,EAAQ6D,eAAiBxO,KAAKwO,cACnDxO,KAAKyO,UAAY9D,EAAQ8D,WAAazO,KAAKyO,UAC3CzO,KAAK0O,uBAAyB/D,EAAQ+D,wBAA0B1O,KAAK0O,uBACrE1O,KAAK2O,aAAehE,EAAQgE,cAAgB3O,KAAK2O,aACjD3O,KAAK4O,oBAAsBjE,EAAQiE,qBAAuB5O,KAAK4O,oBAC/D5O,KAAKgP,WAAarE,EAAQqE,YAAchP,KAAKgP,WAC7ChP,KAAK6O,iBAAmBlE,EAAQkE,kBAAoB7O,KAAK6O,iBACzD7O,KAAK8O,eAAiBnE,EAAQmE,gBAAkB9O,KAAK8O,eACrD9O,KAAK+O,SAAWpE,EAAQoE,UAAY/O,KAAK+O,SACzC/O,KAAKiP,0BAA4BtE,EAAQsE,2BAA6BjP,KAAKiP,0BAEnF,EAsFG,MAAMgB,UAAuBd,EAWhC,YAAmBxE,GACfuF,QAWG,KAAAC,mBAAqB,IAAI,KA+ChB,KAAAC,uBAAyB,IAAI,KAuB7B,KAAAC,uBAAyB,IAAI,KAoB7B,KAAAC,0BAA4B,IAAI,KAmBhC,KAAAC,2BAA6B,IAAI,KAmBjC,KAAAC,yBAA2B,IAAI,KAqB/B,KAAAC,qBAAuB,IAAI,KAmB3B,KAAAC,kBAAoB,IAAI,KAiBxB,KAAAC,oBAAsB,IAAI,KAkB1B,KAAAC,4BAA8B,IAAI,KA6DlC,KAAAC,sBAAwB,IAAI,KAcpC,KAAAC,QAAiC,KACjC,KAAAC,OAAoC,KAEpC,KAAAC,UAAY,IAAI1Q,MAKR,KAAAyE,KAAO,IAAuBA,KAG9B,KAAAkM,WAAa,IAAuBA,WAqT7C,KAAAC,+BAAiC,IAAI,KAuUpC,KAAAC,gBAAkB,EAClB,KAAAC,iBAAkB,EAGnB,KAAAC,KAAOrR,KAAKsR,aAsBX,KAAAC,6BAA8B,EAG/B,KAAAC,yBAA2BxR,KAAKyR,iCAGhC,KAAAC,uBAAyB1R,KAAK2R,+BAv8BjC3R,KAAKsP,SAASsC,OAAOC,OAAO,IAAK3C,GAA4BvE,GACjE,CAgBA,YAAWkF,CAASiC,GACZ9R,KAAK+R,mBACL/R,KAAKmQ,mBAAmBzK,OAAO1F,KAAK+R,mBAEpCD,IACA9R,KAAK+R,kBAAoB/R,KAAKmQ,mBAAmB/K,IAAI0M,GAE7D,CAyCA,gBAAWlC,CAAakC,GAChB9R,KAAKgS,uBACLhS,KAAKoQ,uBAAuB1K,OAAO1F,KAAKgS,uBAExCF,IACA9R,KAAKgS,sBAAwBhS,KAAKoQ,uBAAuBhL,IAAI0M,GAErE,CAgBA,gBAAWhC,CAAagC,GAChB9R,KAAKiS,uBACLjS,KAAKqQ,uBAAuB3K,OAAO1F,KAAKiS,uBAExCH,IACA9R,KAAKiS,sBAAwBjS,KAAKqQ,uBAAuBjL,KAAKR,GAASkN,EAASlN,EAAKsN,KAAMtN,EAAKuN,eAExG,CAYA,mBAAWpC,CAAgB+B,GACnB9R,KAAKoS,0BACLpS,KAAKsQ,0BAA0B5K,OAAO1F,KAAKoS,0BAE3CN,IACA9R,KAAKoS,yBAA2BpS,KAAKsQ,0BAA0BlL,IAAI0M,GAE3E,CAYA,oBAAWnC,CAAiBmC,GACpB9R,KAAKqS,2BACLrS,KAAKuQ,2BAA2B7K,OAAO1F,KAAKqS,2BAE5CP,IACA9R,KAAKqS,0BAA4BrS,KAAKuQ,2BAA2BnL,IAAI0M,GAE7E,CAYA,kBAAWpC,CAAeoC,GAClB9R,KAAKsS,yBACLtS,KAAKwQ,yBAAyB9K,OAAO1F,KAAKsS,yBAE1CR,IACA9R,KAAKsS,wBAA0BtS,KAAKwQ,yBAAyBpL,IAAI0M,GAEzE,CAgBA,cAAWS,CAAWT,GACd9R,KAAKwS,qBACLxS,KAAKyQ,qBAAqB/K,OAAO1F,KAAKwS,qBAE1CxS,KAAKwS,oBAAsBxS,KAAKyQ,qBAAqBrL,IAAI0M,EAC7D,CAYA,WAAWtF,CAAQsF,GACX9R,KAAKyS,kBACLzS,KAAK0Q,kBAAkBhL,OAAO1F,KAAKyS,kBAEvCzS,KAAKyS,iBAAmBzS,KAAK0Q,kBAAkBtL,IAAI0M,EACvD,CAYA,aAAWY,CAAUZ,GACb9R,KAAK2S,oBACL3S,KAAK2Q,oBAAoBjL,OAAO1F,KAAK2S,oBAEzC3S,KAAK2S,mBAAqB3S,KAAK2Q,oBAAoBvL,IAAI0M,EAC3D,CAaA,qBAAWc,CAAkBd,GACrB9R,KAAK6S,4BACL7S,KAAK4Q,4BAA4BlL,OAAO1F,KAAK6S,4BAEjD7S,KAAK6S,2BAA6B7S,KAAK4Q,4BAA4BxL,IAAI0M,EAC3E,CAKA,kBAAWrC,GACP,OAAOzP,KAAKoR,eAChB,CAEA,kBAAW3B,CAAetM,GAClBnD,KAAKoR,kBAAoBjO,IAI7BnD,KAAKoR,gBAAkBjO,EAEnBnD,KAAKoR,gBACLpR,KAAKqR,KAAOrR,KAAK8S,YAEjB9S,KAAKqR,KAAOrR,KAAKsR,aAEzB,CAKA,8BAAW/B,GACP,OAAOvP,KAAKuR,2BAChB,CAEA,8BAAWhC,CAA2BpM,GAC9BnD,KAAKuR,8BAAgCpO,IAIzCnD,KAAKuR,4BAA8BpO,EAE/BnD,KAAKuR,6BACLvR,KAAKwR,yBAA2BxR,KAAK+S,gCACrC/S,KAAK0R,uBAAyB1R,KAAKgT,gCAEnChT,KAAKwR,yBAA2BxR,KAAKyR,iCACrCzR,KAAK0R,uBAAyB1R,KAAK2R,gCAE3C,CAYA,eAAW3B,CAAY8B,GACf9R,KAAKiT,sBACLjT,KAAK6Q,sBAAsBnL,OAAO1F,KAAKiT,sBAE3CjT,KAAKiT,qBAAuBjT,KAAK6Q,sBAAsBzL,IAAI0M,EAC/D,CAkBO,OAAArK,GACCzH,KAAK8Q,UACL9Q,KAAK8Q,QAAQrJ,UACbzH,KAAK8Q,QAAU,MAGnB,IAAK,MAAMoC,KAAWlT,KAAKgR,UACvBkC,EAAQC,QAGZnT,KAAKgR,UAAU7M,OAAS,SAEjBnE,KAAKoT,kBAEZpT,KAAKqP,mBAAsB7D,GAAQC,QAAQC,QAAQF,GAEnDxL,KAAKoQ,uBAAuBiD,QAC5BrT,KAAKqQ,uBAAuBgD,QAC5BrT,KAAKsQ,0BAA0B+C,QAC/BrT,KAAKuQ,2BAA2B8C,QAChCrT,KAAKwQ,yBAAyB6C,QAC9BrT,KAAKyQ,qBAAqB4C,QAC1BrT,KAAK4Q,4BAA4ByC,QAEjCrT,KAAK2Q,oBAAoB2C,qBAAgBC,GACzCvT,KAAK2Q,oBAAoB0C,OAC7B,CAKO,QAAAG,CACHpT,EACAqT,EACAjJ,EACAkJ,EACAC,EACAC,EACApH,EACAzH,GAEA,GAAI+F,YAAYC,OAAO0I,GAEnB,OADAzT,KAAK6T,YAAYzT,EAAOqT,EAAWjJ,EAASkJ,EAAWlH,EAASzH,GACzD,KAGX/E,KAAKoT,kBAAoBO,EAEzB,MAAMlJ,EAAYgJ,EAAmB1O,MAAQ,KAAM+O,YAAYL,GAE/D,GAAIG,EAAgB,CAChB,GAAI5T,KAAK6O,iBAAkB,CACnB7O,KAAK+O,UACL,IAAOgF,KAAK,oEAGhB,MAAMC,EAA4B,CAC9Bb,MAAO,OACP1C,qBAAsB,IAAI,MAGxBwD,EAAa,CACfpK,UAAW,CAACH,EAAoBE,IACrB,IAAI6B,SAAyB,CAACC,EAASC,KAC1C3L,KAAKkU,UACD9T,EACAqT,GACC7O,IACG8G,EAAQ,IAAItB,WAAWxF,OAE3B,GACC6H,IACGd,EAAOc,MAEV0H,IACGA,EAAWC,iBAAiB,QAAS,SAAS1K,KAAcA,EAAaE,EAAa,WAKtGA,WAAY,GAWhB,OARA5J,KAAKqU,mBAAmB,IAAI9K,EAAW0K,IAAapI,MAC/CyI,IACGN,EAAYvD,qBAAqB6C,gBAAgBU,GACjDN,EAAUY,KAEd9H,EAAWC,GAAUD,OAAQ+G,EAAW9G,QAAS8G,GAG9CS,CACX,CAEA,OAAOhU,KAAKkU,UACR9T,EACAqT,GACC7O,IACG5E,KAAKuU,UAAUnU,EAAO,IAAIgK,WAAWxF,EAAqB,EAAIA,EAAqBgF,YAAaY,EAASC,GACzGzK,KAAKqU,mBACD,IAAI9K,EAAW,CACXM,UAAW,CAACH,EAAYE,IAAeC,EAAUjF,EAAqB8E,EAAYE,GAClFA,WAAahF,EAAqBgF,cAExCiC,MACGyI,IACGZ,EAAUY,KAEd9H,EAAWC,GAAUD,OAAQ+G,EAAW9G,QAAS8G,MAGzD,EACA/G,EAER,CACI,OAAOxM,KAAKkU,UACR9T,EACAqT,GACC7O,IACG,IACI5E,KAAKuU,UAAUnU,EAAOwE,EAAgB4F,EAASC,GAC/CiJ,EAAU,CAAEc,KAAMxU,KAAKyU,WAAW7P,IACtC,CAAE,MACM4H,GACAA,GAER,KAEJ,EACAA,EAGZ,CAEQ,WAAAqH,CACJzT,EACAwE,EACA4F,EACAkJ,EACAlH,EACA/B,GAEAzK,KAAKuU,UAAUnU,EAAO,IAAIgK,WAAWxF,EAAK6E,OAAQ7E,EAAK8E,WAAY9E,EAAKgF,YAAaY,EAASC,GAC9FzK,KAAKqU,mBACD,IAAI9K,EAAW,CACXM,UAAW,CAACH,EAAYE,IAr1BxC,SAAuB8K,EAAkChL,EAAoBE,GACzE,IACI,GAAIF,EAAa,GAAKA,GAAcgL,EAAgB9K,WAChD,MAAM,IAAI+K,WAAW,2BAGzB,GAAIjL,EAAaE,EAAa8K,EAAgB9K,WAC1C,MAAM,IAAI+K,WAAW,2BAGzB,OAAOlJ,QAAQC,QAAQ,IAAItB,WAAWsK,EAAgBjL,OAAQiL,EAAgBhL,WAAaA,EAAYE,GAC3G,CAAE,MAAO4D,GACL,OAAO/B,QAAQE,OAAO6B,EAC1B,CACJ,CAu0BuDoH,CAAchQ,EAAM8E,EAAYE,GACvEA,WAAYhF,EAAKgF,cAEvBiC,MACGyI,IACGZ,EAAUY,KAEd9H,EAAWC,GAAUD,OAAQ+G,EAAW9G,QAAS8G,EAEzD,CAKO,eAAAsB,CACHC,EACA1U,EACAwE,EACA4F,EACAmJ,EACAlJ,GAEA,OAAOgB,QAAQC,UAAUG,MAAK,KAC1B7L,KAAKmQ,mBAAmBmD,gBAAgB1O,GACxC5E,KAAKmQ,mBAAmBkD,QAExBrT,KAAKqR,KAAK,WAAW5G,GAAY,MACjCzK,KAAK8Q,QAAU9Q,KAAK+U,WAAWnQ,GACxB5E,KAAK8Q,QAAQ+D,gBAAgBC,EAAa1U,EAAO,KAAMwE,EAAM4F,EAASmJ,EAAYlJ,KAEjG,CAKO,SAAAd,CAAUvJ,EAAcwE,EAAuB4F,EAAiBmJ,EAAyDlJ,GAC5H,OAAOgB,QAAQC,UAAUG,MAAK,KAC1B7L,KAAKmQ,mBAAmBmD,gBAAgB1O,GACxC5E,KAAKmQ,mBAAmBkD,QAExBrT,KAAKqR,KAAK,WAAW5G,GAAY,MACjCzK,KAAK8Q,QAAU9Q,KAAK+U,WAAWnQ,GACxB5E,KAAK8Q,QAAQnH,UAAUvJ,EAAOwE,EAAM4F,EAASmJ,EAAYlJ,KAExE,CAKO,uBAAAuK,CACH5U,EACAwE,EACA4F,EACAmJ,EACAlJ,GAEA,OAAOgB,QAAQC,UAAUG,MAAK,KAC1B7L,KAAKmQ,mBAAmBmD,gBAAgB1O,GACxC5E,KAAKmQ,mBAAmBkD,QAExBrT,KAAKqR,KAAK,WAAW5G,GAAY,MACjCzK,KAAK8Q,QAAU9Q,KAAK+U,WAAWnQ,GAG/B,MAAMqQ,EAAY,IAAI,KAAe7U,GAG/B8U,EAA6B,GACnClV,KAAKuQ,2BAA2BnL,KAAK+P,IACjCD,EAAUhQ,KAAKiQ,MAEnB,MAAMC,EAA+B,GACrCpV,KAAKsQ,0BAA0BlL,KAAKiQ,IAChCD,EAASlQ,KAAKmQ,MAElB,MAAMC,EAAyB,GAC/BtV,KAAKwQ,yBAAyBpL,KAAKmQ,IAC/BD,EAAQpQ,KAAKqQ,MAGjB,MAAMtM,EAAiD,GAOvD,OANAjJ,KAAKoQ,uBAAuBhL,KAAK+B,IACzBA,EAAKE,oBACL4B,EAAoB/D,KAAKiC,EAAKE,uBAI/BrH,KAAK8Q,QAAQ+D,gBAAgB,KAAMzU,EAAO6U,EAAWrQ,EAAM4F,EAASmJ,EAAYlJ,GAAUoB,MAAMzC,IACnG9I,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUS,WAAYtM,EAAOsM,YACxDpV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAU7N,OAAQgC,EAAOhC,QACpD9G,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUU,gBAAiBvM,EAAOuM,iBAC7DrV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUW,UAAWxM,EAAOwM,WACvDtV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUY,gBAAiBzM,EAAOyM,iBAC7DvV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUC,UAAWA,GAChD5U,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUG,SAAUA,GAC/C9U,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUa,OAAQ1M,EAAO0M,QACpDxV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUc,eAAgB3M,EAAO2M,gBAC5DzV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUK,QAASA,GAC9ChV,MAAMkV,UAAUtQ,KAAKuQ,MAAMR,EAAUhM,oBAAqBA,GACnDgM,OAGnB,CAKO,aAAAe,CAAcpR,GACjB,OAAO,IAAuBoR,cAAcpR,EAChD,CAKO,UAAAqR,CAAW7V,EAAcwE,GAC5B,GACIA,EAAKsR,WAAW,UAAY,MAC5BtR,EAAKsR,WAAW,WAAa,MAC7BtR,EAAKsR,WAAW,mCAAqC,MACrDtR,EAAKsR,WAAW,4BAA8B,KAChD,CACE,MAAM3I,GAAc,QAAwB3I,GAG5C,OADA5E,KAAKuU,UAAUnU,EAAO,IAAIgK,WAAWmD,EAAa,EAAGA,EAAY3D,aAC1D5J,KAAKqU,mBACR,IAAI9K,EAAW,CACXM,UAAW,CAACH,EAAYE,IAAeC,EAAU0D,EAAa7D,EAAYE,GAC1EA,WAAY2D,EAAY3D,aAGpC,CAGA,OADA5J,KAAKuU,UAAUnU,EAAOwE,GACf6G,QAAQC,QAAQ,CAAE8I,KAAMxU,KAAKyU,WAAW7P,IACnD,CAWO,YAAAuR,CAAaxL,GAChB,OAAO,IAAIsF,EAAetF,EAAQ,IAAuB5F,MAC7D,CAKA,eAAWqR,GACP,OAAOpW,KAAK+Q,MAChB,CAWO,iBAAAsF,GACH,OAAO,IAAI5K,SAAQ,CAACC,EAASC,KACzB3L,KAAKyQ,qBAAqB6F,SAAQ,KAC9B5K,OAEJ1L,KAAK0Q,kBAAkB4F,SAASxK,IAC5BH,EAAOG,QAGnB,CAKO,SAAAyK,CAAUC,GACTxW,KAAK+Q,SAAWyF,IAIpBxW,KAAK+Q,OAASyF,EACdxW,KAAKkR,+BAA+BoC,gBAAgBtT,KAAK+Q,QACzD/Q,KAAKqR,KAAK/D,EAAgBtN,KAAK+Q,SACnC,CAKO,SAAAmD,CACH9T,EACAqT,EACAC,EACAE,EACApH,EACAiK,GAEA,MAAMvD,EAAU9S,EAAM8T,UAClBT,EACAC,GACCgD,IACG1W,KAAK2W,YAAYD,EAAOxD,MAE5B,EACAU,EACApH,EACAiK,GAQJ,OANAvD,EAAQzC,qBAAqBrL,KAAI,KAE7B8N,EAAQ0D,mBAAoB,EAC5B1D,EAAQ2D,OAAS3D,EAAQ4D,WAE7B9W,KAAKgR,UAAU9L,KAAKgO,GACbA,CACX,CAEQ,WAAAyD,CAAYD,EAAsBxD,GACtC,IAAKlT,KAAKoT,kBACN,OAGJF,EAAQ0D,kBAAoBF,EAAMK,iBAClC7D,EAAQ4D,QAAUJ,EAAMM,OACxB9D,EAAQ2D,OAASH,EAAMO,MAEvB,IAAIF,GAAmB,EACnBC,EAAS,EACTC,EAAQ,EACZ,IAAK,MAAM/D,KAAWlT,KAAKgR,UAAW,CAClC,QAAkCuC,IAA9BL,EAAQ0D,wBAAuDrD,IAApBL,EAAQ4D,cAA4CvD,IAAnBL,EAAQ2D,OACpF,OAGJE,EAAmBA,GAAoB7D,EAAQ0D,kBAC/CI,GAAU9D,EAAQ4D,QAClBG,GAAS/D,EAAQ2D,MACrB,CAEA7W,KAAKoT,kBAAkB,CACnB2D,iBAAkBA,EAClBC,OAAQA,EACRC,MAAOF,EAAmBE,EAAQ,GAE1C,CAEQ,SAAA1C,CAAUnU,EAAcwE,EAA2B4F,EAAU,GAAIC,EAAW,IAC3EzK,KAAK+O,WAIV/O,KAAKwR,yBAAyB,iBAC9BzF,EAAexB,cAAc3F,EAAM4F,EAASC,GAAWI,GAC5C7K,KAAKqP,mBAAmB7E,EAAUK,GAAKgB,MAAML,GACzCpL,EAAM8W,eAAe1L,OAAK+H,GAAW,GAAM,GAAM1H,MAAMjH,GACnD,IAAIwF,WAAWxF,EAAM,EAAGA,EAAKgF,kBAG7CiC,MACEzC,IACGpJ,KAAK0R,uBAAuB,iBAC5B1R,KAAK6Q,sBAAsByC,gBAAgBlK,GAC3CpJ,KAAK6Q,sBAAsBwC,WAE9BvH,IACG9L,KAAK0R,uBAAuB,iBAC5B,KAAMqC,KAAK,uBAAuBjI,EAAOR,WACzCtL,KAAK6Q,sBAAsBwC,WAGvC,CAEQ,UAAA0B,CAAWT,GACf,MAAM6C,EAAc7C,EAAWE,KAAM2C,OAAS,CAAC,EAE/CnX,KAAKqR,KAAK,kBAAkB8F,EAAMC,WAClCD,EAAME,YAAcrX,KAAKqR,KAAK,0BAA0B8F,EAAME,cAC9DF,EAAMG,WAAatX,KAAKqR,KAAK,oBAAoB8F,EAAMG,aAEvD,MAAMF,EAAUnH,EAAesH,cAAcJ,EAAMC,SACnD,IAAKA,EACD,MAAM,IAAI1P,MAAM,oBAAsByP,EAAMC,SAGhD,QAAyB7D,IAArB4D,EAAME,WAA0B,CAChC,MAAMA,EAAapH,EAAesH,cAAcJ,EAAME,YACtD,IAAKA,EACD,MAAM,IAAI3P,MAAM,4BAA8ByP,EAAME,YAGxD,GAAIpH,EAAeuH,gBAAgBH,EAAY,CAAEI,MAAO,EAAGC,MAAO,IAAO,EACrE,MAAM,IAAIhQ,MAAM,iCAAmCyP,EAAME,WAEjE,CAEA,MAKMM,EAL4E,CAC9E,EAAG1H,EAAe2H,mBAClB,EAAG3H,EAAe4H,oBAGaT,EAAQK,OAC3C,IAAKE,EACD,MAAM,IAAIjQ,MAAM,wBAA0ByP,EAAMC,SAGpD,OAAOO,EAAa3X,KACxB,CAEQ,UAAAyU,CAAWD,GACfxU,KAAKwR,yBAAyB,cAC9BxR,KAAKqR,KAAK,gBAAgBmD,EAAKrQ,UAC/B,MAAM2T,EAASC,KAAKC,MAAMxD,GAE1B,OADAxU,KAAK0R,uBAAuB,cACrBoG,CACX,CAEQ,kBAAAzD,CAAmB4D,GAIvB,OAHAjY,KAAKwR,yBAAyB,iBAGvByG,EAAWtO,UAAU,IAAIkC,MAAK,KACjC,MAIMqM,EAAQD,EAAWhO,aACzB,GAJW,aAIPiO,EACA,MAAM,IAAI,KAAa,qBAAuBA,EAAO,KAAWC,gCAGpE,MAAMf,EAAUa,EAAWhO,aAEvBjK,KAAKyP,gBACLzP,KAAKqR,KAAK,mBAAmB+F,KAGjC,MAAMjT,EAAS8T,EAAWhO,aAK1B,IAAImO,EACJ,OALKpY,KAAK6O,kBAAoB1K,IAAW8T,EAAWxO,OAAOG,YACvD,IAAOmK,KAAK,uDAAuD5P,QAAa8T,EAAWxO,OAAOG,cAI9FwN,GACJ,KAAK,EACDgB,EAAWpY,KAAKqY,qBAAqBJ,EAAY9T,GACjD,MAEJ,KAAK,EACDiU,EAAWpY,KAAKsY,qBAAqBL,EAAY9T,GACjD,MAEJ,QACI,MAAM,IAAIuD,MAAM,wBAA0B0P,GAMlD,OAFApX,KAAK0R,uBAAuB,iBAErB0G,IAEf,CAEQ,oBAAAC,CAAqBJ,EAAwB9T,GACjD,MAIMoU,EAAgBN,EAAWhO,aAC3BuO,EAAgBP,EAAWhO,aAEjC,GANU,IAMNuO,EACA,MAAM,IAAI9Q,MAAM,8BAA8B8Q,KAGlD,MAAMC,EAAatU,EAAS8T,EAAWvO,WAEjC9E,EAAwB,CAAE4P,KAAMxU,KAAKyU,WAAWwD,EAAW5N,WAAWkO,IAAiBG,IAAK,MAClG,GAAmB,IAAfD,EAAkB,CAClB,MAAME,EAAkBV,EAAWvO,WACnC9E,EAAK8T,IAAM,CACP7O,UAAW,CAACH,EAAYE,IAAeqO,EAAWxO,OAAOI,UAAU8O,EAAkBjP,EAAYE,GACjGA,WAAY6O,EAEpB,CAEA,OAAOhN,QAAQC,QAAQ9G,EAC3B,CAEQ,oBAAA0T,CAAqBL,EAAwB9T,GACjD,MAAMyU,EACI,WAKJC,EAAcZ,EAAWhO,aAE/B,GADoBgO,EAAWhO,eACX2O,EAChB,MAAM,IAAIlR,MAAM,kCAIpB,OAAIuQ,EAAWvO,WAAamP,IAAgB1U,EACjC8T,EAAWtO,UAAUkP,GAAahN,MAAK,KACnC,CAAE2I,KAAMxU,KAAKyU,WAAWwD,EAAW5N,WAAWwO,IAAeH,IAAK,SAK1ET,EAAWtO,UAAUkP,EAAc,GAAGhN,MAAK,KAC9C,MAAMjH,EAAwB,CAAE4P,KAAMxU,KAAKyU,WAAWwD,EAAW5N,WAAWwO,IAAeH,IAAK,MAE1F7O,EAAY,KACd,MAAMgP,EAAcZ,EAAWhO,aAG/B,OAFoBgO,EAAWhO,cAG3B,KAAK2O,EACD,MAAM,IAAIlR,MAAM,yBAEpB,KA7BH,QA6ByB,CAClB,MAAMiR,EAAkBV,EAAWvO,WACnC9E,EAAK8T,IAAM,CACP7O,UAAW,CAACH,EAAYE,IAAeqO,EAAWxO,OAAOI,UAAU8O,EAAkBjP,EAAYE,GACjGA,WAAYiP,GAEhBZ,EAAW3N,UAAUuO,GACrB,KACJ,CACA,QAEIZ,EAAW3N,UAAUuO,GAK7B,OAAIZ,EAAWvO,aAAevF,EACnB8T,EAAWtO,UAAU,GAAGkC,KAAKhC,GAGjC4B,QAAQC,QAAQ9G,IAG3B,OAAOiF,MAEf,CAEQ,oBAAO0N,CAAcH,GACzB,GAAgB,QAAZA,GAAiC,UAAZA,EACrB,MAAO,CACHK,MAAO,EACPC,MAAO,GAIf,MAAMoB,GAAS1B,EAAU,IAAI0B,MAAM,iBACnC,OAAKA,EAIE,CACHrB,MAAOsB,SAASD,EAAM,IACtBpB,MAAOqB,SAASD,EAAM,KALf,IAOf,CAEQ,sBAAOtB,CAAgBwB,EAAqCC,GAChE,OAAID,EAAEvB,MAAQwB,EAAExB,MACL,EAEPuB,EAAEvB,MAAQwB,EAAExB,OACJ,EAERuB,EAAEtB,MAAQuB,EAAEvB,MACL,EAEPsB,EAAEtB,MAAQuB,EAAEvB,OACJ,EAEL,CACX,CAYO,QAAAwB,CAAS5N,GACZtL,KAAKqR,KAAK/F,GACVtL,KAAKmR,iBACT,CAGO,SAAAgI,KACDnZ,KAAKmR,eACX,CAEQ,WAAA2B,CAAYxH,GAChB,MAAM8N,EAASnJ,EAAeoJ,WAAWC,UAAU,EAA0B,EAAvBtZ,KAAKmR,iBAC3D,IAAOoI,IAAI,GAAGH,IAAS9N,IAC3B,CAEQ,YAAAgG,CAAahG,GAAwB,CAUrC,+BAAAyH,CAAgCyG,GACpC,KAAMC,wBAAwBD,EAClC,CAEQ,gCAAA/H,CAAiC+H,GAA4B,CAE7D,6BAAAxG,CAA8BwG,GAClC,KAAME,sBAAsBF,EAChC,CAEQ,8BAAA7H,CAA+B6H,GAA4B,EA36BrD,EAAAG,oBAAqB,EAOrB,EAAAC,wBAAyB,EAu3Bf,EAAAP,WAAa,oCAgDzC,QAA0B,IAAIpJ,G,2DCr6CvB,MAAM4J,EAQT,WAAArQ,CAAYsQ,GACR9Z,KAAK+Z,SAAWD,CACpB,CAKA,SAAW3W,GAOP,OALInD,KAAK+Z,WACL/Z,KAAKga,OAASha,KAAK+Z,WAEnB/Z,KAAK+Z,cAAWxG,GAEbvT,KAAKga,MAChB,EC8DJ,MAAMC,EAAkC,IAAIJ,GAAK,IAAM,0CACjDK,EAAmC,IAAIL,GAAK,IAAM,kCAkBjD,MAAMM,EAQF,UAAOC,CAAOC,EAAiBC,EAAiC3V,GACnE,IAAK2V,GAAkB/G,MAAT5O,IAAuB2V,EAAM3V,GACvC,MAAM,IAAI+C,MAAM,GAAG2S,4BAAkC1V,MAGzD,OAAO2V,EAAM3V,EACjB,CAQO,aAAO4V,CAAUD,EAAiC3V,GACrD,OAAK2V,GAAkB/G,MAAT5O,GAAuB2V,EAAM3V,GAIpC2V,EAAM3V,GAHF,IAIf,CAMO,aAAO6V,CAAOF,GACjB,GAAIA,EACA,IAAK,IAAI3V,EAAQ,EAAGA,EAAQ2V,EAAMnW,OAAQQ,IACtC2V,EAAM3V,GAAOA,MAAQA,CAGjC,EAaG,SAAS8V,EAAqCC,GACjD,GAAIA,EAASC,KAAOD,EAASE,IAAK,CAC9B,MAAMC,EAAWH,EAASC,IACpBG,EAAWJ,EAASE,IACpBG,EAAY,KAAWC,QAAQ,GAAGC,eAAeJ,EAAS,GAAIA,EAAS,GAAIA,EAAS,IACpFK,EAAY,KAAWF,QAAQ,GAAGC,eAAeH,EAAS,GAAIA,EAAS,GAAIA,EAAS,IAC1F,GAAIJ,EAASS,YAAyC,OAA3BT,EAASU,cAA+C,CAC/E,IAAIC,EAAU,EACd,OAAQX,EAASU,eACb,KAAK,KACDC,EAAU,IACV,MACJ,KAAK,KACDA,EAAU,IACV,MACJ,KAAK,KACDA,EAAU,MACV,MACJ,KAAK,KACDA,EAAU,MAGlB,MAAMC,EAAiB,EAAID,EAC3BN,EAAUQ,aAAaD,GACvBJ,EAAUK,aAAaD,EAC3B,CACA,OAAO,IAAI,IAAaP,EAAWG,EACvC,CACA,OAAO,IACX,CAUO,MAAMM,GA+CF,wBAAOC,CAAkB1W,EAAc+U,IAC1C,QAAsB/U,GAAM,EAAO+U,EACvC,CAQO,0BAAO4B,CAAoB3W,GAC9B,OAAO,QAAwBA,EACnC,CAKA,QAAW4W,GACP,IAAK3b,KAAK4b,MACN,MAAM,IAAIlU,MAAM,8BAGpB,OAAO1H,KAAK4b,KAChB,CAKA,OAAWlD,GACP,OAAO1Y,KAAK6b,IAChB,CAKA,UAAWC,GACP,OAAO9b,KAAK+b,OAChB,CAKA,gBAAWC,GACP,IAAKhc,KAAKic,cACN,MAAM,IAAIvU,MAAM,0BAGpB,OAAO1H,KAAKic,aAChB,CAKA,mBAAWC,GACP,OAAOlc,KAAKmc,gBAChB,CAKA,WAAW3R,GACP,OAAOxK,KAAKoc,QAChB,CAKA,WAAA5S,CAAYsS,GAhHI,KAAAO,kBAAoB,IAAI/b,MAGjC,KAAAgc,gBAA4C,KAG5C,KAAAC,eAA0B,GAG1B,KAAAC,sBAAwB,EAGxB,KAAAC,4BAA6B,EAG7B,KAAAC,yBAA0B,EAGhB,KAAAC,YAAc,IAAIrc,MAC3B,KAAAsc,WAAY,EACZ,KAAAR,SAA6B,KAC7B,KAAAS,UAA8B,KAC9B,KAAAC,eAAmC,KAEnC,KAAAjB,KAA8B,KAE9B,KAAAM,iBAA4C,KAC5C,KAAAY,4BAAgE,CAAC,EACxD,KAAAC,sBAAwB,IAAI1c,MAC5B,KAAA2c,sBAAwB,IAAIC,QAGtC,KAAAC,iBAA0E,KAiF7End,KAAK+b,QAAUD,CACnB,CAQO,2BAAAsB,CAA4BjI,GAC/B,IAAIkI,EAAUrd,KAAKid,sBAAsBK,IAAInI,GAC7C,IAAKkI,EAAS,CACV,IAAIrd,KAAKmd,iBAGL,MAAM,IAAIzV,MAAM,gDAFhB2V,EAAU,IAAIrd,KAAKmd,iBAAiBI,aAAapI,GAIrDnV,KAAKid,sBAAsBO,IAAIrI,EAAUkI,EAC7C,CACA,OAAOA,CACX,CAGO,OAAA5V,GACCzH,KAAK4c,YAIT5c,KAAK4c,WAAY,EAEjB5c,KAAKqc,kBAAkBlY,OAAS,EAEhCnE,KAAK2c,YAAYc,SAASC,GAAcA,EAAUjW,SAAWiW,EAAUjW,YACvEzH,KAAK2c,YAAYxY,OAAS,EAEzBnE,KAAK4b,MAA4B,KAClC5b,KAAK6b,KAAO,KACX7b,KAAKic,cAAoC,KAC1Cjc,KAAKmc,iBAAmB,KACxBnc,KAAK+c,4BAA8B,CAAC,EACpC/c,KAAKgd,sBAAsB7Y,OAAS,EAEpCnE,KAAK+b,QAAQtU,UACjB,CAKO,qBAAMoN,CACTC,EACA1U,EACA6U,EACArQ,EACA4F,EACAmJ,EACAlJ,EAAW,IAGX,aAAagB,QAAQC,UAAUG,MAAK8R,UAChC3d,KAAKic,cAAgB7b,EACrBJ,KAAKsc,gBAAkBrH,EACvBjV,KAAK4d,UAAUhZ,GAEf,IAAIiZ,EAAiC,KAErC,GAAI/I,EAAa,CACb,MAAMgJ,EAAsC,CAAC,EAC7C,GAAI9d,KAAK4b,MAAMiC,MACX,IAAK,MAAM3L,KAAQlS,KAAK4b,MAAMiC,MACtB3L,EAAKnN,OACL+Y,EAAQ5L,EAAKnN,MAAQmN,EAAKvN,OAMtCkZ,GADc/I,aAAuBxU,MAAQwU,EAAc,CAACA,IAC9CiJ,KAAKhZ,IACf,MAAMmN,EAAO4L,EAAQ/Y,GACrB,QAAawO,IAATrB,EACA,MAAM,IAAIxK,MAAM,wBAAwB3C,MAG5C,OAAOmN,IAEf,CAEA,aAAalS,KAAKge,WAAWxT,EAASC,EAAUoT,GAAO,KAC5C,CACHzW,OAAQpH,KAAKie,aACbtI,gBAAiB,GACjBC,UAAW5V,KAAKke,gBAChBrI,gBAAiB7V,KAAKme,sBACtBrI,OAAQ9V,KAAKuc,eACbxG,eAAgB/V,KAAKoe,qBACrB1I,WAAY1V,KAAKqe,iBACjBC,eAAgB,SAIhC,CAKO,eAAM3U,CAAUvJ,EAAcwE,EAAuB4F,EAAiBmJ,EAAyDlJ,EAAW,IAG7I,OAFAzK,KAAKic,cAAgB7b,EACrBJ,KAAK4d,UAAUhZ,SACF5E,KAAKge,WAAWxT,EAASC,EAAU,MAAM,QAC1D,CAEQ,gBAAMuT,CAAcxT,EAAiBC,EAAkBoT,EAAgCU,GAC3F,aAAa9S,QAAQC,UAChBG,MAAK8R,UACF3d,KAAKoc,SAAW5R,EAChBxK,KAAK8c,gBAAkBtS,EAAQ0L,WAAW,UAAYzL,EAAWD,EAAU,GAAGA,IAAUgU,KAAKC,SAC7Fze,KAAK6c,UAAYpS,EACjBzK,KAAKyc,4BAA6B,QAE5Bzc,KAAK0e,uBAGN1e,KAAK8b,OAAOtN,eAA0C,MAAzBxO,KAAKmd,mBAC/Bnd,KAAK8b,OAAO9M,YAAchP,KAAK2e,gBAAgB,yBAC/C3e,KAAKmd,iBAAmB,CACpByB,qBAAsB,wCAA8CC,gBACpEtB,oBAAqB,+BAA2CuB,+BAGpE9e,KAAKmd,iBAAmB,CACpByB,qBAAsB,yCAA0CG,YAChExB,oBAAqB,+BAAuCyB,4BAKxE,MAAMC,EAA4B,GAAG3R,EAAgBA,EAAgB4R,eAAe5R,EAAgBA,EAAgB6R,SAC9GC,EAA+B,GAAG9R,EAAgBA,EAAgB4R,eAAe5R,EAAgBA,EAAgB+R,YAEvHrf,KAAK+b,QAAQvK,yBAAyByN,GACtCjf,KAAK+b,QAAQvK,yBAAyB4N,GAEtCpf,KAAK+b,QAAQxF,UAAUjJ,EAAgB4R,SACvClf,KAAKsf,uBAEL,MAAMC,EAAW,IAAIjf,MAGfkf,EAAiCxf,KAAKic,cAAcwD,4BAG1D,GAFAzf,KAAKic,cAAcwD,6BAA8B,GAE5Czf,KAAK8b,OAAOxN,kBACb,GAAIuP,EACA0B,EAASra,KAAKlF,KAAK0f,eAAe,SAAU,CAAE7B,MAAOA,EAAOlZ,OAAQ,UACjE,GAAwB4O,MAApBvT,KAAK4b,MAAMxb,OAAuBJ,KAAK4b,MAAM+D,QAAU3f,KAAK4b,MAAM+D,OAAO,GAAK,CACrF,MAAMvf,EAAQ+Z,EAAUC,IAAI,SAAUpa,KAAK4b,MAAM+D,OAAQ3f,KAAK4b,MAAMxb,OAAS,GAC7Emf,EAASra,KAAKlF,KAAK0f,eAAe,WAAWtf,EAAMuE,QAASvE,GAChE,CAGJ,IAAKJ,KAAK8b,OAAOtN,eAAiBxO,KAAK8b,OAAO3N,kBAAoBnO,KAAK4b,MAAM1G,UACzE,IAAK,IAAI0K,EAAI,EAAGA,EAAI5f,KAAK4b,MAAM1G,UAAU/Q,SAAUyb,EAAG,CAClD,MAAMzK,EAAWnV,KAAK4b,MAAM1G,UAAU0K,GAChCvF,EAAU,cAAgBuF,EAC1BC,EAAkB,IAASC,iBAEjCP,EAASra,KAAKlF,KAAK+f,mBAAmB1F,EAASlF,EAAU,KAAM0K,GAAiB,SACpF,CAIA7f,KAAKyc,2BAGLzc,KAAKic,cAAcwD,4BAA8BD,EAIjDxf,KAAKic,cAAc+D,kCAAkCR,GAGrDxf,KAAK+b,QAAQjO,kBACbyR,EAASra,KAAKlF,KAAKigB,0BAGnBjgB,KAAK+b,QAAQhO,yBACbwR,EAASra,KAAKlF,KAAKkgB,iCAGvB,MAAMC,EAAgB1U,QAAQ2U,IAAIb,GAAU1T,MAAK,KACzC7L,KAAKmc,kBAAoBnc,KAAKmc,mBAAqBnc,KAAK+b,QAAQvM,gBAChExP,KAAKmc,iBAAiBkE,YAAW,GAIrC,IAAK,MAAMlL,KAAYnV,KAAKic,cAAc/G,UAAW,CACjD,MAAMoL,EAAMnL,OAEsB5B,IAA9B+M,EAAIC,wBACJD,EAAIC,sBAAwB3Y,KAAKgT,IAAI0F,EAAIC,sBAAuBvgB,KAAKic,cAAcnG,OAAO3R,QAElG,CAQA,OANAnE,KAAKwgB,qBACLxgB,KAAK+b,QAAQxF,UAAUjJ,EAAgB6R,OAClCnf,KAAK0c,yBACN1c,KAAKygB,mBAGFlC,OAGX,aAAa4B,EAActU,MAAMzC,IAC7BpJ,KAAK+b,QAAQrK,uBAAuBuN,GAEpC,KAAMyB,cAAa,KACV1gB,KAAK4c,WACNnR,QAAQ2U,IAAIpgB,KAAKqc,mBAAmBxQ,MAChC,KACI7L,KAAK+b,QAAQrK,uBAAuB0N,GAEpCpf,KAAK+b,QAAQxF,UAAUjJ,EAAgB+R,UAEvCrf,KAAK+b,QAAQtL,qBAAqB6C,qBAAgBC,GAClDvT,KAAK+b,QAAQtL,qBAAqB4C,QAElCrT,KAAKyH,aAERgF,IACGzM,KAAK+b,QAAQrL,kBAAkB4C,gBAAgB7G,GAC/CzM,KAAK+b,QAAQrL,kBAAkB2C,QAE/BrT,KAAKyH,gBAMd2B,QAGduX,OAAOlU,IAQJ,MAPKzM,KAAK4c,YACN5c,KAAK+b,QAAQrL,kBAAkB4C,gBAAgB7G,GAC/CzM,KAAK+b,QAAQrL,kBAAkB2C,QAE/BrT,KAAKyH,WAGHgF,IAElB,CAEQ,SAAAmR,CAAUhZ,GAId,GAHA5E,KAAK4b,MAAQhX,EAAK4P,KAClBxU,KAAK4gB,aAEDhc,EAAK8T,IAAK,CACV,MAAMmI,EAAU7gB,KAAK4b,MAAMiF,QAC3B,GAAIA,GAAWA,EAAQ,KAAOA,EAAQ,GAAGhW,IAAK,CAC1C,MAAMiW,EAAeD,EAAQ,IACzBC,EAAalX,WAAahF,EAAK8T,IAAI9O,WAAa,GAAKkX,EAAalX,WAAahF,EAAK8T,IAAI9O,aACxF,IAAOmK,KAAK,yBAAyB+M,EAAalX,sDAAsDhF,EAAK8T,IAAI9O,eAGrH5J,KAAK6b,KAAOjX,EAAK8T,GACrB,MACI,IAAO3E,KAAK,uBAEpB,CACJ,CAEQ,UAAA6M,GAeJ,GAdAzG,EAAUK,OAAOxa,KAAK4b,MAAMmF,WAC5B5G,EAAUK,OAAOxa,KAAK4b,MAAMoF,YAC5B7G,EAAUK,OAAOxa,KAAK4b,MAAMiF,SAC5B1G,EAAUK,OAAOxa,KAAK4b,MAAMqF,aAC5B9G,EAAUK,OAAOxa,KAAK4b,MAAMtG,SAC5B6E,EAAUK,OAAOxa,KAAK4b,MAAMsF,QAC5B/G,EAAUK,OAAOxa,KAAK4b,MAAM1G,WAC5BiF,EAAUK,OAAOxa,KAAK4b,MAAMxU,QAC5B+S,EAAUK,OAAOxa,KAAK4b,MAAMiC,OAC5B1D,EAAUK,OAAOxa,KAAK4b,MAAMuF,UAC5BhH,EAAUK,OAAOxa,KAAK4b,MAAM+D,QAC5BxF,EAAUK,OAAOxa,KAAK4b,MAAMwF,OAC5BjH,EAAUK,OAAOxa,KAAK4b,MAAMxG,UAExBpV,KAAK4b,MAAMiC,MAAO,CAClB,MAAMwD,EAA2C,CAAC,EAClD,IAAK,MAAMnP,KAAQlS,KAAK4b,MAAMiC,MAC1B,GAAI3L,EAAKoP,SACL,IAAK,MAAM3c,KAASuN,EAAKoP,SACrBD,EAAY1c,GAASuN,EAAKvN,MAKtC,MAAM4c,EAAWvhB,KAAKwhB,kBACtB,IAAK,MAAMtP,KAAQlS,KAAK4b,MAAMiC,MAAO,CACjC,MAAM4D,EAAcJ,EAAYnP,EAAKvN,OACrCuN,EAAK4J,YAAyBvI,IAAhBkO,EAA4BF,EAAWvhB,KAAK4b,MAAMiC,MAAM4D,EAC1E,CACJ,CACJ,CAEQ,0BAAM/C,GACV,MAAMgD,EAAqD,GA+B3D,GA7BA,KAAyBjE,SAAQ,CAACkE,EAAqB5c,MAEC,IAAhD/E,KAAK8b,OAAO1M,iBAAiBrK,IAAO6c,QAEhCD,EAAoBE,iBAAmB7hB,KAAK2e,gBAAgB5Z,IAC5D,IAAOgP,KAAK,aAAahP,+CAIvB4c,EAAoBE,kBAAmB7hB,KAAK2e,gBAAgB5Z,IAClE2c,EAAkBxc,KACd,WACI,MAAMwY,QAAkBiE,EAAoB7H,QAAQ9Z,MAMpD,OALI0d,EAAU3Y,OAASA,GACnB,IAAOgP,KAAK,sFAAsF2J,EAAU3Y,YAAYA,KAG5H/E,KAAK+b,QAAQnL,4BAA4B0C,gBAAgBoK,GAClDA,CACV,EARD,OAaZ1d,KAAK2c,YAAYzX,cAAeuG,QAAQ2U,IAAIsB,IAE5C1hB,KAAK2c,YAAYmF,MAAK,CAAC9I,EAAGC,KAAOD,EAAE+I,OAASC,OAAOC,YAAchJ,EAAE8I,OAASC,OAAOC,aACnFjiB,KAAK+b,QAAQnL,4BAA4ByC,QAErCrT,KAAK4b,MAAMsG,mBACX,IAAK,MAAMnd,KAAQ/E,KAAK4b,MAAMsG,mBAE1B,IADkBliB,KAAK2c,YAAYwF,MAAMzE,GAAcA,EAAU3Y,OAASA,GAAQ2Y,EAAUkE,UAC5E,CACZ,IAAoD,IAAhD5hB,KAAK8b,OAAO1M,iBAAiBrK,IAAO6c,QACpC,MAAM,IAAIla,MAAM,sBAAsB3C,iBAE1C,MAAM,IAAI2C,MAAM,sBAAsB3C,qBAC1C,CAGZ,CAEQ,eAAAyc,GACJ,QAAoCjO,IAAhCvT,KAAK+b,QAAQvM,eAEb,OADAxP,KAAKmc,iBAAmBnc,KAAK+b,QAAQvM,eAC9B,CAEH4S,sBAAiD,OAA1BpiB,KAAKmc,sBAA4B5I,EAAYvT,KAAKmc,iBACzExX,OAAQ,GAGhB3E,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAMgG,EAAW,IAAI,IAAK,WAAYtiB,KAAKic,eAC3Cjc,KAAKmc,iBAAmBmG,EACxBtiB,KAAKmc,iBAAiB3a,iBAAmBxB,KAAKsc,gBAC9Ctc,KAAKic,cAAcoG,wBAAyB,EAC5CriB,KAAKmc,iBAAiBkE,YAAW,GAEjC,MAAMkB,EAAkB,CAEpBa,sBAAuBpiB,KAAKmc,iBAC5BxX,OAAQ,GAGZ,OAAQ3E,KAAK+b,QAAQ/N,sBACjB,KAAKZ,EAA+Ba,KAC3BjO,KAAKic,cAAcsG,uBACpBhB,EAASiB,SAAW,CAAC,EAAG,EAAG,EAAG,GAC9BjB,EAASkB,MAAQ,CAAC,EAAG,GAAI,GACzBjH,GAAWkH,eAAenB,EAAUvhB,KAAKmc,mBAE7C,MAEJ,KAAK/O,EAA+BuV,mBAChC3iB,KAAKic,cAAcsG,sBAAuB,EAC1C,MAEJ,QACI,MAAM,IAAI7a,MAAM,mCAAmC1H,KAAK+b,QAAQ/N,yBAKxE,OADAhO,KAAK+b,QAAQ3L,uBAAuBkD,gBAAgBgP,GAC7Cf,CACX,CASO,cAAA7B,CAAerF,EAAiBja,GACnC,MAAMwiB,EAAmB5iB,KAAK6iB,0BAA0BxI,EAASja,GACjE,GAAIwiB,EACA,OAAOA,EAGX,MAAMrD,EAAW,IAAIjf,MAIrB,GAFAN,KAAK8iB,QAAQ,GAAGzI,KAAWja,EAAM2E,MAAQ,MAErC3E,EAAMyd,MACN,IAAK,MAAMlZ,KAASvE,EAAMyd,MAAO,CAC7B,MAAM3L,EAAOiI,EAAUC,IAAI,GAAGC,WAAiB1V,IAAS3E,KAAK4b,MAAMiC,MAAOlZ,GAC1E4a,EAASra,KACLlF,KAAK+iB,cAAc,UAAU7Q,EAAKvN,QAASuN,GAAO8Q,IAC9CA,EAAYlH,OAAS9b,KAAKmc,oBAGtC,CAGJ,IAAK,MAAM8G,KAAUjjB,KAAKgd,sBACtBiG,IAOJ,OAJA1D,EAASra,KAAKlF,KAAKkjB,wBAEnBljB,KAAKmjB,WAEE1X,QAAQ2U,IAAIb,GAAU1T,MAAK,QACtC,CAEQ,iBAAAuX,CAAkBlR,EAAaJ,GACnC,GAAII,EAAKmR,wBACL,IAAK,MAAML,KAAe9Q,EAAKmR,wBAC3BvR,EAASkR,EAGrB,CAEQ,cAAA3E,GACJ,MAAM3I,EAAyB,GAEzBmI,EAAQ7d,KAAK4b,MAAMiC,MACzB,GAAIA,EACA,IAAK,MAAM3L,KAAQ2L,EACf7d,KAAKojB,kBAAkBlR,GAAO8Q,IAC1B,MAAMM,EAAYN,EAAqBM,SACnCA,IAA8C,IAAlC5N,EAAWlQ,QAAQ8d,IAC/B5N,EAAWxQ,KAAKoe,MAMhC,OAAO5N,CACX,CAEQ,UAAAuI,GACJ,MAAM7W,EAAyB,GAG3BpH,KAAKmc,4BAA4B,KACjC/U,EAAOlC,KAAKlF,KAAKmc,kBAGrB,MAAM0B,EAAQ7d,KAAK4b,MAAMiC,MACzB,GAAIA,EACA,IAAK,MAAM3L,KAAQ2L,EACf7d,KAAKojB,kBAAkBlR,GAAO8Q,IAC1B5b,EAAOlC,KAAK8d,MAKxB,OAAO5b,CACX,CAEQ,kBAAAgX,GACJ,MAAMrI,EAAkC,GAElC8H,EAAQ7d,KAAK4b,MAAMiC,MACzB,GAAIA,EACA,IAAK,MAAM3L,KAAQ2L,EACX3L,EAAKkQ,uBAAuE,kBAA9ClQ,EAAKkQ,sBAAsBmB,gBACzDxN,EAAe7Q,KAAKgN,EAAKkQ,uBAEzBlQ,EAAKsR,8BACLzN,EAAe7Q,KAAKgN,EAAKsR,8BAKrC,OAAOzN,CACX,CAEQ,aAAAmI,GACJ,MAAMtI,EAAwB,GAExBwL,EAAQphB,KAAK4b,MAAMwF,MACzB,GAAIA,EACA,IAAK,MAAMqC,KAAQrC,EACXqC,EAAKC,OACL9N,EAAU1Q,KAAKue,EAAKC,MAAMC,iBAKtC,OAAO/N,CACX,CAEQ,mBAAAuI,GACJ,MAAMtI,EAAoC,GAEpCmL,EAAahhB,KAAK4b,MAAMoF,WAC9B,GAAIA,EACA,IAAK,MAAM4C,KAAa5C,EAChB4C,EAAUC,wBACVhO,EAAgB3Q,KAAK0e,EAAUC,wBAK3C,OAAOhO,CACX,CAEQ,gBAAA4K,GACJ,OAAQzgB,KAAK+b,QAAQnO,oBACjB,KAAKP,EAA6ByW,KAE9B,MAEJ,KAAKzW,EAA6BQ,MAAO,CACrC,MAAMkW,EAAyB/jB,KAAKme,sBACE,IAAlC4F,EAAuB5f,QACvB4f,EAAuB,GAAGC,OAAM,GAEpC,KACJ,CACA,KAAK3W,EAA6B4W,IAAK,CACnC,MAAMF,EAAyB/jB,KAAKme,sBACpC,IAAK,MAAM+F,KAAyBH,EAChCG,EAAsBF,OAAM,GAEhC,KACJ,CACA,QAEI,YADA,IAAOtc,MAAM,iCAAiC1H,KAAK+b,QAAQnO,uBAIvE,CAUO,aAAAmV,CAAc1I,EAAiBnI,EAAaL,EAAwD,QACvG,MAAM+Q,EAAmB5iB,KAAKmkB,yBAAyB9J,EAASnI,EAAML,GACtE,GAAI+Q,EACA,OAAOA,EAGX,GAAI1Q,EAAKkQ,sBACL,MAAM,IAAI1a,MAAM,GAAG2S,uCAGvB,MAAMkF,EAAW,IAAIjf,MAErBN,KAAK8iB,QAAQ,GAAGzI,KAAWnI,EAAKnN,MAAQ,MAExC,MAAMqf,EAAYC,IAId,GAHA7I,GAAW8I,mBAAmBD,EAAsBhK,GACpDmB,GAAWkH,eAAexQ,EAAMmS,GAEb9Q,MAAfrB,EAAKqD,OAAqB,CAC1B,MAAMA,EAAS4E,EAAUC,IAAI,GAAGC,WAAkBra,KAAK4b,MAAMtG,QAASpD,EAAKqD,QAC3EgK,EAASra,KACLlF,KAAKukB,gBAAgB,YAAYhP,EAAO5Q,QAAS4Q,GAASiP,IACtDA,EAAc1I,OAASuI,EAClBrkB,KAAKic,cAAcsG,uBACpB8B,EAAqBI,QAAQC,GAAK,MAIlD,CAEA,GAAIxS,EAAKoP,SACL,IAAK,MAAM3c,KAASuN,EAAKoP,SAAU,CAC/B,MAAMqD,EAAYxK,EAAUC,IAAI,GAAGC,cAAoB1V,IAAS3E,KAAK4b,MAAMiC,MAAOlZ,GAClF4a,EAASra,KACLlF,KAAK+iB,cAAc,UAAU4B,EAAUhgB,QAASggB,GAAYC,IACxDA,EAAiB9I,OAASuI,KAGtC,CAGJxS,EAAOwS,IAGLQ,EAAuBtR,MAAbrB,EAAK/K,KACf2d,EAAU9kB,KAAK+b,QAAQxN,WAA0BgF,MAAbrB,EAAKuR,KAE/C,IAAKoB,GAAWC,EAAS,CACrB,MAAMC,EAAW7S,EAAKnN,MAAQ,OAAOmN,EAAKvN,QAC1C3E,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAM0I,EAAgB,IAAI,IAAcD,EAAU/kB,KAAKic,eACvD+I,EAAcxjB,iBAAmBxB,KAAKsc,gBACtCtc,KAAKic,cAAcoG,wBAAyB,EAC3B9O,MAAbrB,EAAK/K,KACL+K,EAAKkQ,sBAAwB4C,EAE7B9S,EAAKsR,6BAA+BwB,EAExCZ,EAASY,EACb,CAEA,GAAIH,EACA,GAAIC,EAAS,CAKT,MAAM3d,EAAOgT,EAAUC,IAAI,GAAGC,SAAgBra,KAAK4b,MAAMxU,OAAQ8K,EAAK/K,MACtEoY,EAASra,KACLlF,KAAKilB,eAAe,WAAW9d,EAAKxC,QAASuN,EAAM/K,GAAOkd,IACtD,MAAMa,EAA8BhT,EAAKsR,6BAGzCa,EAAqBniB,UAAW,OAAUgjB,EAA4BhjB,SAAUmiB,EAAqBniB,UAAY,CAAC,GAElH,MAAMuhB,EAAOtJ,EAAUC,IAAI,GAAGC,SAAgBra,KAAK4b,MAAMwF,MAAOlP,EAAKuR,MACrElE,EAASra,KACLlF,KAAKmlB,eAAe,UAAU1B,EAAK9e,QAASuN,EAAMuR,GAAOE,IACrD3jB,KAAKojB,kBAAkBlR,GAAO8Q,IAC1BA,EAAYoC,SAAWzB,KAI3B3jB,KAAKgd,sBAAsB9X,MAAK,KAC5B,GAAqBqO,MAAjBkQ,EAAK2B,SAAuB,CAG5B,MAAMC,EAAalL,EAAUC,IAAI,UAAUqJ,EAAK9e,iBAAkB3E,KAAK4b,MAAMiC,MAAO4F,EAAK2B,UAAUtJ,OAC/F5J,EAAKvN,QAAU0gB,EAAW1gB,MAC1B0f,EAAqBvI,OAASoJ,EAA4BpJ,OAE1DuI,EAAqBvI,OAASuJ,EAAWjD,qBAEjD,MACIiC,EAAqBvI,OAAS9b,KAAKmc,iBAGvCnc,KAAK+b,QAAQ1L,uBAAuBiD,gBAAgB,CAAEpB,KAAMgT,EAA6B/S,YAAakS,cAM9H,KAAO,CACH,MAAMld,EAAOgT,EAAUC,IAAI,GAAGC,SAAgBra,KAAK4b,MAAMxU,OAAQ8K,EAAK/K,MACtEoY,EAASra,KAAKlF,KAAKilB,eAAe,WAAW9d,EAAKxC,QAASuN,EAAM/K,EAAMid,GAC3E,CAKJ,OAFApkB,KAAKmjB,WAEE1X,QAAQ2U,IAAIb,GAAU1T,MAAK,KAC9B7L,KAAKojB,kBAAkBlR,GAAO8Q,IAC1B,MAAMsC,EAAStC,GACVsC,EAAOC,cAAgBD,EAAOhC,UAAYgC,EAAOhC,SAASkC,4BAE3DxC,EAAYyC,sBAEZzC,EAAY0C,qBAAoB,GAAM,MAIvCxT,EAAKkQ,wBAEpB,CAGQ,cAAA6C,CAAe5K,EAAiBnI,EAAa/K,EAAa0K,GAC9D,MAAM8T,EAAaxe,EAAKwe,WACxB,IAAKA,IAAeA,EAAWxhB,OAC3B,MAAM,IAAIuD,MAAM,GAAG2S,6BAGI9G,MAAvBoS,EAAW,GAAGhhB,OACdwV,EAAUK,OAAOmL,GAGrB,MAAMpG,EAAW,IAAIjf,MAErBN,KAAK8iB,QAAQ,GAAGzI,KAAWlT,EAAKpC,MAAQ,MAExC,MAAMA,EAAOmN,EAAKnN,MAAQ,OAAOmN,EAAKvN,QAEtC,GAA0B,IAAtBghB,EAAWxhB,OAAc,CACzB,MAAMyhB,EAAYze,EAAKwe,WAAW,GAClCpG,EAASra,KACLlF,KAAK6lB,wBAAwB,GAAGxL,gBAAsBuL,EAAUjhB,QAASI,EAAMmN,EAAM/K,EAAMye,GAAY5C,IACnG9Q,EAAKkQ,sBAAwBY,EAC7B9Q,EAAKmR,wBAA0B,CAACL,MAG5C,KAAO,CACHhjB,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnDpK,EAAKkQ,sBAAwB,IAAI,IAAcrd,EAAM/E,KAAKic,eAC1D/J,EAAKkQ,sBAAsB5gB,iBAAmBxB,KAAKsc,gBACnDtc,KAAKic,cAAcoG,wBAAyB,EAC5CnQ,EAAKmR,wBAA0B,GAC/B,IAAK,MAAMuC,KAAaD,EACpBpG,EAASra,KACLlF,KAAK6lB,wBAAwB,GAAGxL,gBAAsBuL,EAAUjhB,QAAS,GAAGI,cAAiB6gB,EAAUjhB,QAASuN,EAAM/K,EAAMye,GAAY5C,IACpIA,EAAYlH,OAAS5J,EAAKkQ,sBAC1BlQ,EAAKmR,wBAAyBne,KAAK8d,MAInD,CAMA,OAJAnR,EAAOK,EAAKkQ,uBAEZpiB,KAAKmjB,WAEE1X,QAAQ2U,IAAIb,GAAU1T,MAAK,IACvBqG,EAAKkQ,uBAEpB,CAaO,uBAAAyD,CACHxL,EACAtV,EACAmN,EACA/K,EACAye,EACA/T,GAEA,MAAM+Q,EAAmB5iB,KAAK8lB,kCAAkCzL,EAAStV,EAAMmN,EAAM/K,EAAMye,EAAW/T,GACtG,GAAI+Q,EACA,OAAOA,EAGX5iB,KAAK8iB,QAAQ,GAAGzI,KAEhB,MAAM0L,EAAgD,IAA/B/lB,KAAKwc,uBAA+Bxc,KAAK+b,QAAQ7N,iBAAgCqF,MAAbrB,EAAKuR,OAAsBtc,EAAKwe,WAAW,GAAGlf,QAEzI,IAAIuf,EACAC,EAEJ,GAAIF,GAAkBH,EAAUM,cAC5BlmB,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD0J,EAAsBJ,EAAUM,cAAcC,kBAAkBC,eAAerhB,GAC/EihB,EAAoBxkB,iBAAmBxB,KAAKsc,gBAC5Ctc,KAAKic,cAAcoG,wBAAyB,EAC5C4D,EAAUL,EAAUM,cAAcD,YAC/B,CACH,MAAM1G,EAAW,IAAIjf,MAErBN,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAM0G,EAAc,IAAI,IAAKje,EAAM/E,KAAKic,eAqBxC,GApBA+G,EAAYxhB,iBAAmBxB,KAAKsc,gBACpCtc,KAAKic,cAAcoG,wBAAyB,EAC5CW,EAAYqD,gBAAkBrmB,KAAKic,cAAcsG,qBAAuB,IAAS+D,gCAAkC,IAASC,yBAE5HvmB,KAAKwmB,oBAAoBnM,EAASnI,EAAM/K,EAAMye,EAAW5C,GACzDzD,EAASra,KACLlF,KAAKymB,qBAAqBpM,EAASuL,EAAW5C,GAAanX,MAAK8R,MAAO+I,SACtD1mB,KAAK2mB,uBAAuBtM,EAASuL,EAAW5C,EAAa0D,GAAiB7a,MAAK,KACxF7L,KAAK4c,YAIT5c,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnDoK,EAAgBE,YAAY5D,GAC5B0D,EAAgBllB,iBAAmBxB,KAAKsc,gBACxCtc,KAAKic,cAAcoG,wBAAyB,UAKnDriB,KAAK8b,OAAOtN,cAAe,CAC5B,MAAMqR,EAAkBrE,GAAWqL,aAAaxM,EAASuL,EAAUkB,MACnE,GAA0BvT,MAAtBqS,EAAUzQ,SAAuB,CACjC,IAAI4R,EAAkB/mB,KAAK+c,4BAA4B8C,GAClDkH,IACDA,EAAkB/mB,KAAKgnB,uBAAuB,wBAAyBnH,GACvE7f,KAAK+b,QAAQxL,2BAA2B+C,gBAAgByT,GACxD/mB,KAAK+c,4BAA4B8C,GAAmBkH,GAExD/D,EAAY7N,SAAW4R,CAC3B,KAAO,CACH,MAAM5R,EAAWgF,EAAUC,IAAI,GAAGC,aAAoBra,KAAK4b,MAAM1G,UAAW0Q,EAAUzQ,UACtFoK,EAASra,KACLlF,KAAK+f,mBAAmB,cAAc5K,EAASxQ,QAASwQ,EAAU6N,EAAanD,GAAkBkH,IAC7F/D,EAAY7N,SAAW4R,KAGnC,CACJ,CAEAd,EAAUxa,QAAQ2U,IAAIb,GAElBwG,IACAH,EAAUM,cAAgB,CACtBC,kBAAmBnD,EACnBiD,QAASA,IAIjBD,EAAsBhD,CAC1B,CAQA,OANAxH,GAAW8I,mBAAmB0B,EAAqB3L,GACnDra,KAAK+b,QAAQ3L,uBAAuBkD,gBAAgB0S,GACpDnU,EAAOmU,GAEPhmB,KAAKmjB,WAEE8C,EAAQpa,MAAK,IACTma,GAEf,CAGQ,oBAAAS,CAAqBpM,EAAiBuL,EAA2B5C,GACrE,MAAMJ,EAAmB5iB,KAAKinB,+BAA+B5M,EAASuL,EAAW5C,GACjF,GAAIJ,EACA,OAAOA,EAGX,MAAMsE,EAAatB,EAAUsB,WAC7B,IAAKA,EACD,MAAM,IAAIxf,MAAM,GAAG2S,6BAGvB,MAAMkF,EAAW,IAAIjf,MAEfomB,EAAkB,IAAI,IAAS1D,EAAYje,KAAM/E,KAAKic,eAE5D,GAAyB1I,MAArBqS,EAAUuB,QACVnE,EAAYoE,aAAc,MACvB,CACH,MAAM1M,EAAWP,EAAUC,IAAI,GAAGC,YAAmBra,KAAK4b,MAAMmF,UAAW6E,EAAUuB,SACrF5H,EAASra,KACLlF,KAAKqnB,0BAA0B,cAAc3M,EAAS/V,QAAS+V,GAAU7O,MAAMjH,IAC3E8hB,EAAgBY,WAAW1iB,MAGvC,CAEA,MAAM2iB,EAAgB,CAACxiB,EAAcyiB,EAAc1V,KAC/C,GAAwByB,MAApB2T,EAAWniB,GACX,OAGJie,EAAYyE,WAAazE,EAAYyE,YAAc,IACL,IAA1CzE,EAAYyE,WAAWjiB,QAAQgiB,IAC/BxE,EAAYyE,WAAWviB,KAAKsiB,GAGhC,MAAM9M,EAAWP,EAAUC,IAAI,GAAGC,gBAAsBtV,IAAQ/E,KAAK4b,MAAMmF,UAAWmG,EAAWniB,IACjGwa,EAASra,KACLlF,KAAK0nB,yBAAyB,cAAchN,EAAS/V,QAAS+V,EAAU8M,GAAM3b,MAAM8b,IAChF,GAAIA,EAAoBC,YAAc,IAAaC,eAAiB7nB,KAAK8b,OAAOpO,2BAA6BsV,EAAYoC,SAAU,CAC/H,MAAM0C,EAAsBrN,EAAqCC,GAC7DoN,IACApB,EAAgBqB,cAAgBD,EAChCpB,EAAgBlB,6BAA8B,EAEtD,CACAkB,EAAgBsB,kBAAkBL,EAAqBjN,EAASuN,WAIpET,GAAQ,IAAaU,2BACrBlF,EAAYmF,mBAAqB,GAGjCrW,GACAA,EAAS4I,IAuBjB,OAnBA6M,EAAc,WAAY,IAAaM,cACvCN,EAAc,SAAU,IAAaa,YACrCb,EAAc,UAAW,IAAac,aACtCd,EAAc,aAAc,IAAae,QACzCf,EAAc,aAAc,IAAagB,SACzChB,EAAc,aAAc,IAAaiB,SACzCjB,EAAc,aAAc,IAAakB,SACzClB,EAAc,aAAc,IAAamB,SACzCnB,EAAc,aAAc,IAAaoB,SACzCpB,EAAc,WAAY,IAAaqB,qBACvCrB,EAAc,YAAa,IAAasB,qBACxCtB,EAAc,WAAY,IAAaW,0BACvCX,EAAc,YAAa,IAAauB,0BACxCvB,EAAc,UAAW,IAAawB,WAAYrO,IACxB,SAAlBA,EAASpO,OACT0W,EAAYgG,gBAAiB,MAI9Bvd,QAAQ2U,IAAIb,GAAU1T,MAAK,IACvB6a,GAEf,CAEQ,mBAAAF,CAAoBnM,EAAiBnI,EAAa/K,EAAaye,EAA2B5C,GAC9F,IAAK4C,EAAUnf,UAAYzG,KAAK+b,QAAQ3N,iBACpC,OAGJ,GAA6BmF,MAAzBrB,EAAK+W,iBACL/W,EAAK+W,iBAAmBrD,EAAUnf,QAAQtC,YACvC,GAAIyhB,EAAUnf,QAAQtC,SAAW+N,EAAK+W,iBACzC,MAAM,IAAIvhB,MAAM,GAAG2S,wDAGvB,MAAM6O,EAAc/hB,EAAKgiB,OAAShiB,EAAKgiB,OAAOD,YAAc,KAE5DlpB,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD0G,EAAY3b,mBAAqB,IAAIxH,EAAmBG,KAAKic,eAC7D+G,EAAY3b,mBAAmB7F,iBAAmBxB,KAAKsc,gBACvDtc,KAAKic,cAAcoG,wBAAyB,EAE5CW,EAAY3b,mBAAmBvH,kBAAmB,EAElD,IAAK,IAAI6E,EAAQ,EAAGA,EAAQihB,EAAUnf,QAAQtC,OAAQQ,IAAS,CAC3D,MAAMykB,EAASlX,EAAKmX,QAAUnX,EAAKmX,QAAQ1kB,GAASwC,EAAKkiB,QAAUliB,EAAKkiB,QAAQ1kB,GAAS,EACnFI,EAAOmkB,EAAcA,EAAYvkB,GAAS,cAAcA,IAC9Dqe,EAAY3b,mBAAmBpC,UAAU,IAAI,EAAAqE,EAAYvE,EAAMqkB,EAAQpG,EAAYsG,YAEvF,CACJ,CAGQ,sBAAA3C,CAAuBtM,EAAiBuL,EAA2B5C,EAAmB0D,GAC1F,IAAKd,EAAUnf,UAAYzG,KAAK+b,QAAQ3N,iBACpC,OAAO3C,QAAQC,UAGnB,MAAM6T,EAAW,IAAIjf,MAEf+G,EAAqB2b,EAAY3b,mBACvC,IAAK,IAAI1C,EAAQ,EAAGA,EAAQ0C,EAAmBnD,WAAYS,IAAS,CAChE,MAAM4kB,EAAqBliB,EAAmBxC,UAAUF,GACxD4a,EAASra,KAAKlF,KAAKwpB,gCAAgC,GAAGnP,aAAmB1V,IAAS+hB,EAAiBd,EAAUnf,QAAQ9B,GAAQ4kB,GACjI,CAEA,OAAO9d,QAAQ2U,IAAIb,GAAU1T,MAAK,KAC9BxE,EAAmBvH,kBAAmB,IAE9C,CAEQ,qCAAM0pB,CACVnP,EACAqM,EACAQ,EACAqC,GAEA,MAAMhK,EAAW,IAAIjf,MAEfinB,EAAgB,CAACkC,EAAmBjC,EAAckC,KACpD,GAA6BnW,MAAzB2T,EAAWuC,GACX,OAGJ,MAAM9B,EAAsBjB,EAAgBiD,gBAAgBnC,GAC5D,IAAKG,EACD,OAGJ,MAAMjN,EAAWP,EAAUC,IAAI,GAAGC,KAAWoP,IAAazpB,KAAK4b,MAAMmF,UAAWmG,EAAWuC,IAC3FlK,EAASra,KACLlF,KAAK4pB,wBAAwB,cAAclP,EAAS/V,QAAS+V,GAAU7O,MAAMjH,IACzE8kB,EAAQ/B,EAAqB/iB,QAgFzC,OA3EA2iB,EAAc,WAAY,IAAaM,cAAc,CAACF,EAAqB/iB,KACvE,MAAMoD,EAAY,IAAIlB,aAAalC,EAAKT,QACxCwjB,EAAoBlK,QAAQ7Y,EAAKT,QAAQ,CAAChB,EAAOwB,KAC7CqD,EAAUrD,GAASC,EAAKD,GAASxB,KAGrComB,EAAmBM,aAAa7hB,MAGpCuf,EAAc,SAAU,IAAaa,YAAY,CAACT,EAAqB/iB,KACnE,MAAMsD,EAAU,IAAIpB,aAAalC,EAAKT,QACtCwjB,EAAoBlK,QAAQvV,EAAQ/D,QAAQ,CAAChB,EAAOwB,KAChDuD,EAAQvD,GAASC,EAAKD,GAASxB,KAGnComB,EAAmBO,WAAW5hB,MAGlCqf,EAAc,UAAW,IAAac,aAAa,CAACV,EAAqB/iB,KACrE,MAAM0D,EAAW,IAAIxB,aAAclC,EAAKT,OAAS,EAAK,GACtD,IAAI4lB,EAAY,EAChBpC,EAAoBlK,QAAS7Y,EAAKT,OAAS,EAAK,GAAG,CAAChB,EAAOwB,MAIlDA,EAAQ,GAAK,GAAM,IACpB2D,EAASyhB,GAAanlB,EAAKmlB,GAAa5mB,EACxC4mB,QAGRR,EAAmBS,YAAY1hB,MAGnCif,EAAc,aAAc,IAAae,QAAQ,CAACX,EAAqB/iB,KACnE,MAAMwD,EAAM,IAAItB,aAAalC,EAAKT,QAClCwjB,EAAoBlK,QAAQ7Y,EAAKT,QAAQ,CAAChB,EAAOwB,KAC7CyD,EAAIzD,GAASC,EAAKD,GAASxB,KAG/BomB,EAAmBU,OAAO7hB,MAG9Bmf,EAAc,aAAc,IAAagB,SAAS,CAACZ,EAAqB/iB,KACpE,MAAMwD,EAAM,IAAItB,aAAalC,EAAKT,QAClCwjB,EAAoBlK,QAAQ7Y,EAAKT,QAAQ,CAAChB,EAAOwB,KAC7CyD,EAAIzD,GAASC,EAAKD,GAASxB,KAG/BomB,EAAmBW,QAAQ9hB,MAG/Bmf,EAAc,UAAW,IAAawB,WAAW,CAACpB,EAAqB/iB,KACnE,IAAI8D,EAAS,KACb,MAAMyhB,EAAgBxC,EAAoByC,UAC1C,GAAsB,IAAlBD,EAAqB,CACrBzhB,EAAS,IAAI5B,aAAclC,EAAKT,OAAS,EAAK,GAC9CwjB,EAAoBlK,QAAQ7Y,EAAKT,QAAQ,CAAChB,EAAOwB,KAC7C,MAAM0lB,EAAQziB,KAAK0iB,MAAM3lB,EAAQ,GAC3B4lB,EAAU5lB,EAAQ,EACxB+D,EAAO,EAAI2hB,EAAQE,GAAW3lB,EAAK,EAAIylB,EAAQE,GAAWpnB,KAE9D,IAAK,IAAIqnB,EAAI,EAAGA,EAAI5lB,EAAKT,OAAS,IAAKqmB,EACnC9hB,EAAO,EAAI8hB,EAAI,GAAK,CAE5B,KAAO,IAAsB,IAAlBL,EAMP,MAAM,IAAIziB,MAAM,GAAG2S,oCAA0C8P,4BAL7DzhB,EAAS,IAAI5B,aAAalC,EAAKT,QAC/BwjB,EAAoBlK,QAAQ7Y,EAAKT,QAAQ,CAAChB,EAAOwB,KAC7C+D,EAAO/D,GAASC,EAAKD,GAASxB,IAItC,CACAomB,EAAmBkB,UAAU/hB,YAGpB+C,QAAQ2U,IAAIb,GAAU1T,MAAK,QAC5C,CAEQ,qBAAO6W,CAAexQ,EAAawY,GAGvC,GAAiBnX,MAAbrB,EAAKuR,KACL,OAGJ,IAAIkH,EAAW,KAAQC,OACnBpI,EAAW,KAAWqI,WACtBpG,EAAU,KAAQqG,MAElB5Y,EAAK6Y,OACU,KAAOC,UAAU9Y,EAAK6Y,QAC9BE,UAAUxG,EAASjC,EAAUmI,IAEhCzY,EAAKgZ,cACLP,EAAW,KAAQK,UAAU9Y,EAAKgZ,cAElChZ,EAAKsQ,WACLA,EAAW,KAAWwI,UAAU9Y,EAAKsQ,WAErCtQ,EAAKuQ,QACLgC,EAAU,KAAQuG,UAAU9Y,EAAKuQ,SAIzCiI,EAAYC,SAAWA,EACvBD,EAAYS,mBAAqB3I,EACjCkI,EAAYjG,QAAUA,CAC1B,CAGQ,cAAAU,CAAe9K,EAAiBnI,EAAauR,EAAa5R,GAC9D,IAAK7R,KAAK+b,QAAQxN,UACd,OAAO9C,QAAQC,UAGnB,MAAMkX,EAAmB5iB,KAAKorB,yBAAyB/Q,EAASnI,EAAMuR,GACtE,GAAIb,EACA,OAAOA,EAGX,GAAIa,EAAKC,MAEL,OADA7R,EAAO4R,EAAKC,MAAMC,iBACXF,EAAKC,MAAMuC,QAGtB,MAAMoF,EAAa,WAAW5H,EAAK9e,QACnC3E,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAMqH,EAAkB,IAAI,IAASF,EAAK1e,MAAQsmB,EAAYA,EAAYrrB,KAAKic,eAC/E0H,EAAgBniB,iBAAmBxB,KAAKsc,gBACxCtc,KAAKic,cAAcoG,wBAAyB,EAE5CriB,KAAKsrB,WAAWjR,EAASoJ,EAAME,GAC/B,MAAMsC,EAAUjmB,KAAKurB,sCAAsClR,EAASoJ,GAAM5X,MAAM2f,IAC5ExrB,KAAKyrB,oBAAoB9H,EAAiB6H,MAU9C,OAPA/H,EAAKC,MAAQ,CACTC,gBAAiBA,EACjBsC,QAASA,GAGbpU,EAAO8R,GAEAsC,CACX,CAEQ,UAAAqF,CAAWjR,EAAiBoJ,EAAaE,GAC7C,GAAqBpQ,MAAjBkQ,EAAK2B,UAAyBplB,KAAK+b,QAAQpO,8BAA+B,CAC1E,MAAM4T,EAAWvhB,KAAK0rB,sBAAsB,GAAGrR,WAAkBoJ,EAAKkI,QACtE,GAAIpK,EACA,QAAsBhO,IAAlBkQ,EAAK2B,SACL3B,EAAK2B,SAAW7D,EAAS5c,UACtB,CACH,MAAMinB,EAAW,CAAC5S,EAAUC,KACxB,KAAOA,EAAE6C,OAAQ7C,EAAIA,EAAE6C,OACnB,GAAI7C,EAAE6C,SAAW9C,EACb,OAAO,EAIf,OAAO,GAGL6S,EAAe1R,EAAUC,IAAI,GAAGC,aAAoBra,KAAK4b,MAAMiC,MAAO4F,EAAK2B,UAC7EyG,IAAiBtK,GAAaqK,EAASC,EAActK,KACrD,IAAOxN,KAAK,GAAGsG,6FACfoJ,EAAK2B,SAAW7D,EAAS5c,MAEjC,MAEA,IAAOoP,KAAK,GAAGsG,gCAEvB,CAEA,MAAMyR,EAA0C,CAAC,EACjD,IAAK,MAAMnnB,KAAS8e,EAAKkI,OAAQ,CAC7B,MAAMzZ,EAAOiI,EAAUC,IAAI,GAAGC,YAAkB1V,IAAS3E,KAAK4b,MAAMiC,MAAOlZ,GAC3E3E,KAAK+rB,UAAU7Z,EAAMuR,EAAME,EAAiBmI,EAChD,CACJ,CAEQ,qBAAAJ,CAAsBrR,EAAiBsR,GAC3C,GAAsB,IAAlBA,EAAOxnB,OACP,OAAO,KAGX,MAAM6nB,EAA2C,CAAC,EAClD,IAAK,MAAMrnB,KAASgnB,EAAQ,CACxB,MAAMM,EAAgB,GACtB,IAAI/Z,EAAOiI,EAAUC,IAAI,GAAGC,KAAW1V,IAAS3E,KAAK4b,MAAMiC,MAAOlZ,GAClE,MAAuB,IAAhBuN,EAAKvN,OACRsnB,EAAKC,QAAQha,GACbA,EAAOA,EAAK4J,OAEhBkQ,EAAMrnB,GAASsnB,CACnB,CAEA,IAAI1K,EAA4B,KAChC,IAAK,IAAIiJ,EAAI,KAAOA,EAAG,CACnB,IAAIyB,EAAOD,EAAML,EAAO,IACxB,GAAInB,GAAKyB,EAAK9nB,OACV,OAAOod,EAGX,MAAMrP,EAAO+Z,EAAKzB,GAClB,IAAK,IAAI2B,EAAI,EAAGA,EAAIR,EAAOxnB,SAAUgoB,EAEjC,GADAF,EAAOD,EAAML,EAAOQ,IAChB3B,GAAKyB,EAAK9nB,QAAU+N,IAAS+Z,EAAKzB,GAClC,OAAOjJ,EAIfA,EAAWrP,CACf,CACJ,CAEQ,SAAA6Z,CAAU7Z,EAAauR,EAAaE,EAA2BmI,GACnE5Z,EAAKka,UAAW,EAEhB,IAAIC,EAAcP,EAAa5Z,EAAKvN,OACpC,GAAI0nB,EACA,OAAOA,EAGX,IAAIC,EAAoC,KACpCpa,EAAKvN,QAAU8e,EAAK2B,WAChBlT,EAAK4J,SAAiC,IAAvB5J,EAAK4J,OAAOnX,MAC3B2nB,EAAoBtsB,KAAK+rB,UAAU7Z,EAAK4J,OAAQ2H,EAAME,EAAiBmI,QAC9CvY,IAAlBkQ,EAAK2B,UACZ,IAAOrR,KAAK,UAAU0P,EAAK9e,uDAInC,MAAM4nB,EAAY9I,EAAKkI,OAAOnmB,QAAQ0M,EAAKvN,OAW3C,OAVA0nB,EAAc,IAAI,IAAKna,EAAKnN,MAAQ,QAAQmN,EAAKvN,QAASgf,EAAiB2I,EAAmBtsB,KAAKwsB,eAAeta,GAAO,KAAM,KAAMqa,GACrIT,EAAa5Z,EAAKvN,OAAS0nB,EAG3BrsB,KAAKgd,sBAAsB9X,MAAK,KAG5BmnB,EAAYI,kBAAkBva,EAAKkQ,0BAGhCiK,CACX,CAEQ,qCAAAd,CAAsClR,EAAiBoJ,GAC3D,GAAgClQ,MAA5BkQ,EAAKiJ,oBACL,OAAOjhB,QAAQC,QAAQ,MAG3B,MAAMgP,EAAWP,EAAUC,IAAI,GAAGC,wBAA+Bra,KAAK4b,MAAMmF,UAAW0C,EAAKiJ,qBAC5F,OAAO1sB,KAAK4pB,wBAAwB,cAAclP,EAAS/V,QAAS+V,EACxE,CAEQ,mBAAA+Q,CAAoB9H,EAA2B6H,GACnD,IAAK,MAAMa,KAAe1I,EAAgBgJ,MAAO,CAC7C,MAAMC,EAAa,KAAO/B,WACpB0B,EAAYF,EAAYQ,OAC1BrB,IAA0C,IAAfe,IAC3B,KAAOO,eAAetB,EAAqC,GAAZe,EAAgBK,GAC/DA,EAAWG,YAAYH,IAG3B,MAAMI,EAAoBX,EAAYY,YAClCD,GACAJ,EAAWM,cAAcF,EAAkBG,+BAAgCP,GAG/EP,EAAYe,aAAaR,GAAY,GAAO,GAC5CP,EAAYgB,iCAA4B9Z,GAAW,EACvD,CACJ,CAEQ,cAAAiZ,CAAeta,GACnB,OAAOA,EAAK6Y,OACN,KAAOC,UAAU9Y,EAAK6Y,QACtB,KAAOuC,QACHpb,EAAKuQ,MAAQ,KAAQuI,UAAU9Y,EAAKuQ,OAAS,KAAQqI,MACrD5Y,EAAKsQ,SAAW,KAAWwI,UAAU9Y,EAAKsQ,UAAY,KAAWqI,WACjE3Y,EAAKgZ,YAAc,KAAQF,UAAU9Y,EAAKgZ,aAAe,KAAQN,OAE/E,CASO,eAAArG,CAAgBlK,EAAiB9E,EAAiB1D,EAA0C,QAC/F,MAAM+Q,EAAmB5iB,KAAKutB,2BAA2BlT,EAAS9E,EAAQ1D,GAC1E,GAAI+Q,EACA,OAAOA,EAGX,MAAMrD,EAAW,IAAIjf,MAErBN,KAAK8iB,QAAQ,GAAGzI,KAAW9E,EAAOxQ,MAAQ,MAE1C/E,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAMkI,EAAgB,IAAI,IAAWjP,EAAOxQ,MAAQ,SAASwQ,EAAO5Q,QAAS,KAAQimB,OAAQ5qB,KAAKic,eAAe,GAQjH,OAPAuI,EAAchjB,iBAAmBxB,KAAKsc,gBACtCtc,KAAKic,cAAcoG,wBAAyB,EAC5C9M,EAAOiY,eAAiBhJ,EAGxBA,EAAciJ,UAAU,IAAI,KAAQ,EAAG,GAAI,IAEnClY,EAAOjJ,MACX,IAAK,cAAwB,CACzB,MAAMohB,EAAcnY,EAAOmY,YAC3B,IAAKA,EACD,MAAM,IAAIhmB,MAAM,GAAG2S,gDAGvBmK,EAAcmJ,IAAMD,EAAYE,KAChCpJ,EAAcqJ,KAAOH,EAAYI,MACjCtJ,EAAcuJ,KAAOL,EAAYM,MAAQ,EACzC,KACJ,CACA,IAAK,eACD,IAAKzY,EAAO0Y,aACR,MAAM,IAAIvmB,MAAM,GAAG2S,iDAGvBmK,EAAcsC,KAAO,IAAOoH,oBAC5B1J,EAAc2J,WAAa5Y,EAAO0Y,aAAaG,KAC/C5J,EAAc6J,WAAa9Y,EAAO0Y,aAAaG,KAC/C5J,EAAc8J,aAAe/Y,EAAO0Y,aAAaM,KACjD/J,EAAcgK,SAAWjZ,EAAO0Y,aAAaM,KAC7C/J,EAAcqJ,KAAOtY,EAAO0Y,aAAaH,MACzCtJ,EAAcuJ,KAAOxY,EAAO0Y,aAAaD,KACzC,MAEJ,QACI,MAAM,IAAItmB,MAAM,GAAG2S,2BAAiC9E,EAAOjJ,SAUnE,OANAkP,GAAW8I,mBAAmBE,EAAenK,GAC7Cra,KAAK+b,QAAQvL,yBAAyB8C,gBAAgBkR,GACtD3S,EAAO2S,GAEPxkB,KAAKmjB,WAEE1X,QAAQ2U,IAAIb,GAAU1T,MAAK,IACvB2Y,GAEf,CAEQ,oBAAAtB,GACJljB,KAAK+b,QAAQvK,yBAAyB,mBAEtC,MAAMwP,EAAahhB,KAAK4b,MAAMoF,WAC9B,IAAKA,EACD,OAAOvV,QAAQC,UAGnB,MAAM6T,EAAW,IAAIjf,MAErB,IAAK,IAAIqE,EAAQ,EAAGA,EAAQqc,EAAW7c,OAAQQ,IAAS,CACpD,MAAMif,EAAY5C,EAAWrc,GAC7B4a,EAASra,KACLlF,KAAKyuB,mBAAmB,eAAe7K,EAAUjf,QAASif,GAAW/X,MAAM6iB,IAEtB,IAA7CA,EAAeC,mBAAmBxqB,QAClCuqB,EAAejnB,aAI/B,CAEA,OAAOgE,QAAQ2U,IAAIb,GAAU1T,MAAK,KAC9B7L,KAAK+b,QAAQrK,uBAAuB,qBAE5C,CAQO,kBAAA+c,CAAmBpU,EAAiBuJ,GACvC5jB,KAAK+b,QAAQvK,yBAAyB,kBAGtC,OADgBxR,KAAK4uB,8BAA8BvU,EAASuJ,IAMrD3J,EAAgC9W,MAAM0I,MAAK,EAAGgjB,qBACjD7uB,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAM4H,EAAwB,IAAI2K,EAAejL,EAAU7e,MAAQ,YAAY6e,EAAUjf,QAAS3E,KAAKic,eACvGiI,EAAsB1iB,iBAAmBxB,KAAKsc,gBAC9Ctc,KAAKic,cAAcoG,wBAAyB,EAC5CuB,EAAUC,uBAAyBK,EAEnC,MAAM3E,EAAW,IAAIjf,MAErB6Z,EAAUK,OAAOoJ,EAAUkL,UAC3B3U,EAAUK,OAAOoJ,EAAUzC,UAE3B,IAAK,MAAMoJ,KAAW3G,EAAUkL,SAC5BvP,EAASra,KACLlF,KAAK+uB,2BAA2B,GAAG1U,cAAoBkQ,EAAQ5lB,QAAS0V,EAASuJ,EAAW2G,GAAS,CAACyE,EAAeC,KACjHD,EAAchO,WAAagO,EAAchO,YAAc,GACvDgO,EAAchO,WAAW9b,KAAK+pB,GAC9B/K,EAAsBgL,qBAAqBD,EAAkBD,OAOzE,OAFAhvB,KAAK+b,QAAQrK,uBAAuB,kBAE7BjG,QAAQ2U,IAAIb,GAAU1T,MAAK,KAC9BqY,EAAsBiL,UAAU,GACzBjL,OAGnB,CAYO,0BAAA6K,CACH1U,EACA+U,EACAxL,EACA2G,EACA8E,GAEA,MAAMpJ,EAAUjmB,KAAKsvB,qCAAqCjV,EAAS+U,EAAkBxL,EAAW2G,EAAS8E,GACzG,GAAIpJ,EACA,OAAOA,EAGX,GAA2B1S,MAAvBgX,EAAQvlB,OAAOkN,KACf,OAAOzG,QAAQC,UAGnB,MAAM6jB,EAAapV,EAAUC,IAAI,GAAGC,gBAAuBra,KAAK4b,MAAMiC,MAAO0M,EAAQvlB,OAAOkN,MACtFsd,EAAoBjF,EAAQvlB,OAAOinB,KACnCwD,EAAsC,YAAtBD,EAGtB,OAAKC,IAAkBF,EAAWtG,mBAAuBwG,IAAkBF,EAAWnN,sBAC3E3W,QAAQC,UAId1L,KAAK+b,QAAQ1N,oBAAuBohB,GAAkBF,EAAWnD,SAK/DlS,EAAiC/W,MAAM0I,MAAK,KAC/C,IAAI6jB,EACJ,OAAQF,GACJ,IAAK,cACDE,GAAa,QAAiB,0BAA0BC,cACxD,MAEJ,IAAK,WACDD,GAAa,QAAiB,uBAAuBC,cACrD,MAEJ,IAAK,QACDD,GAAa,QAAiB,oBAAoBC,cAClD,MAEJ,IAAK,UACDD,GAAa,QAAiB,sBAAsBC,cACpD,MAEJ,QACI,MAAM,IAAIjoB,MAAM,GAAG2S,iCAAuCkQ,EAAQvlB,OAAOinB,SAIjF,IAAKyD,EACD,MAAM,IAAIhoB,MAAM,GAAG2S,2EAAiFkQ,EAAQvlB,OAAOinB,SAGvH,MAAM2D,EAAwD,CAC1DC,OAAQN,EACRO,KAAMJ,GAGV,OAAO1vB,KAAK+vB,yCAAyC1V,EAAS+U,EAAkBxL,EAAW2G,EAASqF,EAAYP,MArCzG5jB,QAAQC,SAuCvB,CAaO,wCAAAqkB,CACH1V,EACA+U,EACAxL,EACA2G,EACAqF,EACAP,GAEA,MAAMW,EAAMhwB,KAAK8b,OAAOrN,UAClBwhB,EAAS,EAAID,EAEbE,EAAU/V,EAAUC,IAAI,GAAGC,YAAmBuJ,EAAUzC,SAAUoJ,EAAQ2F,SAChF,OAAOlwB,KAAKmwB,2BAA2B,GAAGf,cAA6B7E,EAAQ2F,UAAWA,GAASrkB,MAAMjH,IACrG,IAAIwrB,EAAgB,EAEpB,MAAMprB,EAAS4qB,EAAWC,OACpBQ,EAAgBT,EAAWE,KAMjC,IAAK,MAAMQ,KAAgBD,EAAe,CACtC,MAAME,EAASD,EAAaE,UAAUxrB,GAChCyrB,EAAQ7rB,EAAK6rB,MACbC,EAAS9rB,EAAK8rB,OACdC,EAAO,IAAIrwB,MAAqBmwB,EAAMtsB,QAC5C,IAAIysB,EAAe,EAEnB,OAAQhsB,EAAK+qB,eACT,IAAK,OACD,IAAK,IAAIhrB,EAAQ,EAAGA,EAAQ8rB,EAAMtsB,OAAQQ,IAAS,CAC/C,MAAMxB,EAAQmtB,EAAaO,SAAS7rB,EAAQ0rB,EAAQE,EAAc,GAClEA,GAAgBL,EAEhBI,EAAKhsB,GAAS,CACVmsB,MAAOL,EAAM9rB,GAASqrB,EACtB7sB,MAAOA,EACPwsB,cAAe,EAEvB,CACA,MAEJ,IAAK,cACD,IAAK,IAAIhrB,EAAQ,EAAGA,EAAQ8rB,EAAMtsB,OAAQQ,IAAS,CAC/C,MAAMosB,EAAYT,EAAaO,SAAS7rB,EAAQ0rB,EAAQE,EAAcX,GACtEW,GAAgBL,EAChB,MAAMptB,EAAQmtB,EAAaO,SAAS7rB,EAAQ0rB,EAAQE,EAAc,GAClEA,GAAgBL,EAChB,MAAMS,EAAaV,EAAaO,SAAS7rB,EAAQ0rB,EAAQE,EAAcX,GACvEW,GAAgBL,EAEhBI,EAAKhsB,GAAS,CACVmsB,MAAOL,EAAM9rB,GAASqrB,EACtBe,UAAWA,EACX5tB,MAAOA,EACP6tB,WAAYA,EAEpB,CACA,MAEJ,IAAK,SACD,IAAK,IAAIrsB,EAAQ,EAAGA,EAAQ8rB,EAAMtsB,OAAQQ,IAAS,CAC/C,MAAMxB,EAAQmtB,EAAaO,SAAS7rB,EAAQ0rB,EAAQE,EAAc,GAClEA,GAAgBL,EAEhBI,EAAKhsB,GAAS,CACVmsB,MAAOL,EAAM9rB,GAASqrB,EACtB7sB,MAAOA,EAEf,EAKR,GAAIytB,EAAe,EAAG,CAClB,MAAM7rB,EAAO,GAAG6e,EAAU7e,MAAQ,YAAY6e,EAAUjf,kBAAkB4lB,EAAQ5lB,SAASyrB,IACrFa,EAAoBX,EAAaY,gBAAgBlsB,EAAQD,EAAMirB,EAAKW,GAC1E,IAAK,MAAM1B,KAAoBgC,EAC3Bb,IACAf,EAAOJ,EAAiBkC,kBAAmBlC,EAAiBA,iBAEpE,CACJ,IAER,CAEQ,0BAAAkB,CAA2B9V,EAAiB6V,GAChD,GAAIA,EAAQxM,MACR,OAAOwM,EAAQxM,MAGnB,MAAMiM,EAAgBO,EAAQP,eAAiB,SAC/C,OAAQA,GACJ,IAAK,OACL,IAAK,SACL,IAAK,cACD,MAEJ,QACI,MAAM,IAAIjoB,MAAM,GAAG2S,mCAAyC6V,EAAQP,kBAI5E,MAAMyB,EAAgBjX,EAAUC,IAAI,GAAGC,UAAiBra,KAAK4b,MAAMmF,UAAWmP,EAAQO,OAChFY,EAAiBlX,EAAUC,IAAI,GAAGC,WAAkBra,KAAK4b,MAAMmF,UAAWmP,EAAQQ,QAYxF,OAXAR,EAAQxM,MAAQjY,QAAQ2U,IAAI,CACxBpgB,KAAK4pB,wBAAwB,cAAcwH,EAAczsB,QAASysB,GAClEpxB,KAAK4pB,wBAAwB,cAAcyH,EAAe1sB,QAAS0sB,KACpExlB,MAAK,EAAEylB,EAAWC,MACV,CACHd,MAAOa,EACP3B,cAAeA,EACfe,OAAQa,MAITrB,EAAQxM,KACnB,CAUO,eAAA8N,CAAgBnX,EAAiB5Q,EAAiBC,EAAoBE,GACzE,MAAMgZ,EAAmB5iB,KAAKyxB,2BAA2BpX,EAAS5Q,EAAQC,EAAYE,GACtF,GAAIgZ,EACA,OAAOA,EAGX,IAAKnZ,EAAOia,MACR,GAAIja,EAAOoB,IACPpB,EAAOia,MAAQ1jB,KAAK0xB,aAAa,GAAGrX,QAAe5Q,EAAQA,EAAOoB,SAC/D,CACH,IAAK7K,KAAK6b,KACN,MAAM,IAAInU,MAAM,GAAG2S,oEAGvB5Q,EAAOia,MAAQ1jB,KAAK6b,KAAKhS,UAAU,EAAGJ,EAAOG,WACjD,CAGJ,OAAOH,EAAOia,MAAM7X,MAAMjH,IACtB,IACI,OAAO,IAAIwF,WAAWxF,EAAK6E,OAAQ7E,EAAK8E,WAAaA,EAAYE,EACrE,CAAE,MAAO4D,GACL,MAAM,IAAI9F,MAAM,GAAG2S,MAAY7M,EAAElC,UACrC,IAER,CAQO,mBAAAqmB,CAAoBtX,EAAiBuX,GACxC,MAAMhP,EAAmB5iB,KAAK6xB,+BAA+BxX,EAASuX,GACtE,GAAIhP,EACA,OAAOA,EAGX,GAAIgP,EAAWlO,MACX,OAAOkO,EAAWlO,MAGtB,MAAMja,EAAS0Q,EAAUC,IAAI,GAAGC,WAAkBra,KAAK4b,MAAMiF,QAAS+Q,EAAWnoB,QAGjF,OAFAmoB,EAAWlO,MAAQ1jB,KAAKwxB,gBAAgB,YAAY/nB,EAAO9E,QAAS8E,EAAQmoB,EAAWloB,YAAc,EAAGkoB,EAAWhoB,YAE5GgoB,EAAWlO,KACtB,CAEQ,kBAAAoO,CAAmBzX,EAAiBK,EAAqBlR,GAC7D,GAAIkR,EAASgJ,MACT,OAAOhJ,EAASgJ,MAGpB,MAAMqO,EAAgBvW,GAAWwW,kBAAkB3X,EAASK,EAASpO,MAC/D2lB,EAAaF,EAAgB,IAAaG,kBAAkBxX,EAASU,eACrEjX,EAAS4tB,EAAgBrX,EAASuN,MAExC,GAA2B1U,MAAvBmH,EAASkX,WACTlX,EAASgJ,MAAQjY,QAAQC,QAAQ,IAAIlC,EAAYrF,QAC9C,CACH,MAAMytB,EAAazX,EAAUC,IAAI,GAAGC,eAAsBra,KAAK4b,MAAMqF,YAAavG,EAASkX,YAC3FlX,EAASgJ,MAAQ1jB,KAAK2xB,oBAAoB,gBAAgBC,EAAWjtB,QAASitB,GAAY/lB,MAAMjH,IAC5F,GAA+B,OAA3B8V,EAASU,eAAkDV,EAASS,YAAgByW,EAAWK,YAAcL,EAAWK,aAAeA,EAEpI,CACH,MAAME,EAAa,IAAI3oB,EAAYrF,GAanC,OAZA,IAAaiuB,QACTxtB,EACA8V,EAAShR,YAAc,EACvBkoB,EAAWK,YAAcA,EACzBF,EACArX,EAASU,cACT+W,EAAWhuB,OACXuW,EAASS,aAAc,GACvB,CAAChY,EAAOwB,KACJwtB,EAAWxtB,GAASxB,KAGrBgvB,CACX,CAhBI,OAAO3W,GAAW6W,eAAehY,EAASK,EAASU,cAAexW,EAAM8V,EAAShR,WAAYvF,KAkBzG,CAEA,GAAIuW,EAAS4X,OAAQ,CACjB,MAAMA,EAAS5X,EAAS4X,OACxB5X,EAASgJ,MAAQhJ,EAASgJ,MAAM7X,MAAMjH,IAClC,MAAMutB,EAAavtB,EACb2tB,EAAoBpY,EAAUC,IAAI,GAAGC,8BAAqCra,KAAK4b,MAAMqF,YAAaqR,EAAOnL,QAAQyK,YACjHY,EAAmBrY,EAAUC,IAAI,GAAGC,6BAAoCra,KAAK4b,MAAMqF,YAAaqR,EAAOG,OAAOb,YACpH,OAAOnmB,QAAQ2U,IAAI,CACfpgB,KAAK2xB,oBAAoB,gBAAgBY,EAAkB5tB,QAAS4tB,GACpEvyB,KAAK2xB,oBAAoB,gBAAgBa,EAAiB7tB,QAAS6tB,KACpE3mB,MAAK,EAAE6mB,EAAaC,MACnB,MAAMxL,EAAU3L,GAAW6W,eACvB,GAAGhY,mBACHiY,EAAOnL,QAAQ/L,cACfsX,EACAJ,EAAOnL,QAAQzd,WACf4oB,EAAOrK,OAGL2K,EAAeb,EAAgBO,EAAOrK,MAC5C,IAAIwK,EAEJ,GAA+B,OAA3B/X,EAASU,eAAkDV,EAASS,WAEjE,CACH,MAAM0X,EAAarX,GAAW6W,eAAe,GAAGhY,kBAAyBK,EAASU,cAAeuX,EAAYL,EAAOG,OAAO/oB,WAAYkpB,GACvIH,EAAS,IAAIjpB,EAAYopB,GACzB,IAAaR,QAAQS,EAAY,EAAGZ,EAAYF,EAAerX,EAASU,cAAeqX,EAAOtuB,OAAQuW,EAASS,aAAc,GAAO,CAAChY,EAAOwB,KACxI8tB,EAAO9tB,GAASxB,IAExB,MAPIsvB,EAASjX,GAAW6W,eAAe,GAAGhY,kBAAyBK,EAASU,cAAeuX,EAAYL,EAAOG,OAAO/oB,WAAYkpB,GASjI,IAAIE,EAAc,EAClB,IAAK,IAAIC,EAAe,EAAGA,EAAe5L,EAAQhjB,OAAQ4uB,IAAgB,CACtE,IAAIhJ,EAAY5C,EAAQ4L,GAAgBhB,EACxC,IAAK,IAAIiB,EAAiB,EAAGA,EAAiBjB,EAAeiB,IACzDb,EAAWpI,KAAe0I,EAAOK,IAEzC,CAEA,OAAOX,OAGnB,CAEA,OAAOzX,EAASgJ,KACpB,CAKO,uBAAAkG,CAAwBvP,EAAiBK,GAC5C,OAAO1a,KAAK8xB,mBAAmBzX,EAASK,EAAU5T,aACtD,CAKO,yBAAAugB,CAA0BhN,EAAiBK,GAC9C,GAAsB,WAAlBA,EAASpO,KACT,MAAM,IAAI5E,MAAM,GAAG2S,yBAA+BK,EAASpO,QAG/D,GAC+B,OAA3BoO,EAASU,eACkB,OAA3BV,EAASU,eACkB,OAA3BV,EAASU,cAET,MAAM,IAAI1T,MAAM,GAAG2S,kCAAwCK,EAASU,iBAGxE,GAAIV,EAASgJ,MACT,OAAOhJ,EAASgJ,MAGpB,GAAIhJ,EAAS4X,OAAQ,CACjB,MAAM9oB,EAAcgS,GAAWyX,0BAA0B,GAAG5Y,kBAAyBK,EAASU,eAC9FV,EAASgJ,MAAQ1jB,KAAK8xB,mBAAmBzX,EAASK,EAAUlR,EAChE,KAAO,CACH,MAAMooB,EAAazX,EAAUC,IAAI,GAAGC,eAAsBra,KAAK4b,MAAMqF,YAAavG,EAASkX,YAC3FlX,EAASgJ,MAAQ1jB,KAAK2xB,oBAAoB,gBAAgBC,EAAWjtB,QAASitB,GAAY/lB,MAAMjH,GACrF4W,GAAW6W,eAAehY,EAASK,EAASU,cAAexW,EAAM8V,EAAShR,WAAYgR,EAASuN,QAE9G,CAEA,OAAOvN,EAASgJ,KACpB,CAKO,0BAAAwP,CAA2BtB,GAC9B,GAAIA,EAAWuB,eACX,OAAOvB,EAAWuB,eAGtB,MAAM3rB,EAASxH,KAAKic,cAAcvZ,YAKlC,OAJAkvB,EAAWuB,eAAiBnzB,KAAK2xB,oBAAoB,gBAAgBC,EAAWjtB,QAASitB,GAAY/lB,MAAMjH,GAChG,IAAI,IAAO4C,EAAQ5C,GAAM,KAG7BgtB,EAAWuB,cACtB,CAKO,wBAAAzL,CAAyBrN,EAAiBK,EAAqB8M,GAClE,GAAI9M,EAAS0Y,uBAAuB5L,GAChC,OAAO9M,EAAS0Y,qBAAqB5L,GAGpC9M,EAAS0Y,uBACV1Y,EAAS0Y,qBAAuB,CAAC,GAGrC,MAAM5rB,EAASxH,KAAKic,cAAcvZ,YAElC,GAAIgY,EAAS4X,QAAiC/e,MAAvBmH,EAASkX,WAC5BlX,EAAS0Y,qBAAqB5L,GAAQxnB,KAAK4pB,wBAAwBvP,EAASK,GAAU7O,MAAMjH,GACjF,IAAI,IAAa4C,EAAQ5C,EAAM4iB,GAAM,SAE7C,CACH,MAAMoK,EAAazX,EAAUC,IAAI,GAAGC,eAAsBra,KAAK4b,MAAMqF,YAAavG,EAASkX,YAC3FlX,EAAS0Y,qBAAqB5L,GAAQxnB,KAAKkzB,2BAA2BtB,GAAY/lB,MAAMwnB,IACpF,MAAMtB,EAAgBvW,GAAWwW,kBAAkB3X,EAASK,EAASpO,MACrE,OAAO,IAAI,IACP9E,EACA6rB,EACA7L,GACA,OACAjU,EACAqe,EAAWK,gBACX1e,EACAmH,EAAShR,WACTqoB,EACArX,EAASU,cACTV,EAASS,YACT,OACA5H,GACA,KAGZ,CAEA,OAAOmH,EAAS0Y,qBAAqB5L,EACzC,CAEQ,6CAAA8L,CAA8CjZ,EAAiBqV,EAA2C3I,GAC9G,MAAMxH,EAAW,IAAIjf,MACf+c,EAAUrd,KAAKod,4BAA4B2J,GAwCjD,OAtCI2I,IAEIA,EAAW6D,iBACXlW,EAAQmW,UAAY,KAAOxI,UAAU0E,EAAW6D,iBAChDlW,EAAQoW,gBAAkB/D,EAAW6D,gBAAgB,IAErDlW,EAAQmW,UAAY,KAAOE,QAI/BrW,EAAQsW,cAA6CpgB,MAA7Bmc,EAAWkE,eAA8B,EAAIlE,EAAWkE,eAChFvW,EAAQwW,kBAAkDtgB,MAA9Bmc,EAAWoE,gBAA+B,EAAIpE,EAAWoE,gBAEjFpE,EAAWqE,kBACXxU,EAASra,KACLlF,KAAKg0B,qBAAqB,GAAG3Z,qBAA4BqV,EAAWqE,kBAAmB1e,IACnFA,EAAQtQ,KAAO,GAAGgiB,EAAgBhiB,oBAClCsY,EAAQ0W,iBAAmB1e,MAKnCqa,EAAWuE,2BACXvE,EAAWuE,yBAAyBC,cAAe,EACnD3U,EAASra,KACLlF,KAAKg0B,qBAAqB,GAAG3Z,6BAAoCqV,EAAWuE,0BAA2B5e,IACnGA,EAAQtQ,KAAO,GAAGgiB,EAAgBhiB,4BAClCsY,EAAQ8W,qBAAuB9e,EAC/BgI,EAAQ+W,yBAA2B/e,MAK3CgI,EAAQgX,sCAAuC,EAC/ChX,EAAQiX,oCAAqC,IAI9C7oB,QAAQ2U,IAAIb,GAAU1T,MAAK,QACtC,CAKO,kBAAAkU,CACH1F,EACAlF,EACA6N,EACAnD,EACAhO,EAA8C,QAE9C,MAAM+Q,EAAmB5iB,KAAKu0B,6BAA6Bla,EAASlF,EAAU6N,EAAanD,EAAiBhO,GAC5G,GAAI+Q,EACA,OAAOA,EAGXzN,EAASuO,MAAQvO,EAASuO,OAAS,CAAC,EACpC,IAAI8Q,EAAcrf,EAASuO,MAAM7D,GACjC,IAAK2U,EAAa,CACdx0B,KAAK8iB,QAAQ,GAAGzI,KAAWlF,EAASpQ,MAAQ,MAE5C,MAAMgiB,EAAkB/mB,KAAKy0B,eAAepa,EAASlF,EAAU0K,GAE/D2U,EAAc,CACVzN,gBAAiBA,EACjB2N,cAAe,GACfzO,QAASjmB,KAAK20B,4BAA4Bta,EAASlF,EAAU4R,IAGjE5R,EAASuO,MAAM7D,GAAmB2U,EAElChZ,GAAW8I,mBAAmByC,EAAiB1M,GAC/Cra,KAAK+b,QAAQxL,2BAA2B+C,gBAAgByT,GAExD/mB,KAAKmjB,UACT,CAeA,OAbIH,IACAwR,EAAYE,cAAcxvB,KAAK8d,GAE/BA,EAAYrS,oBAAoB2F,SAAQ,KACpC,MAAM3R,EAAQ6vB,EAAYE,cAAclvB,QAAQwd,IACjC,IAAXre,GACA6vB,EAAYE,cAAcjvB,OAAOd,EAAO,OAKpDkN,EAAO2iB,EAAYzN,iBAEZyN,EAAYvO,QAAQpa,MAAK,IACrB2oB,EAAYzN,iBAE3B,CAEQ,sBAAAC,CAAuBjiB,EAAc8a,GACzC,IAAK7f,KAAKmd,iBACN,MAAM,IAAIzV,MAAM,iCAEpB1H,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAMyK,EAAkB,IAAI/mB,KAAKmd,iBAAiByB,cAAc7Z,EAAM/E,KAAKic,eAC3E8K,EAAgBvlB,iBAAmBxB,KAAKsc,gBACxCtc,KAAKic,cAAcoG,wBAAyB,EAC5C0E,EAAgB6N,SAAW/U,EAC3BkH,EAAgB8N,iBAAmB70B,KAAKmd,iBAAiByB,cAAckW,gBAGvE,MAAMzX,EAAUrd,KAAKod,4BAA4B2J,GAOjD,OANA1J,EAAQ0X,4BAA8B/0B,KAAK+b,QAAQrN,uBAGnD2O,EAAQsW,cAAgB,EACxBtW,EAAQwW,kBAAoB,EAErB9M,CACX,CASO,cAAA0N,CAAepa,EAAiBlF,EAAqB0K,GACxD,MAAMmV,EAAoBh1B,KAAKi1B,0BAA0B5a,EAASlF,EAAU0K,GAC5E,GAAImV,EACA,OAAOA,EAGX,MAAMjwB,EAAOoQ,EAASpQ,MAAQ,WAAWoQ,EAASxQ,QAGlD,OAFwB3E,KAAKgnB,uBAAuBjiB,EAAM8a,EAG9D,CASO,2BAAA8U,CAA4Bta,EAAiBlF,EAAqB4R,GACrE,MAAMnE,EAAmB5iB,KAAKk1B,uCAAuC7a,EAASlF,EAAU4R,GACxF,GAAInE,EACA,OAAOA,EAGX,MAAMrD,EAAW,IAAIjf,MAUrB,OARAif,EAASra,KAAKlF,KAAKm1B,gCAAgC9a,EAASlF,EAAU4R,IAElE5R,EAASigB,sBACT7V,EAASra,KAAKlF,KAAKszB,8CAA8C,GAAGjZ,yBAAgClF,EAASigB,qBAAsBrO,IAGvI/mB,KAAKq1B,4BAA4Bhb,EAASlF,EAAU4R,GAE7Ctb,QAAQ2U,IAAIb,GAAU1T,MAAK,QACtC,CASO,+BAAAspB,CAAgC9a,EAAiBlF,EAAqB4R,GACzE,MAAMxH,EAAW,IAAIjf,MACf+c,EAAUrd,KAAKod,4BAA4B2J,GA2BjD,IAAIuO,EAxBJjY,EAAQkY,cAAgBpgB,EAASqgB,eAAiB,KAAOxK,UAAU7V,EAASqgB,gBAAkB,IAAI,KAAO,EAAG,EAAG,GAG3GrgB,EAASsgB,cACTpY,EAAQqY,iBAAkB,EAC1BrY,EAAQsY,kBAAmB,GAG3BxgB,EAASygB,gBACTzgB,EAASygB,cAAc1B,cAAe,EACtC3U,EAASra,KACLlF,KAAKg0B,qBAAqB,GAAG3Z,kBAAyBlF,EAASygB,eAAgBvgB,IAC3EA,EAAQtQ,KAAO,GAAGgiB,EAAgBhiB,gBAClCsY,EAAQwY,sBAAwBxgB,EACK9B,MAAjC4B,EAASygB,eAAenT,QACxBpN,EAAQygB,MAAQ3gB,EAASygB,cAAcnT,WAMnDpF,EAAQ0Y,wBAAwB/1B,KAAKic,cAAcsG,qBAAsBviB,KAAKic,cAAcsG,uBAIhG,IACIyT,EADAC,EAAqB,EA0BzB,OAvBI9gB,EAAS+gB,mBACT/gB,EAAS+gB,iBAAiBhC,cAAe,EACzC3U,EAASra,KACLlF,KAAKg0B,qBAAqB,GAAG3Z,qBAA4BlF,EAAS+gB,kBAAmB7gB,IACjFA,EAAQtQ,KAAO,GAAGgiB,EAAgBhiB,mBAClCuwB,EAAYjgB,MAIsB9B,MAAtC4B,EAAS+gB,iBAAiBC,WAC1BF,EAAa9gB,EAAS+gB,iBAAiBC,WAI3ChhB,EAASihB,iBACT7W,EAASra,KACLlF,KAAKg0B,qBAAqB,GAAG3Z,oBAA2BlF,EAASihB,iBAAkB/gB,IAC/EA,EAAQtQ,KAAO,GAAGgiB,EAAgBhiB,kBAClCixB,EAAkB3gB,MAKvB5J,QAAQ2U,IAAIb,GAAU1T,MAAK,KAE1BypB,IACAjY,EAAQgZ,wBAA0Bf,EAClCjY,EAAQiZ,gCAAkCL,GAG1CD,IACA3Y,EAAQkZ,qBAAuBP,KAG3C,CASO,2BAAAX,CAA4Bhb,EAAiBlF,EAAqB4R,GACrE,IAAK/mB,KAAKmd,iBACN,MAAM,IAAIzV,MAAM,GAAG2S,kCAGvB,MAAMgD,EAAUrd,KAAKod,4BAA4B2J,GAC3CgN,EAAmB1W,EAAQ0W,iBAGjC,OADkB5e,EAASqhB,WAAa,UAEpC,IAAK,SACDzP,EAAgB8N,iBAAmB70B,KAAKmd,iBAAiByB,cAAckW,gBACvE/N,EAAgB0P,MAAQ,EACxB,MAEJ,IAAK,OACD1P,EAAgB8N,iBAAmB70B,KAAKmd,iBAAiByB,cAAc8X,mBACvErZ,EAAQsZ,YAAsCpjB,MAAxB4B,EAASyhB,YAA2B,GAAMzhB,EAASyhB,YACrE7C,IACAA,EAAiB8C,UAAW,GAEhC,MAEJ,IAAK,QACD9P,EAAgB8N,iBAAmB70B,KAAKmd,iBAAiByB,cAAckY,oBACnE/C,IACAA,EAAiB8C,UAAW,EAC5BxZ,EAAQ0Z,8BAA+B,GAE3C,MAEJ,QACI,MAAM,IAAIrvB,MAAM,GAAG2S,+BAAqClF,EAASqhB,cAG7E,CASO,oBAAAxC,CAAqB3Z,EAAiB2c,EAA2BnlB,EAAgD,QACpH,MAAM+Q,EAAmB5iB,KAAKi3B,gCAAgC5c,EAAS2c,EAAanlB,GACpF,GAAI+Q,EACA,OAAOA,EAKX,GAFA5iB,KAAK8iB,QAAQ,GAAGzI,KAEZ2c,EAAYE,UAAa,EACzB,MAAM,IAAIxvB,MAAM,GAAG2S,8BAAoC2c,EAAYE,aAGvE,MAAM7hB,EAAU8E,EAAUC,IAAI,GAAGC,UAAiBra,KAAK4b,MAAMxG,SAAU4hB,EAAYryB,OACnF0Q,EAAQ8hB,aAAeH,EAEvB,MAAM/Q,EAAUjmB,KAAKo3B,kBAAkB,aAAaJ,EAAYryB,QAAS0Q,GAAUgiB,IAC/EA,EAAeC,iBAAmBN,EAAYE,UAAY,EAC1D1b,GAAW8I,mBAAmB+S,EAAgBhd,GAC9Cra,KAAK+b,QAAQzL,0BAA0BgD,gBAAgB+jB,GACvDxlB,EAAOwlB,MAKX,OAFAr3B,KAAKmjB,WAEE8C,CACX,CAKO,iBAAAmR,CAAkB/c,EAAiBhF,EAAmBxD,EAAgD,QACzG,MAAM+Q,EAAmB5iB,KAAKu3B,4BAA4Bld,EAAShF,EAASxD,GAC5E,GAAI+Q,EACA,OAAOA,EAGX5iB,KAAK8iB,QAAQ,GAAGzI,KAAWhF,EAAQtQ,MAAQ,MAE3C,MAAMmrB,EAA6B3c,MAAnB8B,EAAQ6a,QAAuB1U,GAAWgc,eAAiBrd,EAAUC,IAAI,GAAGC,YAAmBra,KAAK4b,MAAMuF,SAAU9L,EAAQ6a,SACtIuH,EAAQtd,EAAUC,IAAI,GAAGC,WAAkBra,KAAK4b,MAAMsF,OAAQ7L,EAAQqiB,QACtEzR,EAAUjmB,KAAK23B,oBAAoBtd,EAAS6V,EAASuH,EAAO5lB,OAAQ0B,GAAY8B,EAAQ8hB,aAAajD,cAI3G,OAFAl0B,KAAKmjB,WAEE8C,CACX,CAKO,mBAAA0R,CACHtd,EACA6V,EACAuH,EACA5lB,EAAgD,OAChD+lB,EACAC,GAEA,MAAMC,EAAc93B,KAAK+3B,aAAa,aAAa7H,EAAQvrB,QAASurB,GAE9D3Q,EAAW,IAAIjf,MAEf03B,EAAW,IAAI,IACrBh4B,KAAKic,cAAcoG,yBAA2BriB,KAAKsc,gBACnD,MAAM2b,EAAkD,CACpDC,SAAUJ,EAAYK,UACtBC,SAAS,EACTC,aAAcP,EAAYO,aAC1BhJ,OAAQ,KACCrvB,KAAK4c,WACNob,EAAStsB,WAGjBc,QAAS,CAAClB,EAAkBgtB,KACnBt4B,KAAK4c,WACNob,EAASrsB,OAAO,IAAIjE,MAAM,GAAG2S,MAAYie,GAAaA,EAAUhtB,QAAUgtB,EAAUhtB,QAAUA,GAAW,8BAGjHitB,SAAUd,EAAMc,WAAY,QAAYd,EAAM5sB,KAAO,IACrD2tB,cAAeZ,EACfC,gBAAiBA,GAAiB73B,KAAK+b,QAAQjN,gBAE7CuoB,EAAiB,IAAI,IAAQ,KAAMr3B,KAAKic,cAAegc,GA2B7D,OA1BAZ,EAAe71B,iBAAmBxB,KAAKsc,gBACvCtc,KAAKic,cAAcoG,wBAAyB,EAC5C9C,EAASra,KAAK8yB,EAAS/R,SAEvB1G,EAASra,KACLlF,KAAKy4B,eAAe,WAAWhB,EAAM9yB,QAAS8yB,GAAO5rB,MAAMjH,IACvD,MAAMG,EAAO0yB,EAAM5sB,KAAO,GAAG7K,KAAK6c,kBAAkB4a,EAAM9yB,QACpD+zB,EAAU,QAAQ14B,KAAK8c,iBAAiB/X,IAC9CsyB,EAAesB,UAAUD,EAAS9zB,GAGlC,MAAMg0B,EAAkBvB,EAAewB,qBACnCD,IACAA,EAAgBE,MAAQrB,EAAM1yB,UAK1CsyB,EAAe0B,MAAQjB,EAAYiB,MACnC1B,EAAe2B,MAAQlB,EAAYkB,MACnCnnB,EAAOwlB,GAEHr3B,KAAK+b,QAAQnN,sBACbyoB,EAAetyB,KAAO0yB,EAAM1yB,MAAQ0yB,EAAM5sB,KAAO,QAAQ4sB,EAAM9yB,SAG5D8G,QAAQ2U,IAAIb,GAAU1T,MAAK,IACvBwrB,GAEf,CAEQ,YAAAU,CAAa1d,EAAiB6V,GAUlC,OATKA,EAAQxM,QACTwM,EAAQxM,MAAQ,CACZyU,UAAiC,OAAtBjI,EAAQ+I,WAAgE,OAAtB/I,EAAQ+I,UACrEZ,aAAc7c,GAAW0d,wBAAwB7e,EAAS6V,GAC1D6I,MAAOvd,GAAW2d,oBAAoB,GAAG9e,UAAiB6V,EAAQkJ,OAClEJ,MAAOxd,GAAW2d,oBAAoB,GAAG9e,UAAiB6V,EAAQmJ,SAInEnJ,EAAQxM,KACnB,CAQO,cAAA+U,CAAepe,EAAiBod,GACnC,IAAKA,EAAM/T,MAAO,CAGd,GAFA1jB,KAAK8iB,QAAQ,GAAGzI,KAAWod,EAAM1yB,MAAQ,MAErC0yB,EAAM5sB,IACN4sB,EAAM/T,MAAQ1jB,KAAK0xB,aAAa,GAAGrX,QAAeod,EAAOA,EAAM5sB,SAC5D,CACH,MAAM+mB,EAAazX,EAAUC,IAAI,GAAGC,eAAsBra,KAAK4b,MAAMqF,YAAawW,EAAM7F,YACxF6F,EAAM/T,MAAQ1jB,KAAK2xB,oBAAoB,gBAAgBC,EAAWjtB,QAASitB,EAC/E,CAEA5xB,KAAKmjB,UACT,CAEA,OAAOsU,EAAM/T,KACjB,CASO,YAAAgO,CAAarX,EAAiBif,EAAqBzuB,GACtD,MAAM+X,EAAmB5iB,KAAKu5B,wBAAwBlf,EAASif,EAAUzuB,GACzE,GAAI+X,EACA,OAAOA,EAGX,IAAKpH,GAAWge,aAAa3uB,GACzB,MAAM,IAAInD,MAAM,GAAG2S,OAAaxP,iBAGpC,IAAI,QAAgBA,GAAM,CACtB,MAAMjG,EAAO,IAAIwF,YAAW,QAAwBS,IAEpD,OADA7K,KAAKy5B,IAAI,GAAGpf,cAAoBxP,EAAIyO,UAAU,EAAG,WAAW1U,EAAKT,iBAC1DsH,QAAQC,QAAQ9G,EAC3B,CAIA,OAFA5E,KAAKy5B,IAAI,GAAGpf,cAAoBxP,KAEzB7K,KAAK+b,QAAQ1M,mBAAmBrP,KAAKoc,SAAWvR,GAAKgB,MAAML,GACvD,IAAIC,SAAQ,CAACC,EAASC,KACzB3L,KAAK+b,QAAQ7H,UACTlU,KAAKic,cACLzQ,GACC5G,IACQ5E,KAAK4c,YACN5c,KAAKy5B,IAAI,GAAGpf,aAAmBxP,MAASjG,EAAqBgF,qBAC7D8B,EAAQ,IAAItB,WAAWxF,QAG/B,GACCsO,IACGvH,EAAO,IAAI,KAAc,GAAG0O,sBAA4BxP,KAAOqI,EAAU,KAAOA,EAAQwmB,OAAS,IAAMxmB,EAAQymB,WAAa,KAAMzmB,WAKtJ,CAOO,yBAAOoR,CAAmBsV,EAA8BC,GAC3DD,EAAc13B,SAAW03B,EAAc13B,UAAY,CAAC,EACpD,MAAMA,EAAY03B,EAAcE,kBAAoBF,EAAcE,mBAAqB,CAAC,EAClFne,EAAQzZ,EAASyZ,KAAOzZ,EAASyZ,MAAQ,CAAC,GAC9BA,EAAKoe,SAAWpe,EAAKoe,UAAY,IAC1C70B,KAAK20B,EAClB,CAEQ,0BAAOV,CAAoB9e,EAAiByM,GAIhD,OAFAA,EAAevT,MAARuT,EAAoB,MAAyBA,GAGhD,KAAK,MACD,OAAO,IAAQkT,kBACnB,KAAK,MACD,OAAO,IAAQC,mBACnB,KAAK,MACD,OAAO,IAAQC,iBACnB,QAEI,OADA,IAAOnmB,KAAK,GAAGsG,qBAA2ByM,MACnC,IAAQoT,iBAE3B,CAEQ,8BAAOhB,CAAwB7e,EAAiB6V,GAEpD,MAAMiK,EAAiC5mB,MAArB2c,EAAQiK,UAAyB,KAA0BjK,EAAQiK,UAC/ElB,EAAiC1lB,MAArB2c,EAAQ+I,UAAyB,KAAwC/I,EAAQ+I,UAEnG,GAAkB,OAAdkB,EACA,OAAQlB,GACJ,KAAK,KACD,OAAO,IAAQmB,eACnB,KAAK,KACD,OAAO,IAAQC,cACnB,KAAK,KACD,OAAO,IAAQC,0BACnB,KAAK,KACD,OAAO,IAAQC,yBACnB,KAAK,KACD,OAAO,IAAQC,yBACnB,KAAK,KACD,OAAO,IAAQC,wBACnB,QAEI,OADA,IAAO1mB,KAAK,GAAGsG,+BAAqC4e,MAC7C,IAAQwB,6BAOvB,OAJkB,OAAdN,GACA,IAAOpmB,KAAK,GAAGsG,+BAAqC8f,MAGhDlB,GACJ,KAAK,KACD,OAAO,IAAQyB,gBACnB,KAAK,KACD,OAAO,IAAQC,eACnB,KAAK,KACD,OAAO,IAAQC,2BACnB,KAAK,KACD,OAAO,IAAQC,0BACnB,KAAK,KACD,OAAO,IAAQC,0BACnB,KAAK,KACD,OAAO,IAAQC,yBACnB,QAEI,OADA,IAAOhnB,KAAK,GAAGsG,+BAAqC4e,MAC7C,IAAQ2B,2BAG/B,CAEQ,gCAAO3H,CAA0B5Y,EAAiBe,GACtD,IACI,OAAO,OAAyBA,EACpC,CAAE,MAAO5N,GACL,MAAM,IAAI9F,MAAM,GAAG2S,MAAY7M,EAAElC,UACrC,CACJ,CAEQ,qBAAO+mB,CAAehY,EAAiBe,EAAsCwW,EAA6BloB,EAAgCvF,GAC9I,MAAMsF,EAASmoB,EAAWnoB,OAC1BC,EAAakoB,EAAWloB,YAAcA,GAAc,GAEpD,MAAMF,EAAcgS,GAAWyX,0BAA0B,GAAG5Y,kBAAyBe,GAE/E4f,EAAsB,IAAa9I,kBAAkB9W,GAC3D,OAAI1R,EAAasxB,IAAwB,GAErC,IAAOjnB,KAAK,GAAGsG,qCAA2C3Q,uDAAgEsxB,MACnH,IAAIxxB,EAAYC,EAAOvC,MAAMwC,EAAYA,EAAavF,EAAS62B,GAAsB,IAGzF,IAAIxxB,EAAYC,EAAQC,EAAYvF,EAC/C,CAEQ,wBAAO6tB,CAAkB3X,EAAiB/N,GAC9C,OAAQA,GACJ,IAAK,SACD,OAAO,EACX,IAAK,OACD,OAAO,EACX,IAAK,OACD,OAAO,EACX,IAAK,OAEL,IAAK,OACD,OAAO,EACX,IAAK,OACD,OAAO,EACX,IAAK,OACD,OAAO,GAGf,MAAM,IAAI5E,MAAM,GAAG2S,oBAA0B/N,KACjD,CAEQ,mBAAOktB,CAAa3uB,GACxB,OAAO,KAAMowB,SAASpwB,KAA+B,IAAvBA,EAAIrF,QAAQ,KAC9C,CAKO,mBAAOqhB,CAAaxM,EAAiByM,GAKxC,OAJYvT,MAARuT,IACAA,EAAO,GAGHA,GACJ,KAAK,EACD,OAAO,IAASoU,kBACpB,KAAK,EACD,OAAO,IAASC,iBACpB,KAAK,EACD,OAAO,IAASC,iBACpB,KAAK,EACD,OAAO,IAASC,kBACpB,KAAK,EACD,OAAO,IAASvb,iBACpB,KAAK,EACD,OAAO,IAASwb,sBACpB,KAAK,EACD,OAAO,IAASC,oBAGxB,MAAM,IAAI7zB,MAAM,GAAG2S,mCAAyCyM,KAChE,CAEQ,sBAAA7G,GACJjgB,KAAK+b,QAAQvK,yBAAyB,qBAEtC,MAAM+N,EAAW,IAAIjf,MAErB,GAAIN,KAAK4b,MAAM1G,UACX,IAAK,MAAMC,KAAYnV,KAAK4b,MAAM1G,UAC9B,GAAIC,EAASuO,MACT,IAAK,MAAM7D,KAAmB1K,EAASuO,MAAO,CAC1C,MAAM8Q,EAAcrf,EAASuO,MAAM7D,GACnC,IAAK,MAAMmD,KAAewR,EAAYE,cAAe,CAEjD1R,EAAYwY,oBAAmB,GAE/B,MAAMzU,EAAkByN,EAAYzN,gBACpCxH,EAASra,KAAK6hB,EAAgB0U,sBAAsBzY,IACpDzD,EAASra,KAAK6hB,EAAgB0U,sBAAsBzY,EAAa,CAAE0Y,cAAc,KAC7E17B,KAAK+b,QAAQpN,eACb4Q,EAASra,KAAK6hB,EAAgB0U,sBAAsBzY,EAAa,CAAE2Y,WAAW,KAC9Epc,EAASra,KAAK6hB,EAAgB0U,sBAAsBzY,EAAa,CAAE2Y,WAAW,EAAMD,cAAc,KAE1G,CACJ,CAKZ,OAAOjwB,QAAQ2U,IAAIb,GAAU1T,MAAK,KAC9B7L,KAAK+b,QAAQrK,uBAAuB,uBAE5C,CAEQ,6BAAAwO,GACJlgB,KAAK+b,QAAQvK,yBAAyB,6BAEtC,MAAM+N,EAAW,IAAIjf,MAEfwV,EAAS9V,KAAKic,cAAcnG,OAClC,IAAK,MAAM8lB,KAAS9lB,EAAQ,CACxB,MAAMwB,EAAYskB,EAAMC,qBACpBvkB,GACAiI,EAASra,KAAKoS,EAAUmkB,wBAEhC,CAEA,OAAOhwB,QAAQ2U,IAAIb,GAAU1T,MAAK,KAC9B7L,KAAK+b,QAAQrK,uBAAuB,+BAE5C,CAEQ,kBAAAoqB,CAAmB7Y,GACvB,IAAK,MAAMvF,KAAa1d,KAAK2c,YACrBe,EAAUkE,SACVqB,EAAOvF,EAGnB,CAEQ,gBAAAqe,CAAoBzC,EAAqB0C,EAAsBC,GACnE,IAAK,MAAMve,KAAa1d,KAAK2c,YACzB,GAAIe,EAAUkE,QAAS,CACnB,MAAMpb,EAAK,GAAGkX,EAAU3Y,QAAQi3B,IAC1BE,EAAiB5C,EACvB4C,EAAeC,gCAAkCD,EAAeC,iCAAmC,CAAC,EACpG,MAAMC,EAAiCF,EAAeC,gCACtD,IAAKC,EAA+B51B,GAAK,CACrC41B,EAA+B51B,IAAM,EAErC,IACI,MAAM4C,EAAS6yB,EAAYve,GAC3B,GAAItU,EACA,OAAOA,CAEf,C,eACWgzB,EAA+B51B,EAC1C,CACJ,CACJ,CAGJ,OAAO,IACX,CAEQ,oBAAA8Y,GACJtf,KAAK87B,oBAAoBpe,GAAcA,EAAU2e,WAAa3e,EAAU2e,aAC5E,CAEQ,kBAAA7b,GACJxgB,KAAK87B,oBAAoBpe,GAAcA,EAAU4e,SAAW5e,EAAU4e,WAC1E,CAGQ,yBAAAzZ,CAA0BxI,EAAiBja,GAC/C,OAAOJ,KAAK+7B,iBAAiB37B,EAAO,aAAcsd,GAAcA,EAAUgC,gBAAkBhC,EAAUgC,eAAerF,EAASja,IAClI,CAGQ,wBAAA+jB,CAAyB9J,EAAiBnI,EAAaL,GAC3D,OAAO7R,KAAK+7B,iBAAiB7pB,EAAM,YAAawL,GAAcA,EAAUqF,eAAiBrF,EAAUqF,cAAc1I,EAASnI,EAAML,IACpI,CAGQ,0BAAA0b,CAA2BlT,EAAiB9E,EAAiB1D,GACjE,OAAO7R,KAAK+7B,iBAAiBxmB,EAAQ,cAAemI,GAAcA,EAAU6G,iBAAmB7G,EAAU6G,gBAAgBlK,EAAS9E,EAAQ1D,IAC9I,CAGQ,8BAAAoV,CAA+B5M,EAAiBuL,EAA2B5C,GAC/E,OAAOhjB,KAAK+7B,iBAAiBnW,EAAW,kBAAmBlI,GAAcA,EAAU+I,sBAAwB/I,EAAU+I,qBAAqBpM,EAASuL,EAAW5C,IAClK,CAGQ,iCAAA8C,CACJzL,EACAtV,EACAmN,EACA/K,EACAye,EACA/T,GAEA,OAAO7R,KAAK+7B,iBACRnW,EACA,qBACClI,GAAcA,EAAUmI,yBAA2BnI,EAAUmI,wBAAwBxL,EAAStV,EAAMmN,EAAM/K,EAAMye,EAAW/T,IAEpI,CAGQ,4BAAA0iB,CACJla,EACAlF,EACA6N,EACAnD,EACAhO,GAEA,OAAO7R,KAAK+7B,iBACR5mB,EACA,gBACCuI,GAAcA,EAAUqC,oBAAsBrC,EAAUqC,mBAAmB1F,EAASlF,EAAU6N,EAAanD,EAAiBhO,IAErI,CAEQ,yBAAAojB,CAA0B5a,EAAiBlF,EAAqB0K,GACpE,OAAO7f,KAAK+7B,iBAAiB5mB,EAAU,kBAAmBuI,GAAcA,EAAU+W,gBAAkB/W,EAAU+W,eAAepa,EAASlF,EAAU0K,IACpJ,CAGQ,sCAAAqV,CAAuC7a,EAAiBlF,EAAqB4R,GACjF,OAAO/mB,KAAK+7B,iBACR5mB,EACA,0BACCuI,GAAcA,EAAUiX,6BAA+BjX,EAAUiX,4BAA4Bta,EAASlF,EAAU4R,IAEzH,CAGQ,+BAAAkQ,CAAgC5c,EAAiB2c,EAA2BnlB,GAChF,OAAO7R,KAAK+7B,iBAAiB/E,EAAa,mBAAoBtZ,GAAcA,EAAUsW,sBAAwBtW,EAAUsW,qBAAqB3Z,EAAS2c,EAAanlB,IACvK,CAGQ,2BAAA0lB,CAA4Bld,EAAiBhF,EAAmBxD,GACpE,OAAO7R,KAAK+7B,iBAAiB1mB,EAAS,eAAgBqI,GAAcA,EAAU0Z,mBAAqB1Z,EAAU0Z,kBAAkB/c,EAAShF,EAASxD,IACrJ,CAGQ,6BAAA+c,CAA8BvU,EAAiBuJ,GACnD,OAAO5jB,KAAK+7B,iBAAiBnY,EAAW,iBAAkBlG,GAAcA,EAAU+Q,oBAAsB/Q,EAAU+Q,mBAAmBpU,EAASuJ,IAClJ,CAGQ,oCAAA0L,CACJjV,EACA+U,EACAxL,EACA2G,EACA8E,GAEA,OAAOrvB,KAAK+7B,iBACRnY,EACA,wBACClG,GAAcA,EAAUqR,4BAA8BrR,EAAUqR,2BAA2B1U,EAAS+U,EAAkBxL,EAAW2G,EAAS8E,IAEnJ,CAGQ,wBAAAjE,CAAyB/Q,EAAiBnI,EAAauR,GAC3D,OAAOzjB,KAAK+7B,iBAAiBtY,EAAM,YAAa/F,GAAcA,EAAUyH,gBAAkBzH,EAAUyH,eAAe9K,EAASnI,EAAMuR,IACtI,CAGQ,uBAAA8V,CAAwBlf,EAAiBif,EAAqBzuB,GAClE,OAAO7K,KAAK+7B,iBAAiBzC,EAAU,WAAY5b,GAAcA,EAAU6e,eAAiB7e,EAAU6e,cAAcliB,EAASif,EAAUzuB,IAC3I,CAGQ,8BAAAgnB,CAA+BxX,EAAiBuX,GACpD,OAAO5xB,KAAK+7B,iBAAiBnK,EAAY,kBAAmBlU,GAAcA,EAAUiU,qBAAuBjU,EAAUiU,oBAAoBtX,EAASuX,IACtJ,CAGQ,0BAAAH,CAA2BpX,EAAiB5Q,EAAiBC,EAAoBE,GACrF,OAAO5J,KAAK+7B,iBAAiBtyB,EAAQ,cAAeiU,GAAcA,EAAU8T,iBAAmB9T,EAAU8T,gBAAgBnX,EAAS5Q,EAAQC,EAAYE,IAC1J,CAWO,yBAAO4yB,CACVniB,EACAif,EACAmD,EACAR,GAEA,IAAK3C,EAASroB,WACV,OAAO,KAGX,MAEMyM,EAFa4b,EAASroB,WAECwrB,GAC7B,OAAK/e,EAIEue,EAAY,GAAG5hB,gBAAsBoiB,IAAiB/e,GAHlD,IAIf,CAWO,qBAAOgf,CACVriB,EACAif,EACAmD,EACAR,GAEA,IAAK3C,EAASnQ,OACV,OAAO,KAGX,MAEMwT,EAFSrD,EAASnQ,OAEHsT,GACrB,OAAKE,EAIEV,EAAY,GAAG5hB,YAAkBoiB,IAAiBE,GAH9C,IAIf,CAOO,eAAAhe,CAAgB5Z,GACnB,QAAS/E,KAAK4b,MAAMghB,iBAA+D,IAA7C58B,KAAK4b,MAAMghB,eAAep3B,QAAQT,EAC5E,CAMO,OAAA+d,CAAQxX,GACXtL,KAAK+b,QAAQ7C,SAAS5N,EAC1B,CAKO,QAAA6X,GACHnjB,KAAK+b,QAAQ5C,WACjB,CAMO,GAAAsgB,CAAInuB,GACPtL,KAAK+b,QAAQ1K,KAAK/F,EACtB,CAMO,uBAAAuxB,CAAwBrjB,GAC3BxZ,KAAK+b,QAAQvK,yBAAyBgI,EAC1C,CAMO,qBAAAsjB,CAAsBtjB,GACzBxZ,KAAK+b,QAAQrK,uBAAuB8H,EACxC,EAr1FuB,GAAAge,eAA2B,CAAE7yB,OAAQ,GAw1FhEsL,EAAe4H,mBAAsBiE,GAAW,IAAIN,GAAWM,E","sources":["webpack://@dev/inspector-v2/../core/src/Morph/morphTargetManager.ts?","webpack://@dev/inspector-v2/../core/src/Misc/dataReader.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/glTFValidation.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/glTFFileLoader.ts?","webpack://@dev/inspector-v2/../core/src/Misc/lazy.ts?","webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/glTFLoader.ts?"],"sourcesContent":["import type { Observer } from \"../Misc/observable\";\r\nimport { SmartArray } from \"../Misc/smartArray\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { IDisposable, Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport type { Mesh } from \"../Meshes/mesh\";\r\nimport { MorphTarget } from \"./morphTarget\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport type { Effect } from \"../Materials/effect\";\r\nimport { RawTexture2DArray } from \"../Materials/Textures/rawTexture2DArray\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n/**\r\n * This class is used to deform meshes using morphing between different targets\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/morphTargets\r\n */\r\nexport class MorphTargetManager implements IDisposable {\r\n    /** Enable storing morph target data into textures when set to true (true by default) */\r\n    public static EnableTextureStorage = true;\r\n\r\n    /** Maximum number of active morph targets supported in the \"vertex attribute\" mode (i.e., not the \"texture\" mode) */\r\n    public static MaxActiveMorphTargetsInVertexAttributeMode = 8;\r\n\r\n    /**\r\n     * When used in texture mode, if greather than 0, this will override the the morph manager numMaxInfluencers value.\r\n     */\r\n    public static ConstantTargetCountForTextureMode = 0;\r\n\r\n    private _targets = new Array<MorphTarget>();\r\n    private _targetInfluenceChangedObservers = new Array<Nullable<Observer<boolean>>>();\r\n    private _targetDataLayoutChangedObservers = new Array<Nullable<Observer<void>>>();\r\n    private _activeTargets = new SmartArray<MorphTarget>(16);\r\n    private _scene: Nullable<Scene>;\r\n    private _influences: Float32Array;\r\n    private _supportsPositions = false;\r\n    private _supportsNormals = false;\r\n    private _supportsTangents = false;\r\n    private _supportsUVs = false;\r\n    private _supportsUV2s = false;\r\n    private _supportsColors = false;\r\n    private _vertexCount = 0;\r\n    private _uniqueId = 0;\r\n    private _tempInfluences = new Array<number>();\r\n    private _canUseTextureForTargets = false;\r\n    private _blockCounter = 0;\r\n    private _mustSynchronize = true;\r\n    private _forceUpdateWhenUnfrozen = false;\r\n\r\n    /** @internal */\r\n    public _textureVertexStride = 0;\r\n\r\n    /** @internal */\r\n    public _textureWidth = 0;\r\n\r\n    /** @internal */\r\n    public _textureHeight = 1;\r\n\r\n    /** @internal */\r\n    public _morphTargetTextureIndices: Float32Array;\r\n\r\n    /** @internal */\r\n    public _parentContainer: Nullable<IAssetContainer> = null;\r\n\r\n    /** @internal */\r\n    public _targetStoreTexture: Nullable<RawTexture2DArray>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if influencers must be optimized (eg. recompiling the shader if less influencers are used)\r\n     */\r\n    public optimizeInfluencers = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if positions must be morphed\r\n     */\r\n    public enablePositionMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if normals must be morphed\r\n     */\r\n    public enableNormalMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if tangents must be morphed\r\n     */\r\n    public enableTangentMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV must be morphed\r\n     */\r\n    public enableUVMorphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if UV2 must be morphed\r\n     */\r\n    public enableUV2Morphing = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if colors must be morphed\r\n     */\r\n    public enableColorMorphing = true;\r\n\r\n    /**\r\n     * Sets a boolean indicating that adding new target or updating an existing target will not update the underlying data buffers\r\n     */\r\n    public set areUpdatesFrozen(block: boolean) {\r\n        if (block) {\r\n            this._blockCounter++;\r\n        } else {\r\n            this._blockCounter--;\r\n            if (this._blockCounter <= 0) {\r\n                this._blockCounter = 0;\r\n\r\n                this._syncActiveTargets(this._forceUpdateWhenUnfrozen);\r\n                this._forceUpdateWhenUnfrozen = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    public get areUpdatesFrozen() {\r\n        return this._blockCounter > 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager\r\n     * @param scene defines the current scene\r\n     */\r\n    public constructor(scene: Nullable<Scene> = null) {\r\n        if (!scene) {\r\n            scene = EngineStore.LastCreatedScene;\r\n        }\r\n\r\n        this._scene = scene;\r\n\r\n        if (this._scene) {\r\n            this._scene.addMorphTargetManager(this);\r\n\r\n            this._uniqueId = this._scene.getUniqueId();\r\n\r\n            const engineCaps = this._scene.getEngine().getCaps();\r\n            this._canUseTextureForTargets =\r\n                engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;\r\n        }\r\n    }\r\n\r\n    private _numMaxInfluencers = 0;\r\n\r\n    /**\r\n     * Gets or sets the maximum number of influencers (targets) (default value: 0).\r\n     * Setting a value for this property can lead to a smoother experience, as only one shader will be compiled, which will use this value as the maximum number of influencers.\r\n     * If you leave the value at 0 (default), a new shader will be compiled every time the number of active influencers changes. This can cause problems, as compiling a shader takes time.\r\n     * If you assign a non-zero value to this property, you need to ensure that this value is greater than the maximum number of (active) influencers you'll need for this morph manager.\r\n     * Otherwise, the number of active influencers will be truncated at the value you set for this property, which can lead to unexpected results.\r\n     * Note that this property has no effect if \"useTextureToStoreTargets\" is false.\r\n     * Note as well that if MorphTargetManager.ConstantTargetCountForTextureMode is greater than 0, this property will be ignored and the constant value will be used instead.\r\n     */\r\n    public get numMaxInfluencers(): number {\r\n        if (MorphTargetManager.ConstantTargetCountForTextureMode > 0 && this.isUsingTextureForTargets) {\r\n            return MorphTargetManager.ConstantTargetCountForTextureMode;\r\n        }\r\n        return this._numMaxInfluencers;\r\n    }\r\n\r\n    public set numMaxInfluencers(value: number) {\r\n        if (this._numMaxInfluencers === value) {\r\n            return;\r\n        }\r\n\r\n        this._numMaxInfluencers = value;\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Gets the unique ID of this manager\r\n     */\r\n    public get uniqueId(): number {\r\n        return this._uniqueId;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of vertices handled by this manager\r\n     */\r\n    public get vertexCount(): number {\r\n        return this._vertexCount;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of positions\r\n     */\r\n    public get supportsPositions(): boolean {\r\n        return this._supportsPositions && this.enablePositionMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of normals\r\n     */\r\n    public get supportsNormals(): boolean {\r\n        return this._supportsNormals && this.enableNormalMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of tangents\r\n     */\r\n    public get supportsTangents(): boolean {\r\n        return this._supportsTangents && this.enableTangentMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates\r\n     */\r\n    public get supportsUVs(): boolean {\r\n        return this._supportsUVs && this.enableUVMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of texture coordinates 2\r\n     */\r\n    public get supportsUV2s(): boolean {\r\n        return this._supportsUV2s && this.enableUV2Morphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager supports morphing of colors\r\n     */\r\n    public get supportsColors(): boolean {\r\n        return this._supportsColors && this.enableColorMorphing;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing positions\r\n     */\r\n    public get hasPositions(): boolean {\r\n        return this._supportsPositions;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing normals\r\n     */\r\n    public get hasNormals(): boolean {\r\n        return this._supportsNormals;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing tangents\r\n     */\r\n    public get hasTangents(): boolean {\r\n        return this._supportsTangents;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing texture coordinates\r\n     */\r\n    public get hasUVs(): boolean {\r\n        return this._supportsUVs;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing texture coordinates 2\r\n     */\r\n    public get hasUV2s(): boolean {\r\n        return this._supportsUV2s;\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating if this manager has data for morphing colors\r\n     */\r\n    public get hasColors(): boolean {\r\n        return this._supportsColors;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of targets stored in this manager\r\n     */\r\n    public get numTargets(): number {\r\n        return this._targets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the number of influencers (ie. the number of targets with influences > 0)\r\n     */\r\n    public get numInfluencers(): number {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        return this._activeTargets.length;\r\n    }\r\n\r\n    /**\r\n     * Gets the list of influences (one per target)\r\n     */\r\n    public get influences(): Float32Array {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        return this._influences;\r\n    }\r\n\r\n    private _useTextureToStoreTargets = true;\r\n    /**\r\n     * Gets or sets a boolean indicating that targets should be stored as a texture instead of using vertex attributes (default is true).\r\n     * Please note that this option is not available if the hardware does not support it\r\n     */\r\n    public get useTextureToStoreTargets(): boolean {\r\n        return this._useTextureToStoreTargets;\r\n    }\r\n\r\n    public set useTextureToStoreTargets(value: boolean) {\r\n        if (this._useTextureToStoreTargets === value) {\r\n            return;\r\n        }\r\n        this._useTextureToStoreTargets = value;\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Gets a boolean indicating that the targets are stored into a texture (instead of as attributes)\r\n     */\r\n    public get isUsingTextureForTargets() {\r\n        return (\r\n            MorphTargetManager.EnableTextureStorage &&\r\n            this.useTextureToStoreTargets &&\r\n            this._canUseTextureForTargets &&\r\n            !this._scene?.getEngine().getCaps().disableMorphTargetTexture\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the MorphTargetManager\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Gets the active target at specified index. An active target is a target with an influence > 0\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getActiveTarget(index: number): MorphTarget {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        return this._activeTargets.data[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the target at specified index\r\n     * @param index defines the index to check\r\n     * @returns the requested target\r\n     */\r\n    public getTarget(index: number): MorphTarget {\r\n        return this._targets[index];\r\n    }\r\n\r\n    /**\r\n     * Gets the first target with the specified name\r\n     * @param name defines the name to check\r\n     * @returns the requested target\r\n     */\r\n    public getTargetByName(name: string): Nullable<MorphTarget> {\r\n        for (const target of this._targets) {\r\n            if (target.name === name) {\r\n                return target;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _influencesAreDirty = false;\r\n    private _needUpdateInfluences = false;\r\n\r\n    /**\r\n     * Add a new target to this manager\r\n     * @param target defines the target to add\r\n     */\r\n    public addTarget(target: MorphTarget): void {\r\n        this._targets.push(target);\r\n        this._targetInfluenceChangedObservers.push(\r\n            target.onInfluenceChanged.add((needUpdate) => {\r\n                if (this.areUpdatesFrozen && needUpdate) {\r\n                    this._forceUpdateWhenUnfrozen = true;\r\n                }\r\n                this._influencesAreDirty = true;\r\n                this._needUpdateInfluences = this._needUpdateInfluences || needUpdate;\r\n            })\r\n        );\r\n        this._targetDataLayoutChangedObservers.push(\r\n            target._onDataLayoutChanged.add(() => {\r\n                this._mustSynchronize = true;\r\n                this._syncActiveTargets();\r\n            })\r\n        );\r\n        this._mustSynchronize = true;\r\n        this._syncActiveTargets();\r\n    }\r\n\r\n    /**\r\n     * Removes a target from the manager\r\n     * @param target defines the target to remove\r\n     */\r\n    public removeTarget(target: MorphTarget): void {\r\n        const index = this._targets.indexOf(target);\r\n        if (index >= 0) {\r\n            this._targets.splice(index, 1);\r\n\r\n            target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);\r\n            target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);\r\n            this._mustSynchronize = true;\r\n            this._syncActiveTargets();\r\n        }\r\n\r\n        if (this._scene) {\r\n            this._scene.stopAnimation(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _bind(effect: Effect) {\r\n        if (this._influencesAreDirty) {\r\n            this._syncActiveTargets();\r\n        }\r\n        effect.setFloat3(\"morphTargetTextureInfo\", this._textureVertexStride, this._textureWidth, this._textureHeight);\r\n        effect.setFloatArray(\"morphTargetTextureIndices\", this._morphTargetTextureIndices);\r\n        effect.setTexture(\"morphTargets\", this._targetStoreTexture);\r\n        effect.setFloat(\"morphTargetCount\", this.numInfluencers);\r\n    }\r\n\r\n    /**\r\n     * Clone the current manager\r\n     * @returns a new MorphTargetManager\r\n     */\r\n    public clone(): MorphTargetManager {\r\n        const copy = new MorphTargetManager(this._scene);\r\n        copy.areUpdatesFrozen = true;\r\n\r\n        for (const target of this._targets) {\r\n            copy.addTarget(target.clone());\r\n        }\r\n        copy.areUpdatesFrozen = false;\r\n\r\n        copy.enablePositionMorphing = this.enablePositionMorphing;\r\n        copy.enableNormalMorphing = this.enableNormalMorphing;\r\n        copy.enableTangentMorphing = this.enableTangentMorphing;\r\n        copy.enableUVMorphing = this.enableUVMorphing;\r\n        copy.enableUV2Morphing = this.enableUV2Morphing;\r\n        copy.enableColorMorphing = this.enableColorMorphing;\r\n        copy.metadata = this.metadata;\r\n\r\n        return copy;\r\n    }\r\n\r\n    /**\r\n     * Serializes the current manager into a Serialization object\r\n     * @returns the serialized object\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {};\r\n\r\n        serializationObject.id = this.uniqueId;\r\n\r\n        serializationObject.targets = [];\r\n        for (const target of this._targets) {\r\n            serializationObject.targets.push(target.serialize());\r\n        }\r\n\r\n        if (this.metadata) {\r\n            serializationObject.metadata = this.metadata;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    private _syncActiveTargets(needUpdate = false): void {\r\n        if (this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        needUpdate = needUpdate || this._needUpdateInfluences;\r\n\r\n        this._needUpdateInfluences = false;\r\n        this._influencesAreDirty = false;\r\n\r\n        const wasUsingTextureForTargets = !!this._targetStoreTexture;\r\n        const isUsingTextureForTargets = this.isUsingTextureForTargets;\r\n\r\n        if (this._mustSynchronize || wasUsingTextureForTargets !== isUsingTextureForTargets) {\r\n            this._mustSynchronize = false;\r\n            this.synchronize();\r\n        }\r\n\r\n        let influenceCount = 0;\r\n        this._activeTargets.reset();\r\n\r\n        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {\r\n            this._morphTargetTextureIndices = new Float32Array(this._targets.length);\r\n        }\r\n\r\n        let targetIndex = -1;\r\n        for (const target of this._targets) {\r\n            targetIndex++;\r\n            if (target.influence === 0 && this.optimizeInfluencers) {\r\n                continue;\r\n            }\r\n\r\n            if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {\r\n                break;\r\n            }\r\n\r\n            this._activeTargets.push(target);\r\n            this._morphTargetTextureIndices[influenceCount] = targetIndex;\r\n            this._tempInfluences[influenceCount++] = target.influence;\r\n        }\r\n\r\n        if (this._morphTargetTextureIndices.length !== influenceCount) {\r\n            this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);\r\n        }\r\n\r\n        if (!this._influences || this._influences.length !== influenceCount) {\r\n            this._influences = new Float32Array(influenceCount);\r\n        }\r\n\r\n        for (let index = 0; index < influenceCount; index++) {\r\n            this._influences[index] = this._tempInfluences[index];\r\n        }\r\n\r\n        if (needUpdate && this._scene) {\r\n            for (const mesh of this._scene.meshes) {\r\n                if ((<any>mesh).morphTargetManager === this) {\r\n                    if (isUsingTextureForTargets) {\r\n                        mesh._markSubMeshesAsAttributesDirty();\r\n                    } else {\r\n                        (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronize the targets with all the meshes using this morph target manager\r\n     */\r\n    public synchronize(): void {\r\n        if (!this._scene || this.areUpdatesFrozen) {\r\n            return;\r\n        }\r\n\r\n        const engine = this._scene.getEngine();\r\n\r\n        this._supportsPositions = true;\r\n        this._supportsNormals = true;\r\n        this._supportsTangents = true;\r\n        this._supportsUVs = true;\r\n        this._supportsUV2s = true;\r\n        this._supportsColors = true;\r\n        this._vertexCount = 0;\r\n\r\n        this._targetStoreTexture?.dispose();\r\n        this._targetStoreTexture = null;\r\n\r\n        if (this.isUsingTextureForTargets && this._targets.length > engine.getCaps().texture2DArrayMaxLayerCount) {\r\n            this.useTextureToStoreTargets = false;\r\n        }\r\n\r\n        for (const target of this._targets) {\r\n            this._supportsPositions = this._supportsPositions && target.hasPositions;\r\n            this._supportsNormals = this._supportsNormals && target.hasNormals;\r\n            this._supportsTangents = this._supportsTangents && target.hasTangents;\r\n            this._supportsUVs = this._supportsUVs && target.hasUVs;\r\n            this._supportsUV2s = this._supportsUV2s && target.hasUV2s;\r\n            this._supportsColors = this._supportsColors && target.hasColors;\r\n\r\n            const vertexCount = target.vertexCount;\r\n            if (this._vertexCount === 0) {\r\n                this._vertexCount = vertexCount;\r\n            } else if (this._vertexCount !== vertexCount) {\r\n                Logger.Error(\r\n                    `Incompatible target. Targets must all have the same vertices count. Current vertex count: ${this._vertexCount}, vertex count for target \"${target.name}\": ${vertexCount}`\r\n                );\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (this.isUsingTextureForTargets) {\r\n            this._textureVertexStride = 0;\r\n\r\n            this._supportsPositions && this._textureVertexStride++;\r\n            this._supportsNormals && this._textureVertexStride++;\r\n            this._supportsTangents && this._textureVertexStride++;\r\n            this._supportsUVs && this._textureVertexStride++;\r\n            this._supportsUV2s && this._textureVertexStride++;\r\n            this._supportsColors && this._textureVertexStride++;\r\n\r\n            this._textureWidth = this._vertexCount * this._textureVertexStride || 1;\r\n            this._textureHeight = 1;\r\n\r\n            const maxTextureSize = engine.getCaps().maxTextureSize;\r\n            if (this._textureWidth > maxTextureSize) {\r\n                this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);\r\n                this._textureWidth = maxTextureSize;\r\n            }\r\n\r\n            const targetCount = this._targets.length;\r\n            const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);\r\n\r\n            let offset = 0;\r\n            for (let index = 0; index < targetCount; index++) {\r\n                const target = this._targets[index];\r\n\r\n                const positions = target.getPositions();\r\n                const normals = target.getNormals();\r\n                const uvs = target.getUVs();\r\n                const tangents = target.getTangents();\r\n                const uv2s = target.getUV2s();\r\n                const colors = target.getColors();\r\n\r\n                offset = index * this._textureWidth * this._textureHeight * 4;\r\n                for (let vertex = 0; vertex < this._vertexCount; vertex++) {\r\n                    if (this._supportsPositions && positions) {\r\n                        data[offset] = positions[vertex * 3];\r\n                        data[offset + 1] = positions[vertex * 3 + 1];\r\n                        data[offset + 2] = positions[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsNormals && normals) {\r\n                        data[offset] = normals[vertex * 3];\r\n                        data[offset + 1] = normals[vertex * 3 + 1];\r\n                        data[offset + 2] = normals[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsUVs && uvs) {\r\n                        data[offset] = uvs[vertex * 2];\r\n                        data[offset + 1] = uvs[vertex * 2 + 1];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsTangents && tangents) {\r\n                        data[offset] = tangents[vertex * 3];\r\n                        data[offset + 1] = tangents[vertex * 3 + 1];\r\n                        data[offset + 2] = tangents[vertex * 3 + 2];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsUV2s && uv2s) {\r\n                        data[offset] = uv2s[vertex * 2];\r\n                        data[offset + 1] = uv2s[vertex * 2 + 1];\r\n                        offset += 4;\r\n                    }\r\n\r\n                    if (this._supportsColors && colors) {\r\n                        data[offset] = colors[vertex * 4];\r\n                        data[offset + 1] = colors[vertex * 4 + 1];\r\n                        data[offset + 2] = colors[vertex * 4 + 2];\r\n                        data[offset + 3] = colors[vertex * 4 + 3];\r\n                        offset += 4;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(\r\n                data,\r\n                this._textureWidth,\r\n                this._textureHeight,\r\n                targetCount,\r\n                this._scene,\r\n                false,\r\n                false,\r\n                Constants.TEXTURE_NEAREST_SAMPLINGMODE,\r\n                Constants.TEXTURETYPE_FLOAT\r\n            );\r\n            this._targetStoreTexture.name = `Morph texture_${this.uniqueId}`;\r\n        }\r\n\r\n        // Flag meshes as dirty to resync with the active targets\r\n        for (const mesh of this._scene.meshes) {\r\n            if ((<any>mesh).morphTargetManager === this) {\r\n                (<Mesh>mesh)._syncGeometryWithMorphTargetManager();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public dispose() {\r\n        if (this._targetStoreTexture) {\r\n            this._targetStoreTexture.dispose();\r\n        }\r\n\r\n        this._targetStoreTexture = null;\r\n        this.metadata = null;\r\n\r\n        // Remove from scene\r\n        if (this._scene) {\r\n            this._scene.removeMorphTargetManager(this);\r\n\r\n            if (this._parentContainer) {\r\n                const index = this._parentContainer.morphTargetManagers.indexOf(this);\r\n                if (index > -1) {\r\n                    this._parentContainer.morphTargetManagers.splice(index, 1);\r\n                }\r\n                this._parentContainer = null;\r\n            }\r\n\r\n            for (const morph of this._targets) {\r\n                this._scene.stopAnimation(morph);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Statics\r\n\r\n    /**\r\n     * Creates a new MorphTargetManager from serialized data\r\n     * @param serializationObject defines the serialized data\r\n     * @param scene defines the hosting scene\r\n     * @returns the new MorphTargetManager\r\n     */\r\n    public static Parse(serializationObject: any, scene: Scene): MorphTargetManager {\r\n        const result = new MorphTargetManager(scene);\r\n\r\n        for (const targetData of serializationObject.targets) {\r\n            result.addTarget(MorphTarget.Parse(targetData, scene));\r\n        }\r\n\r\n        if (serializationObject.metadata) {\r\n            result.metadata = serializationObject.metadata;\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n","import { Decode } from \"./stringTools\";\r\n\r\n/**\r\n * Interface for a data buffer\r\n */\r\nexport interface IDataBuffer {\r\n    /**\r\n     * Reads bytes from the data buffer.\r\n     * @param byteOffset The byte offset to read\r\n     * @param byteLength The byte length to read\r\n     * @returns A promise that resolves when the bytes are read\r\n     */\r\n    readAsync(byteOffset: number, byteLength: number): Promise<ArrayBufferView>;\r\n\r\n    /**\r\n     * The byte length of the buffer.\r\n     */\r\n    readonly byteLength: number;\r\n}\r\n\r\n/**\r\n * Utility class for reading from a data buffer\r\n */\r\nexport class DataReader {\r\n    /**\r\n     * The data buffer associated with this data reader.\r\n     */\r\n    public readonly buffer: IDataBuffer;\r\n\r\n    /**\r\n     * The current byte offset from the beginning of the data buffer.\r\n     */\r\n    public byteOffset = 0;\r\n\r\n    private _dataView: DataView;\r\n    private _dataByteOffset: number;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param buffer The buffer to read\r\n     */\r\n    constructor(buffer: IDataBuffer) {\r\n        this.buffer = buffer;\r\n    }\r\n\r\n    /**\r\n     * Loads the given byte length.\r\n     * @param byteLength The byte length to load\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public async loadAsync(byteLength: number): Promise<void> {\r\n        const data = await this.buffer.readAsync(this.byteOffset, byteLength);\r\n        this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);\r\n        this._dataByteOffset = 0;\r\n    }\r\n\r\n    /**\r\n     * Read a unsigned 32-bit integer from the currently loaded data range.\r\n     * @returns The 32-bit integer read\r\n     */\r\n    public readUint32(): number {\r\n        const value = this._dataView.getUint32(this._dataByteOffset, true);\r\n        this._dataByteOffset += 4;\r\n        this.byteOffset += 4;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a byte array from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The byte array read\r\n     */\r\n    public readUint8Array(byteLength: number): Uint8Array {\r\n        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);\r\n        this._dataByteOffset += byteLength;\r\n        this.byteOffset += byteLength;\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Read a string from the currently loaded data range.\r\n     * @param byteLength The byte length to read\r\n     * @returns The string read\r\n     */\r\n    public readString(byteLength: number): string {\r\n        return Decode(this.readUint8Array(byteLength));\r\n    }\r\n\r\n    /**\r\n     * Skips the given byte length the currently loaded data range.\r\n     * @param byteLength The byte length to skip\r\n     */\r\n    public skipBytes(byteLength: number): void {\r\n        this._dataByteOffset += byteLength;\r\n        this.byteOffset += byteLength;\r\n    }\r\n}\r\n","/* eslint-disable github/no-then */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare let GLTFValidator: GLTF2.IGLTFValidator;\r\n\r\n// WorkerGlobalScope\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function importScripts(...urls: string[]): void;\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ndeclare function postMessage(message: any, transfer?: any[]): void;\r\n\r\nfunction ValidateAsync(\r\n    data: string | Uint8Array,\r\n    rootUrl: string,\r\n    fileName: string,\r\n    getExternalResource: (uri: string) => Promise<Uint8Array>\r\n): Promise<GLTF2.IGLTFValidationResults> {\r\n    const options: GLTF2.IGLTFValidationOptions = {\r\n        externalResourceFunction: getExternalResource,\r\n    };\r\n\r\n    if (fileName) {\r\n        options.uri = rootUrl === \"file:\" ? fileName : rootUrl + fileName;\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? GLTFValidator.validateBytes(data, options) : GLTFValidator.validateString(data, options);\r\n}\r\n\r\n/**\r\n * The worker function that gets converted to a blob url to pass into a worker.\r\n */\r\nfunction WorkerFunc(): void {\r\n    const pendingExternalResources: Array<{ resolve: (data: any) => void; reject: (reason: any) => void }> = [];\r\n\r\n    onmessage = (message) => {\r\n        const data = message.data;\r\n        switch (data.id) {\r\n            case \"init\": {\r\n                importScripts(data.url);\r\n                break;\r\n            }\r\n            case \"validate\": {\r\n                ValidateAsync(\r\n                    data.data,\r\n                    data.rootUrl,\r\n                    data.fileName,\r\n                    (uri) =>\r\n                        new Promise((resolve, reject) => {\r\n                            const index = pendingExternalResources.length;\r\n                            pendingExternalResources.push({ resolve, reject });\r\n                            postMessage({ id: \"getExternalResource\", index: index, uri: uri });\r\n                        })\r\n                ).then(\r\n                    (value) => {\r\n                        postMessage({ id: \"validate.resolve\", value: value });\r\n                    },\r\n                    (reason) => {\r\n                        postMessage({ id: \"validate.reject\", reason: reason });\r\n                    }\r\n                );\r\n                break;\r\n            }\r\n            case \"getExternalResource.resolve\": {\r\n                pendingExternalResources[data.index].resolve(data.value);\r\n                break;\r\n            }\r\n            case \"getExternalResource.reject\": {\r\n                pendingExternalResources[data.index].reject(data.reason);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Configuration for glTF validation\r\n */\r\nexport interface IGLTFValidationConfiguration {\r\n    /**\r\n     * The url of the glTF validator.\r\n     */\r\n    url: string;\r\n}\r\n\r\n/**\r\n * glTF validation\r\n */\r\nexport class GLTFValidation {\r\n    /**\r\n     * The configuration. Defaults to `{ url: \"https://cdn.babylonjs.com/gltf_validator.js\" }`.\r\n     */\r\n    public static Configuration: IGLTFValidationConfiguration = {\r\n        url: `${Tools._DefaultCdnUrl}/gltf_validator.js`,\r\n    };\r\n\r\n    private static _LoadScriptPromise: Promise<void>;\r\n\r\n    /**\r\n     * Validate a glTF asset using the glTF-Validator.\r\n     * @param data The JSON of a glTF or the array buffer of a binary glTF\r\n     * @param rootUrl The root url for the glTF\r\n     * @param fileName The file name for the glTF\r\n     * @param getExternalResource The callback to get external resources for the glTF validator\r\n     * @returns A promise that resolves with the glTF validation results once complete\r\n     */\r\n    public static ValidateAsync(\r\n        data: string | Uint8Array,\r\n        rootUrl: string,\r\n        fileName: string,\r\n        getExternalResource: (uri: string) => Promise<Uint8Array>\r\n    ): Promise<GLTF2.IGLTFValidationResults> {\r\n        if (typeof Worker === \"function\") {\r\n            return new Promise((resolve, reject) => {\r\n                const workerContent = `${ValidateAsync}(${WorkerFunc})()`;\r\n                const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: \"application/javascript\" }));\r\n                const worker = new Worker(workerBlobUrl);\r\n\r\n                const onError = (error: ErrorEvent) => {\r\n                    worker.removeEventListener(\"error\", onError);\r\n                    worker.removeEventListener(\"message\", onMessage);\r\n                    // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                    reject(error);\r\n                };\r\n\r\n                const onMessage = (message: MessageEvent) => {\r\n                    const data = message.data;\r\n                    switch (data.id) {\r\n                        case \"getExternalResource\": {\r\n                            getExternalResource(data.uri).then(\r\n                                (value) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.resolve\", index: data.index, value: value }, [value.buffer]);\r\n                                },\r\n                                (reason) => {\r\n                                    worker.postMessage({ id: \"getExternalResource.reject\", index: data.index, reason: reason });\r\n                                }\r\n                            );\r\n                            break;\r\n                        }\r\n                        case \"validate.resolve\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            resolve(data.value);\r\n                            worker.terminate();\r\n                            break;\r\n                        }\r\n                        case \"validate.reject\": {\r\n                            worker.removeEventListener(\"error\", onError);\r\n                            worker.removeEventListener(\"message\", onMessage);\r\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                            reject(data.reason);\r\n                            worker.terminate();\r\n                        }\r\n                    }\r\n                };\r\n\r\n                worker.addEventListener(\"error\", onError);\r\n                worker.addEventListener(\"message\", onMessage);\r\n\r\n                worker.postMessage({ id: \"init\", url: Tools.GetBabylonScriptURL(this.Configuration.url) });\r\n\r\n                if (ArrayBuffer.isView(data)) {\r\n                    // Slice the data to avoid copying the whole array buffer.\r\n                    const slicedData = data.slice();\r\n                    worker.postMessage({ id: \"validate\", data: slicedData, rootUrl: rootUrl, fileName: fileName }, [slicedData.buffer]);\r\n                } else {\r\n                    worker.postMessage({ id: \"validate\", data: data, rootUrl: rootUrl, fileName: fileName });\r\n                }\r\n            });\r\n        } else {\r\n            if (!this._LoadScriptPromise) {\r\n                this._LoadScriptPromise = Tools.LoadBabylonScriptAsync(this.Configuration.url);\r\n            }\r\n\r\n            return this._LoadScriptPromise.then(() => {\r\n                return ValidateAsync(data, rootUrl, fileName, getExternalResource);\r\n            });\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable github/no-then */\r\n/* eslint-disable @typescript-eslint/no-floating-promises */\r\n/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type * as GLTF2 from \"babylonjs-gltf2interface\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { ISceneLoaderPluginFactory, ISceneLoaderPluginAsync, ISceneLoaderProgressEvent, ISceneLoaderAsyncResult, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene, IDisposable } from \"core/scene\";\r\nimport type { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IFileRequest } from \"core/Misc/fileRequest\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DataReader } from \"core/Misc/dataReader\";\r\nimport { GLTFValidation } from \"./glTFValidation\";\r\nimport { GLTFFileLoaderMetadata, GLTFMagicBase64Encoded } from \"./glTFFileLoader.metadata\";\r\nimport type { LoadFileError } from \"core/Misc/fileTools\";\r\nimport { DecodeBase64UrlToBinary } from \"core/Misc/fileTools\";\r\nimport { RuntimeError, ErrorCodes } from \"core/Misc/error\";\r\nimport type { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\n\r\n/**\r\n * Defines options for glTF loader extensions. This interface is extended by specific extensions.\r\n */\r\nexport interface GLTFLoaderExtensionOptions extends Record<string, Record<string, unknown> | undefined> {}\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the glTF loader.\r\n         */\r\n        [GLTFFileLoaderMetadata.name]: Partial<GLTFLoaderOptions>;\r\n    }\r\n}\r\n\r\ninterface IFileRequestInfo extends IFileRequest {\r\n    _lengthComputable?: boolean;\r\n    _loaded?: number;\r\n    _total?: number;\r\n}\r\n\r\nfunction readAsync(arrayBuffer: ArrayBuffer, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        return Promise.resolve(new Uint8Array(arrayBuffer, byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\nfunction readViewAsync(arrayBufferView: ArrayBufferView, byteOffset: number, byteLength: number): Promise<Uint8Array> {\r\n    try {\r\n        if (byteOffset < 0 || byteOffset >= arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Offset is out of range.\");\r\n        }\r\n\r\n        if (byteOffset + byteLength > arrayBufferView.byteLength) {\r\n            throw new RangeError(\"Length is out of range.\");\r\n        }\r\n\r\n        return Promise.resolve(new Uint8Array(arrayBufferView.buffer, arrayBufferView.byteOffset + byteOffset, byteLength));\r\n    } catch (e) {\r\n        return Promise.reject(e);\r\n    }\r\n}\r\n\r\n/**\r\n * Mode that determines the coordinate system to use.\r\n */\r\nexport enum GLTFLoaderCoordinateSystemMode {\r\n    /**\r\n     * Automatically convert the glTF right-handed data to the appropriate system based on the current coordinate system mode of the scene.\r\n     */\r\n    AUTO,\r\n\r\n    /**\r\n     * Sets the useRightHandedSystem flag on the scene.\r\n     */\r\n    FORCE_RIGHT_HANDED,\r\n}\r\n\r\n/**\r\n * Mode that determines what animations will start.\r\n */\r\nexport enum GLTFLoaderAnimationStartMode {\r\n    /**\r\n     * No animation will start.\r\n     */\r\n    NONE,\r\n\r\n    /**\r\n     * The first animation will start.\r\n     */\r\n    FIRST,\r\n\r\n    /**\r\n     * All animations will start.\r\n     */\r\n    ALL,\r\n}\r\n\r\n/**\r\n * Interface that contains the data for the glTF asset.\r\n */\r\nexport interface IGLTFLoaderData {\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    json: object;\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    bin: Nullable<IDataBuffer>;\r\n}\r\n\r\n/**\r\n * Interface for extending the loader.\r\n */\r\nexport interface IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    readonly name: string;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines the order of this extension.\r\n     * The loader sorts the extensions using these values when loading.\r\n     */\r\n    order?: number;\r\n}\r\n\r\n/**\r\n * Loader state.\r\n */\r\nexport enum GLTFLoaderState {\r\n    /**\r\n     * The asset is loading.\r\n     */\r\n    LOADING,\r\n\r\n    /**\r\n     * The asset is ready for rendering.\r\n     */\r\n    READY,\r\n\r\n    /**\r\n     * The asset is completely loaded.\r\n     */\r\n    COMPLETE,\r\n}\r\n\r\n/** @internal */\r\nexport interface IGLTFLoader extends IDisposable {\r\n    importMeshAsync: (\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ) => Promise<ISceneLoaderAsyncResult>;\r\n    loadAsync: (scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string) => Promise<void>;\r\n}\r\n\r\n/**\r\n * Adds default/implicit options to extension specific options.\r\n */\r\ntype DefaultExtensionOptions<BaseExtensionOptions> = {\r\n    /**\r\n     * Defines if the extension is enabled\r\n     */\r\n    enabled?: boolean;\r\n} & BaseExtensionOptions;\r\n\r\n/**\r\n * This class contains all the concrete (not abstract) glTF options, excluding callbacks.\r\n * The purpose of this class is to make it easy to provide a way to mutate the default\r\n * loader options (see the GLTFLoaderDefaultOptions instance below) without duplicating\r\n * all the options in yet another object. Since this class is instantiated for the default\r\n * options object, abstract properties and callbacks are not included, it's more just\r\n * flag-type options.\r\n */\r\nclass GLTFLoaderBaseOptions {\r\n    /**\r\n     * Defines if the loader should always compute the bounding boxes of meshes and not use the min/max values from the position accessor. Defaults to false.\r\n     */\r\n    public alwaysComputeBoundingBox = false;\r\n\r\n    /**\r\n     * Defines if the loader should always compute the nearest common ancestor of the skeleton joints instead of using `skin.skeleton`. Defaults to false.\r\n     * Set this to true if loading assets with invalid `skin.skeleton` values.\r\n     */\r\n    public alwaysComputeSkeletonRootNode = false;\r\n\r\n    /**\r\n     * The animation start mode. Defaults to FIRST.\r\n     */\r\n    public animationStartMode = GLTFLoaderAnimationStartMode.FIRST;\r\n\r\n    /**\r\n     * Defines if the loader should compile materials before raising the success callback. Defaults to false.\r\n     */\r\n    public compileMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should compile shadow generators before raising the success callback. Defaults to false.\r\n     */\r\n    public compileShadowGenerators = false;\r\n\r\n    /**\r\n     * The coordinate system mode. Defaults to AUTO.\r\n     */\r\n    public coordinateSystemMode = GLTFLoaderCoordinateSystemMode.AUTO;\r\n\r\n    /**\r\n     * Defines if the loader should create instances when multiple glTF nodes point to the same glTF mesh. Defaults to true.\r\n     */\r\n    public createInstances = true;\r\n\r\n    /**\r\n     * If true, load all materials defined in the file, even if not used by any mesh. Defaults to false.\r\n     */\r\n    public loadAllMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load morph targets. Defaults to true.\r\n     */\r\n    public loadMorphTargets = true;\r\n\r\n    /**\r\n     * Defines if the loader should load node animations. Defaults to true.\r\n     * NOTE: The animation of this node will still load if the node is also a joint of a skin and `loadSkins` is true.\r\n     */\r\n    public loadNodeAnimations = true;\r\n\r\n    /**\r\n     * If true, load only the materials defined in the file. Defaults to false.\r\n     */\r\n    public loadOnlyMaterials = false;\r\n\r\n    /**\r\n     * Defines if the loader should load skins. Defaults to true.\r\n     */\r\n    public loadSkins = true;\r\n\r\n    /**\r\n     * If true, do not load any materials defined in the file. Defaults to false.\r\n     */\r\n    public skipMaterials = false;\r\n\r\n    /**\r\n     * When loading glTF animations, which are defined in seconds, target them to this FPS. Defaults to 60.\r\n     */\r\n    public targetFps = 60;\r\n\r\n    /**\r\n     * Defines if the Alpha blended materials are only applied as coverage.\r\n     * If false, (default) The luminance of each pixel will reduce its opacity to simulate the behaviour of most physical materials.\r\n     * If true, no extra effects are applied to transparent pixels.\r\n     */\r\n    public transparencyAsCoverage = false;\r\n\r\n    /**\r\n     * Defines if the loader should also compile materials with clip planes. Defaults to false.\r\n     */\r\n    public useClipPlane = false;\r\n\r\n    /**\r\n     * If true, the loader will derive the name for Babylon textures from the glTF texture name, image name, or image url. Defaults to false.\r\n     * Note that it is possible for multiple Babylon textures to share the same name when the Babylon textures load from the same glTF texture or image.\r\n     */\r\n    public useGltfTextureNames = false;\r\n\r\n    /**\r\n     * Defines if the loader should use range requests when load binary glTF files from HTTP.\r\n     * Enabling will disable offline support and glTF validator.\r\n     * Defaults to false.\r\n     */\r\n    public useRangeRequests = false;\r\n\r\n    /**\r\n     * If true, load the color (gamma encoded) textures into sRGB buffers (if supported by the GPU), which will yield more accurate results when sampling the texture. Defaults to true.\r\n     */\r\n    public useSRGBBuffers = true;\r\n\r\n    /**\r\n     * Defines if the loader should validate the asset.\r\n     */\r\n    public validate = false;\r\n\r\n    /**\r\n     * Load the glTF files using the OpenPBR material.\r\n     * @experimental\r\n     */\r\n    public useOpenPBR = false;\r\n\r\n    /**\r\n     * If true, the loader will not use the transmission helper when loading materials with transmission.\r\n     */\r\n    public dontUseTransmissionHelper = false;\r\n}\r\n\r\n/**\r\n * The default GLTF loader options.\r\n * Override the properties of this object to globally change the default loader options.\r\n * To specify options for a specific load call, pass those options into the associated load function.\r\n */\r\nexport const GLTFLoaderDefaultOptions = new GLTFLoaderBaseOptions();\r\n\r\nabstract class GLTFLoaderOptions extends GLTFLoaderBaseOptions {\r\n    // eslint-disable-next-line babylonjs/available\r\n    protected copyFrom(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        if (options) {\r\n            this.alwaysComputeBoundingBox = options.alwaysComputeBoundingBox ?? this.alwaysComputeBoundingBox;\r\n            this.alwaysComputeSkeletonRootNode = options.alwaysComputeSkeletonRootNode ?? this.alwaysComputeSkeletonRootNode;\r\n            this.animationStartMode = options.animationStartMode ?? this.animationStartMode;\r\n            this.capturePerformanceCounters = options.capturePerformanceCounters ?? this.capturePerformanceCounters;\r\n            this.compileMaterials = options.compileMaterials ?? this.compileMaterials;\r\n            this.compileShadowGenerators = options.compileShadowGenerators ?? this.compileShadowGenerators;\r\n            this.coordinateSystemMode = options.coordinateSystemMode ?? this.coordinateSystemMode;\r\n            this.createInstances = options.createInstances ?? this.createInstances;\r\n            this.customRootNode = options.customRootNode;\r\n            this.extensionOptions = options.extensionOptions ?? this.extensionOptions;\r\n            this.loadAllMaterials = options.loadAllMaterials ?? this.loadAllMaterials;\r\n            this.loadMorphTargets = options.loadMorphTargets ?? this.loadMorphTargets;\r\n            this.loadNodeAnimations = options.loadNodeAnimations ?? this.loadNodeAnimations;\r\n            this.loadOnlyMaterials = options.loadOnlyMaterials ?? this.loadOnlyMaterials;\r\n            this.loadSkins = options.loadSkins ?? this.loadSkins;\r\n            this.loggingEnabled = options.loggingEnabled ?? this.loggingEnabled;\r\n            this.onCameraLoaded = options.onCameraLoaded;\r\n            this.onMaterialLoaded = options.onMaterialLoaded;\r\n            this.onMeshLoaded = options.onMeshLoaded;\r\n            this.onParsed = options.onParsed;\r\n            this.onSkinLoaded = options.onSkinLoaded;\r\n            this.onTextureLoaded = options.onTextureLoaded;\r\n            this.onValidated = options.onValidated;\r\n            this.preprocessUrlAsync = options.preprocessUrlAsync ?? this.preprocessUrlAsync;\r\n            this.skipMaterials = options.skipMaterials ?? this.skipMaterials;\r\n            this.targetFps = options.targetFps ?? this.targetFps;\r\n            this.transparencyAsCoverage = options.transparencyAsCoverage ?? this.transparencyAsCoverage;\r\n            this.useClipPlane = options.useClipPlane ?? this.useClipPlane;\r\n            this.useGltfTextureNames = options.useGltfTextureNames ?? this.useGltfTextureNames;\r\n            this.useOpenPBR = options.useOpenPBR ?? this.useOpenPBR;\r\n            this.useRangeRequests = options.useRangeRequests ?? this.useRangeRequests;\r\n            this.useSRGBBuffers = options.useSRGBBuffers ?? this.useSRGBBuffers;\r\n            this.validate = options.validate ?? this.validate;\r\n            this.dontUseTransmissionHelper = options.dontUseTransmissionHelper ?? this.dontUseTransmissionHelper;\r\n        }\r\n    }\r\n\r\n    // --------------\r\n    // Common options\r\n    // --------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public abstract onParsed?: ((loaderData: IGLTFLoaderData) => void) | undefined;\r\n\r\n    // ----------\r\n    // V2 options\r\n    // ----------\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public abstract capturePerformanceCounters: boolean;\r\n\r\n    /**\r\n     * Defines the node to use as the root of the hierarchy when loading the scene (default: undefined). If not defined, a root node will be automatically created.\r\n     * You can also pass null if you don't want a root node to be created.\r\n     */\r\n    public customRootNode?: Nullable<TransformNode>;\r\n\r\n    /**\r\n     * Defines options for glTF extensions.\r\n     */\r\n    public extensionOptions: {\r\n        // NOTE: This type is doing two things:\r\n        // 1. Adding an implicit 'enabled' property to the options for each extension.\r\n        // 2. Creating a mapped type of all the options of all the extensions to make it just look like a consolidated plain object in intellisense for the user.\r\n        [Extension in keyof GLTFLoaderExtensionOptions]?: {\r\n            [Option in keyof DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>]: DefaultExtensionOptions<GLTFLoaderExtensionOptions[Extension]>[Option];\r\n        };\r\n    } = {};\r\n\r\n    /**\r\n     * If true, enable logging for the loader. Defaults to false.\r\n     */\r\n    public abstract loggingEnabled: boolean;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public abstract onCameraLoaded?: (camera: Camera) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public abstract onMaterialLoaded?: (material: Material) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public abstract onMeshLoaded?: (mesh: AbstractMesh) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public abstract onSkinLoaded?: (node: TransformNode, skinnedNode: TransformNode) => void;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public abstract onTextureLoaded?: (texture: BaseTexture) => void;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public abstract onValidated?: (results: GLTF2.IGLTFValidationResults) => void;\r\n\r\n    /**\r\n     * Function called before loading a url referenced by the asset.\r\n     * @param url url referenced by the asset\r\n     * @returns Async url to load\r\n     */\r\n    public preprocessUrlAsync = (url: string) => Promise.resolve(url);\r\n}\r\n\r\n/**\r\n * File loader for loading glTF files into a scene.\r\n */\r\nexport class GLTFFileLoader extends GLTFLoaderOptions implements IDisposable, ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /** @internal */\r\n    public static _CreateGLTF1Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /** @internal */\r\n    public static _CreateGLTF2Loader: (parent: GLTFFileLoader) => IGLTFLoader;\r\n\r\n    /**\r\n     * Creates a new glTF file loader.\r\n     * @param options The options for the loader\r\n     */\r\n    public constructor(options?: Partial<Readonly<GLTFLoaderOptions>>) {\r\n        super();\r\n        this.copyFrom(Object.assign({ ...GLTFLoaderDefaultOptions }, options));\r\n    }\r\n\r\n    // --------------------\r\n    // Begin Common options\r\n    // --------------------\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public onParsedObservable = new Observable<IGLTFLoaderData>();\r\n\r\n    private _onParsedObserver: Nullable<Observer<IGLTFLoaderData>>;\r\n\r\n    /**\r\n     * Raised when the asset has been parsed\r\n     */\r\n    public set onParsed(callback: ((loaderData: IGLTFLoaderData) => void) | undefined) {\r\n        if (this._onParsedObserver) {\r\n            this.onParsedObservable.remove(this._onParsedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onParsedObserver = this.onParsedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    // ------------------\r\n    // End Common options\r\n    // ------------------\r\n\r\n    // ----------------\r\n    // Begin V1 options\r\n    // ----------------\r\n\r\n    /**\r\n     * Set this property to false to disable incremental loading which delays the loader from calling the success callback until after loading the meshes and shaders.\r\n     * Textures always loads asynchronously. For example, the success callback can compute the bounding information of the loaded meshes when incremental loading is disabled.\r\n     * Defaults to true.\r\n     * @internal\r\n     */\r\n    public static IncrementalLoading = true;\r\n\r\n    /**\r\n     * Set this property to true in order to work with homogeneous coordinates, available with some converters and exporters.\r\n     * Defaults to false. See https://en.wikipedia.org/wiki/Homogeneous_coordinates.\r\n     * @internal\r\n     */\r\n    public static HomogeneousCoordinates = false;\r\n\r\n    // --------------\r\n    // End V1 options\r\n    // --------------\r\n\r\n    /**\r\n     * Observable raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the observable is raised as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public readonly onMeshLoadedObservable = new Observable<AbstractMesh>();\r\n\r\n    private _onMeshLoadedObserver: Nullable<Observer<AbstractMesh>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a mesh after parsing the glTF properties of the mesh.\r\n     * Note that the callback is called as soon as the mesh object is created, meaning some data may not have been setup yet for this mesh (vertex data, morph targets, material, ...)\r\n     */\r\n    public set onMeshLoaded(callback: ((mesh: AbstractMesh) => void) | undefined) {\r\n        if (this._onMeshLoadedObserver) {\r\n            this.onMeshLoadedObservable.remove(this._onMeshLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMeshLoadedObserver = this.onMeshLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     * @param node - the transform node that corresponds to the original glTF skin node used for animations\r\n     * @param skinnedNode - the transform node that is the skinned mesh itself or the parent of the skinned meshes\r\n     */\r\n    public readonly onSkinLoadedObservable = new Observable<{ node: TransformNode; skinnedNode: TransformNode }>();\r\n\r\n    private _onSkinLoadedObserver: Nullable<Observer<{ node: TransformNode; skinnedNode: TransformNode }>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a skin after parsing the glTF properties of the skin node.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/importers/glTF/glTFSkinning#ignoring-the-transform-of-the-skinned-mesh\r\n     */\r\n    public set onSkinLoaded(callback: ((node: TransformNode, skinnedNode: TransformNode) => void) | undefined) {\r\n        if (this._onSkinLoadedObserver) {\r\n            this.onSkinLoadedObservable.remove(this._onSkinLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onSkinLoadedObserver = this.onSkinLoadedObservable.add((data) => callback(data.node, data.skinnedNode));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public readonly onTextureLoadedObservable = new Observable<BaseTexture>();\r\n\r\n    private _onTextureLoadedObserver: Nullable<Observer<BaseTexture>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a texture after parsing the glTF properties of the texture.\r\n     */\r\n    public set onTextureLoaded(callback: ((texture: BaseTexture) => void) | undefined) {\r\n        if (this._onTextureLoadedObserver) {\r\n            this.onTextureLoadedObservable.remove(this._onTextureLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onTextureLoadedObserver = this.onTextureLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public readonly onMaterialLoadedObservable = new Observable<Material>();\r\n\r\n    private _onMaterialLoadedObserver: Nullable<Observer<Material>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a material after parsing the glTF properties of the material.\r\n     */\r\n    public set onMaterialLoaded(callback: ((material: Material) => void) | undefined) {\r\n        if (this._onMaterialLoadedObserver) {\r\n            this.onMaterialLoadedObservable.remove(this._onMaterialLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onMaterialLoadedObserver = this.onMaterialLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public readonly onCameraLoadedObservable = new Observable<Camera>();\r\n\r\n    private _onCameraLoadedObserver: Nullable<Observer<Camera>>;\r\n\r\n    /**\r\n     * Callback raised when the loader creates a camera after parsing the glTF properties of the camera.\r\n     */\r\n    public set onCameraLoaded(callback: ((camera: Camera) => void) | undefined) {\r\n        if (this._onCameraLoadedObserver) {\r\n            this.onCameraLoadedObservable.remove(this._onCameraLoadedObserver);\r\n        }\r\n        if (callback) {\r\n            this._onCameraLoadedObserver = this.onCameraLoadedObservable.add(callback);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public readonly onCompleteObservable = new Observable<void>();\r\n\r\n    private _onCompleteObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised when the asset is completely loaded, immediately before the loader is disposed.\r\n     * For assets with LODs, raised when all of the LODs are complete.\r\n     * For assets without LODs, raised when the model is complete, immediately after the loader resolves the returned promise.\r\n     */\r\n    public set onComplete(callback: () => void) {\r\n        if (this._onCompleteObserver) {\r\n            this.onCompleteObservable.remove(this._onCompleteObserver);\r\n        }\r\n        this._onCompleteObserver = this.onCompleteObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised when an error occurs.\r\n     */\r\n    public readonly onErrorObservable = new Observable<any>();\r\n\r\n    private _onErrorObserver: Nullable<Observer<any>>;\r\n\r\n    /**\r\n     * Callback raised when an error occurs.\r\n     */\r\n    public set onError(callback: (reason: any) => void) {\r\n        if (this._onErrorObserver) {\r\n            this.onErrorObservable.remove(this._onErrorObserver);\r\n        }\r\n        this._onErrorObserver = this.onErrorObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after the loader is disposed.\r\n     */\r\n    public readonly onDisposeObservable = new Observable<void>();\r\n\r\n    private _onDisposeObserver: Nullable<Observer<void>>;\r\n\r\n    /**\r\n     * Callback raised after the loader is disposed.\r\n     */\r\n    public set onDispose(callback: () => void) {\r\n        if (this._onDisposeObserver) {\r\n            this.onDisposeObservable.remove(this._onDisposeObserver);\r\n        }\r\n        this._onDisposeObserver = this.onDisposeObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Observable raised after a loader extension is created.\r\n     * Set additional options for a loader extension in this event.\r\n     */\r\n    public readonly onExtensionLoadedObservable = new Observable<IGLTFLoaderExtension>();\r\n\r\n    private _onExtensionLoadedObserver: Nullable<Observer<IGLTFLoaderExtension>>;\r\n\r\n    /**\r\n     * Callback raised after a loader extension is created.\r\n     */\r\n    public set onExtensionLoaded(callback: (extension: IGLTFLoaderExtension) => void) {\r\n        if (this._onExtensionLoadedObserver) {\r\n            this.onExtensionLoadedObservable.remove(this._onExtensionLoadedObserver);\r\n        }\r\n        this._onExtensionLoadedObserver = this.onExtensionLoadedObservable.add(callback);\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader logging is enabled.\r\n     */\r\n    public get loggingEnabled(): boolean {\r\n        return this._loggingEnabled;\r\n    }\r\n\r\n    public set loggingEnabled(value: boolean) {\r\n        if (this._loggingEnabled === value) {\r\n            return;\r\n        }\r\n\r\n        this._loggingEnabled = value;\r\n\r\n        if (this._loggingEnabled) {\r\n            this._log = this._logEnabled;\r\n        } else {\r\n            this._log = this._logDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Defines if the loader should capture performance counters.\r\n     */\r\n    public get capturePerformanceCounters(): boolean {\r\n        return this._capturePerformanceCounters;\r\n    }\r\n\r\n    public set capturePerformanceCounters(value: boolean) {\r\n        if (this._capturePerformanceCounters === value) {\r\n            return;\r\n        }\r\n\r\n        this._capturePerformanceCounters = value;\r\n\r\n        if (this._capturePerformanceCounters) {\r\n            this._startPerformanceCounter = this._startPerformanceCounterEnabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterEnabled;\r\n        } else {\r\n            this._startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n            this._endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Observable raised after validation when validate is set to true. The event data is the result of the validation.\r\n     */\r\n    public readonly onValidatedObservable = new Observable<GLTF2.IGLTFValidationResults>();\r\n\r\n    private _onValidatedObserver: Nullable<Observer<GLTF2.IGLTFValidationResults>>;\r\n\r\n    /**\r\n     * Callback raised after the asset is validated.\r\n     */\r\n    public set onValidated(callback: (results: GLTF2.IGLTFValidationResults) => void) {\r\n        if (this._onValidatedObserver) {\r\n            this.onValidatedObservable.remove(this._onValidatedObserver);\r\n        }\r\n        this._onValidatedObserver = this.onValidatedObservable.add(callback);\r\n    }\r\n\r\n    private _loader: Nullable<IGLTFLoader> = null;\r\n    private _state: Nullable<GLTFLoaderState> = null;\r\n    private _progressCallback?: (event: ISceneLoaderProgressEvent) => void;\r\n    private _requests = new Array<IFileRequestInfo>();\r\n\r\n    /**\r\n     * Name of the loader (\"gltf\")\r\n     */\r\n    public readonly name = GLTFFileLoaderMetadata.name;\r\n\r\n    /** @internal */\r\n    public readonly extensions = GLTFFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Disposes the loader, releases resources during load, and cancels any outstanding requests.\r\n     */\r\n    public dispose(): void {\r\n        if (this._loader) {\r\n            this._loader.dispose();\r\n            this._loader = null;\r\n        }\r\n\r\n        for (const request of this._requests) {\r\n            request.abort();\r\n        }\r\n\r\n        this._requests.length = 0;\r\n\r\n        delete this._progressCallback;\r\n\r\n        this.preprocessUrlAsync = (url) => Promise.resolve(url);\r\n\r\n        this.onMeshLoadedObservable.clear();\r\n        this.onSkinLoadedObservable.clear();\r\n        this.onTextureLoadedObservable.clear();\r\n        this.onMaterialLoadedObservable.clear();\r\n        this.onCameraLoadedObservable.clear();\r\n        this.onCompleteObservable.clear();\r\n        this.onExtensionLoadedObservable.clear();\r\n\r\n        this.onDisposeObservable.notifyObservers(undefined);\r\n        this.onDisposeObservable.clear();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string | ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onProgress?: (ev: ISceneLoaderProgressEvent) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        name?: string\r\n    ): Nullable<IFileRequest> {\r\n        if (ArrayBuffer.isView(fileOrUrl)) {\r\n            this._loadBinary(scene, fileOrUrl, rootUrl, onSuccess, onError, name);\r\n            return null;\r\n        }\r\n\r\n        this._progressCallback = onProgress;\r\n\r\n        const fileName = (fileOrUrl as File).name || Tools.GetFilename(fileOrUrl as string);\r\n\r\n        if (useArrayBuffer) {\r\n            if (this.useRangeRequests) {\r\n                if (this.validate) {\r\n                    Logger.Warn(\"glTF validation is not supported when range requests are enabled\");\r\n                }\r\n\r\n                const fileRequest: IFileRequest = {\r\n                    abort: () => {},\r\n                    onCompleteObservable: new Observable<IFileRequest>(),\r\n                };\r\n\r\n                const dataBuffer = {\r\n                    readAsync: (byteOffset: number, byteLength: number) => {\r\n                        return new Promise<ArrayBufferView>((resolve, reject) => {\r\n                            this._loadFile(\r\n                                scene,\r\n                                fileOrUrl,\r\n                                (data) => {\r\n                                    resolve(new Uint8Array(data as ArrayBuffer));\r\n                                },\r\n                                true,\r\n                                (error) => {\r\n                                    reject(error);\r\n                                },\r\n                                (webRequest) => {\r\n                                    webRequest.setRequestHeader(\"Range\", `bytes=${byteOffset}-${byteOffset + byteLength - 1}`);\r\n                                }\r\n                            );\r\n                        });\r\n                    },\r\n                    byteLength: 0,\r\n                };\r\n\r\n                this._unpackBinaryAsync(new DataReader(dataBuffer)).then(\r\n                    (loaderData) => {\r\n                        fileRequest.onCompleteObservable.notifyObservers(fileRequest);\r\n                        onSuccess(loaderData);\r\n                    },\r\n                    onError ? (error) => onError(undefined, error) : undefined\r\n                );\r\n\r\n                return fileRequest;\r\n            }\r\n\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    this._validate(scene, new Uint8Array(data as ArrayBuffer, 0, (data as ArrayBuffer).byteLength), rootUrl, fileName);\r\n                    this._unpackBinaryAsync(\r\n                        new DataReader({\r\n                            readAsync: (byteOffset, byteLength) => readAsync(data as ArrayBuffer, byteOffset, byteLength),\r\n                            byteLength: (data as ArrayBuffer).byteLength,\r\n                        })\r\n                    ).then(\r\n                        (loaderData) => {\r\n                            onSuccess(loaderData);\r\n                        },\r\n                        onError ? (error) => onError(undefined, error) : undefined\r\n                    );\r\n                },\r\n                true,\r\n                onError\r\n            );\r\n        } else {\r\n            return this._loadFile(\r\n                scene,\r\n                fileOrUrl,\r\n                (data) => {\r\n                    try {\r\n                        this._validate(scene, data as string, rootUrl, fileName);\r\n                        onSuccess({ json: this._parseJson(data as string) });\r\n                    } catch {\r\n                        if (onError) {\r\n                            onError();\r\n                        }\r\n                    }\r\n                },\r\n                false,\r\n                onError\r\n            );\r\n        }\r\n    }\r\n\r\n    private _loadBinary(\r\n        scene: Scene,\r\n        data: ArrayBufferView,\r\n        rootUrl: string,\r\n        onSuccess: (data: unknown, responseURL?: string) => void,\r\n        onError?: (request?: WebRequest, exception?: LoadFileError) => void,\r\n        fileName?: string\r\n    ): void {\r\n        this._validate(scene, new Uint8Array(data.buffer, data.byteOffset, data.byteLength), rootUrl, fileName);\r\n        this._unpackBinaryAsync(\r\n            new DataReader({\r\n                readAsync: (byteOffset, byteLength) => readViewAsync(data, byteOffset, byteLength),\r\n                byteLength: data.byteLength,\r\n            })\r\n        ).then(\r\n            (loaderData) => {\r\n                onSuccess(loaderData);\r\n            },\r\n            onError ? (error) => onError(undefined, error) : undefined\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.importMeshAsync(meshesNames, scene, null, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName?: string): Promise<void> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n            return this._loader.loadAsync(scene, data, rootUrl, onProgress, fileName);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public loadAssetContainerAsync(\r\n        scene: Scene,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName?: string\r\n    ): Promise<AssetContainer> {\r\n        return Promise.resolve().then(() => {\r\n            this.onParsedObservable.notifyObservers(data);\r\n            this.onParsedObservable.clear();\r\n\r\n            this._log(`Loading ${fileName || \"\"}`);\r\n            this._loader = this._getLoader(data);\r\n\r\n            // Prepare the asset container.\r\n            const container = new AssetContainer(scene);\r\n\r\n            // Get materials/textures when loading to add to container\r\n            const materials: Array<Material> = [];\r\n            this.onMaterialLoadedObservable.add((material) => {\r\n                materials.push(material);\r\n            });\r\n            const textures: Array<BaseTexture> = [];\r\n            this.onTextureLoadedObservable.add((texture) => {\r\n                textures.push(texture);\r\n            });\r\n            const cameras: Array<Camera> = [];\r\n            this.onCameraLoadedObservable.add((camera) => {\r\n                cameras.push(camera);\r\n            });\r\n\r\n            const morphTargetManagers: Array<MorphTargetManager> = [];\r\n            this.onMeshLoadedObservable.add((mesh) => {\r\n                if (mesh.morphTargetManager) {\r\n                    morphTargetManagers.push(mesh.morphTargetManager);\r\n                }\r\n            });\r\n\r\n            return this._loader.importMeshAsync(null, scene, container, data, rootUrl, onProgress, fileName).then((result) => {\r\n                Array.prototype.push.apply(container.geometries, result.geometries);\r\n                Array.prototype.push.apply(container.meshes, result.meshes);\r\n                Array.prototype.push.apply(container.particleSystems, result.particleSystems);\r\n                Array.prototype.push.apply(container.skeletons, result.skeletons);\r\n                Array.prototype.push.apply(container.animationGroups, result.animationGroups);\r\n                Array.prototype.push.apply(container.materials, materials);\r\n                Array.prototype.push.apply(container.textures, textures);\r\n                Array.prototype.push.apply(container.lights, result.lights);\r\n                Array.prototype.push.apply(container.transformNodes, result.transformNodes);\r\n                Array.prototype.push.apply(container.cameras, cameras);\r\n                Array.prototype.push.apply(container.morphTargetManagers, morphTargetManagers);\r\n                return container;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public canDirectLoad(data: string): boolean {\r\n        return GLTFFileLoaderMetadata.canDirectLoad(data);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public directLoad(scene: Scene, data: string): Promise<object> {\r\n        if (\r\n            data.startsWith(\"base64,\" + GLTFMagicBase64Encoded) || // this is technically incorrect, but will continue to support for backcompat.\r\n            data.startsWith(\";base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"application/octet-stream;base64,\" + GLTFMagicBase64Encoded) ||\r\n            data.startsWith(\"model/gltf-binary;base64,\" + GLTFMagicBase64Encoded)\r\n        ) {\r\n            const arrayBuffer = DecodeBase64UrlToBinary(data);\r\n\r\n            this._validate(scene, new Uint8Array(arrayBuffer, 0, arrayBuffer.byteLength));\r\n            return this._unpackBinaryAsync(\r\n                new DataReader({\r\n                    readAsync: (byteOffset, byteLength) => readAsync(arrayBuffer, byteOffset, byteLength),\r\n                    byteLength: arrayBuffer.byteLength,\r\n                })\r\n            );\r\n        }\r\n\r\n        this._validate(scene, data);\r\n        return Promise.resolve({ json: this._parseJson(data) });\r\n    }\r\n\r\n    /**\r\n     * The callback that allows custom handling of the root url based on the response url.\r\n     * @param rootUrl the original root url\r\n     * @param responseURL the response url if available\r\n     * @returns the new root url\r\n     */\r\n    public rewriteRootURL?(rootUrl: string, responseURL?: string): string;\r\n\r\n    /** @internal */\r\n    public createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new GLTFFileLoader(options[GLTFFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * The loader state or null if the loader is not active.\r\n     */\r\n    public get loaderState(): Nullable<GLTFLoaderState> {\r\n        return this._state;\r\n    }\r\n\r\n    /**\r\n     * Observable raised when the loader state changes.\r\n     */\r\n    public onLoaderStateChangedObservable = new Observable<Nullable<GLTFLoaderState>>();\r\n\r\n    /**\r\n     * Returns a promise that resolves when the asset is completely loaded.\r\n     * @returns a promise that resolves when the asset is completely loaded.\r\n     */\r\n    public whenCompleteAsync(): Promise<void> {\r\n        return new Promise((resolve, reject) => {\r\n            this.onCompleteObservable.addOnce(() => {\r\n                resolve();\r\n            });\r\n            this.onErrorObservable.addOnce((reason) => {\r\n                reject(reason);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _setState(state: GLTFLoaderState): void {\r\n        if (this._state === state) {\r\n            return;\r\n        }\r\n\r\n        this._state = state;\r\n        this.onLoaderStateChangedObservable.notifyObservers(this._state);\r\n        this._log(GLTFLoaderState[this._state]);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFile(\r\n        scene: Scene,\r\n        fileOrUrl: File | string,\r\n        onSuccess: (data: string | ArrayBuffer) => void,\r\n        useArrayBuffer?: boolean,\r\n        onError?: (request?: WebRequest) => void,\r\n        onOpened?: (request: WebRequest) => void\r\n    ): IFileRequest {\r\n        const request = scene._loadFile(\r\n            fileOrUrl,\r\n            onSuccess,\r\n            (event) => {\r\n                this._onProgress(event, request);\r\n            },\r\n            true,\r\n            useArrayBuffer,\r\n            onError,\r\n            onOpened\r\n        ) as IFileRequestInfo;\r\n        request.onCompleteObservable.add(() => {\r\n            // Force the length computable to be true since we can guarantee the data is loaded.\r\n            request._lengthComputable = true;\r\n            request._total = request._loaded;\r\n        });\r\n        this._requests.push(request);\r\n        return request;\r\n    }\r\n\r\n    private _onProgress(event: ProgressEvent, request: IFileRequestInfo): void {\r\n        if (!this._progressCallback) {\r\n            return;\r\n        }\r\n\r\n        request._lengthComputable = event.lengthComputable;\r\n        request._loaded = event.loaded;\r\n        request._total = event.total;\r\n\r\n        let lengthComputable = true;\r\n        let loaded = 0;\r\n        let total = 0;\r\n        for (const request of this._requests) {\r\n            if (request._lengthComputable === undefined || request._loaded === undefined || request._total === undefined) {\r\n                return;\r\n            }\r\n\r\n            lengthComputable = lengthComputable && request._lengthComputable;\r\n            loaded += request._loaded;\r\n            total += request._total;\r\n        }\r\n\r\n        this._progressCallback({\r\n            lengthComputable: lengthComputable,\r\n            loaded: loaded,\r\n            total: lengthComputable ? total : 0,\r\n        });\r\n    }\r\n\r\n    private _validate(scene: Scene, data: string | Uint8Array, rootUrl = \"\", fileName = \"\"): void {\r\n        if (!this.validate) {\r\n            return;\r\n        }\r\n\r\n        this._startPerformanceCounter(\"Validate JSON\");\r\n        GLTFValidation.ValidateAsync(data, rootUrl, fileName, (uri) => {\r\n            return this.preprocessUrlAsync(rootUrl + uri).then((url) => {\r\n                return scene._loadFileAsync(url, undefined, true, true).then((data) => {\r\n                    return new Uint8Array(data, 0, data.byteLength);\r\n                });\r\n            });\r\n        }).then(\r\n            (result) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                this.onValidatedObservable.notifyObservers(result);\r\n                this.onValidatedObservable.clear();\r\n            },\r\n            (reason) => {\r\n                this._endPerformanceCounter(\"Validate JSON\");\r\n                Tools.Warn(`Failed to validate: ${reason.message}`);\r\n                this.onValidatedObservable.clear();\r\n            }\r\n        );\r\n    }\r\n\r\n    private _getLoader(loaderData: IGLTFLoaderData): IGLTFLoader {\r\n        const asset = (<any>loaderData.json).asset || {};\r\n\r\n        this._log(`Asset version: ${asset.version}`);\r\n        asset.minVersion && this._log(`Asset minimum version: ${asset.minVersion}`);\r\n        asset.generator && this._log(`Asset generator: ${asset.generator}`);\r\n\r\n        const version = GLTFFileLoader._parseVersion(asset.version);\r\n        if (!version) {\r\n            throw new Error(\"Invalid version: \" + asset.version);\r\n        }\r\n\r\n        if (asset.minVersion !== undefined) {\r\n            const minVersion = GLTFFileLoader._parseVersion(asset.minVersion);\r\n            if (!minVersion) {\r\n                throw new Error(\"Invalid minimum version: \" + asset.minVersion);\r\n            }\r\n\r\n            if (GLTFFileLoader._compareVersion(minVersion, { major: 2, minor: 0 }) > 0) {\r\n                throw new Error(\"Incompatible minimum version: \" + asset.minVersion);\r\n            }\r\n        }\r\n\r\n        const createLoaders: { [key: number]: (parent: GLTFFileLoader) => IGLTFLoader } = {\r\n            1: GLTFFileLoader._CreateGLTF1Loader,\r\n            2: GLTFFileLoader._CreateGLTF2Loader,\r\n        };\r\n\r\n        const createLoader = createLoaders[version.major];\r\n        if (!createLoader) {\r\n            throw new Error(\"Unsupported version: \" + asset.version);\r\n        }\r\n\r\n        return createLoader(this);\r\n    }\r\n\r\n    private _parseJson(json: string): object {\r\n        this._startPerformanceCounter(\"Parse JSON\");\r\n        this._log(`JSON length: ${json.length}`);\r\n        const parsed = JSON.parse(json);\r\n        this._endPerformanceCounter(\"Parse JSON\");\r\n        return parsed;\r\n    }\r\n\r\n    private _unpackBinaryAsync(dataReader: DataReader): Promise<IGLTFLoaderData> {\r\n        this._startPerformanceCounter(\"Unpack Binary\");\r\n\r\n        // Read magic + version + length + json length + json format\r\n        return dataReader.loadAsync(20).then(() => {\r\n            const Binary = {\r\n                Magic: 0x46546c67,\r\n            };\r\n\r\n            const magic = dataReader.readUint32();\r\n            if (magic !== Binary.Magic) {\r\n                throw new RuntimeError(\"Unexpected magic: \" + magic, ErrorCodes.GLTFLoaderUnexpectedMagicError);\r\n            }\r\n\r\n            const version = dataReader.readUint32();\r\n\r\n            if (this.loggingEnabled) {\r\n                this._log(`Binary version: ${version}`);\r\n            }\r\n\r\n            const length = dataReader.readUint32();\r\n            if (!this.useRangeRequests && length !== dataReader.buffer.byteLength) {\r\n                Logger.Warn(`Length in header does not match actual data length: ${length} != ${dataReader.buffer.byteLength}`);\r\n            }\r\n\r\n            let unpacked: Promise<IGLTFLoaderData>;\r\n            switch (version) {\r\n                case 1: {\r\n                    unpacked = this._unpackBinaryV1Async(dataReader, length);\r\n                    break;\r\n                }\r\n                case 2: {\r\n                    unpacked = this._unpackBinaryV2Async(dataReader, length);\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(\"Unsupported version: \" + version);\r\n                }\r\n            }\r\n\r\n            this._endPerformanceCounter(\"Unpack Binary\");\r\n\r\n            return unpacked;\r\n        });\r\n    }\r\n\r\n    private _unpackBinaryV1Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ContentFormat = {\r\n            JSON: 0,\r\n        };\r\n\r\n        const contentLength = dataReader.readUint32();\r\n        const contentFormat = dataReader.readUint32();\r\n\r\n        if (contentFormat !== ContentFormat.JSON) {\r\n            throw new Error(`Unexpected content format: ${contentFormat}`);\r\n        }\r\n\r\n        const bodyLength = length - dataReader.byteOffset;\r\n\r\n        const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(contentLength)), bin: null };\r\n        if (bodyLength !== 0) {\r\n            const startByteOffset = dataReader.byteOffset;\r\n            data.bin = {\r\n                readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                byteLength: bodyLength,\r\n            };\r\n        }\r\n\r\n        return Promise.resolve(data);\r\n    }\r\n\r\n    private _unpackBinaryV2Async(dataReader: DataReader, length: number): Promise<IGLTFLoaderData> {\r\n        const ChunkFormat = {\r\n            JSON: 0x4e4f534a,\r\n            BIN: 0x004e4942,\r\n        };\r\n\r\n        // Read the JSON chunk header.\r\n        const chunkLength = dataReader.readUint32();\r\n        const chunkFormat = dataReader.readUint32();\r\n        if (chunkFormat !== ChunkFormat.JSON) {\r\n            throw new Error(\"First chunk format is not JSON\");\r\n        }\r\n\r\n        // Bail if there are no other chunks.\r\n        if (dataReader.byteOffset + chunkLength === length) {\r\n            return dataReader.loadAsync(chunkLength).then(() => {\r\n                return { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n            });\r\n        }\r\n\r\n        // Read the JSON chunk and the length and type of the next chunk.\r\n        return dataReader.loadAsync(chunkLength + 8).then(() => {\r\n            const data: IGLTFLoaderData = { json: this._parseJson(dataReader.readString(chunkLength)), bin: null };\r\n\r\n            const readAsync = (): Promise<IGLTFLoaderData> => {\r\n                const chunkLength = dataReader.readUint32();\r\n                const chunkFormat = dataReader.readUint32();\r\n\r\n                switch (chunkFormat) {\r\n                    case ChunkFormat.JSON: {\r\n                        throw new Error(\"Unexpected JSON chunk\");\r\n                    }\r\n                    case ChunkFormat.BIN: {\r\n                        const startByteOffset = dataReader.byteOffset;\r\n                        data.bin = {\r\n                            readAsync: (byteOffset, byteLength) => dataReader.buffer.readAsync(startByteOffset + byteOffset, byteLength),\r\n                            byteLength: chunkLength,\r\n                        };\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // ignore unrecognized chunkFormat\r\n                        dataReader.skipBytes(chunkLength);\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (dataReader.byteOffset !== length) {\r\n                    return dataReader.loadAsync(8).then(readAsync);\r\n                }\r\n\r\n                return Promise.resolve(data);\r\n            };\r\n\r\n            return readAsync();\r\n        });\r\n    }\r\n\r\n    private static _parseVersion(version: string): Nullable<{ major: number; minor: number }> {\r\n        if (version === \"1.0\" || version === \"1.0.1\") {\r\n            return {\r\n                major: 1,\r\n                minor: 0,\r\n            };\r\n        }\r\n\r\n        const match = (version + \"\").match(/^(\\d+)\\.(\\d+)/);\r\n        if (!match) {\r\n            return null;\r\n        }\r\n\r\n        return {\r\n            major: parseInt(match[1]),\r\n            minor: parseInt(match[2]),\r\n        };\r\n    }\r\n\r\n    private static _compareVersion(a: { major: number; minor: number }, b: { major: number; minor: number }): number {\r\n        if (a.major > b.major) {\r\n            return 1;\r\n        }\r\n        if (a.major < b.major) {\r\n            return -1;\r\n        }\r\n        if (a.minor > b.minor) {\r\n            return 1;\r\n        }\r\n        if (a.minor < b.minor) {\r\n            return -1;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    private static readonly _logSpaces = \"                                \";\r\n    private _logIndentLevel = 0;\r\n    private _loggingEnabled = false;\r\n\r\n    /** @internal */\r\n    public _log = this._logDisabled;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _logOpen(message: string): void {\r\n        this._log(message);\r\n        this._logIndentLevel++;\r\n    }\r\n\r\n    /** @internal */\r\n    public _logClose(): void {\r\n        --this._logIndentLevel;\r\n    }\r\n\r\n    private _logEnabled(message: string): void {\r\n        const spaces = GLTFFileLoader._logSpaces.substring(0, this._logIndentLevel * 2);\r\n        Logger.Log(`${spaces}${message}`);\r\n    }\r\n\r\n    private _logDisabled(message: string): void {}\r\n\r\n    private _capturePerformanceCounters = false;\r\n\r\n    /** @internal */\r\n    public _startPerformanceCounter = this._startPerformanceCounterDisabled;\r\n\r\n    /** @internal */\r\n    public _endPerformanceCounter = this._endPerformanceCounterDisabled;\r\n\r\n    private _startPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.StartPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _startPerformanceCounterDisabled(counterName: string): void {}\r\n\r\n    private _endPerformanceCounterEnabled(counterName: string): void {\r\n        Tools.EndPerformanceCounter(counterName);\r\n    }\r\n\r\n    private _endPerformanceCounterDisabled(counterName: string): void {}\r\n}\r\n\r\nRegisterSceneLoaderPlugin(new GLTFFileLoader());\r\n","/**\r\n * A class that lazily initializes a value given a factory function.\r\n */\r\nexport class Lazy<T> {\r\n    private _factory: (() => T) | undefined;\r\n    private _value: T | undefined;\r\n\r\n    /**\r\n     * Creates a new instance of the Lazy class.\r\n     * @param factory A function that creates the value.\r\n     */\r\n    constructor(factory: () => T) {\r\n        this._factory = factory;\r\n    }\r\n\r\n    /**\r\n     * Gets the lazily initialized value.\r\n     */\r\n    public get value(): T {\r\n        // If the factory function is still defined, it means we haven't called it yet.\r\n        if (this._factory) {\r\n            this._value = this._factory();\r\n            // Set the factory function to undefined to allow it to be garbage collected.\r\n            this._factory = undefined;\r\n        }\r\n        return this._value as T;\r\n    }\r\n}\r\n","/* eslint-disable @typescript-eslint/promise-function-async */\r\n/* eslint-disable no-restricted-syntax */\r\n/* eslint-disable github/no-then */\r\nimport type { IndicesArray, Nullable, TypedArray, TypedArrayConstructor } from \"core/types\";\r\nimport { Deferred } from \"core/Misc/deferred\";\r\nimport { Quaternion, Vector3, Matrix, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { FreeCamera } from \"core/Cameras/freeCamera\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { IAnimatable } from \"core/Animations/animatable.interface\";\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { Bone } from \"core/Bones/bone\";\r\nimport { Skeleton } from \"core/Bones/skeleton\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { ITextureCreationOptions } from \"core/Materials/Textures/texture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { Buffer, VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Geometry } from \"core/Meshes/geometry\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { MorphTargetManager } from \"core/Morph/morphTargetManager\";\r\nimport type { ISceneLoaderAsyncResult, ISceneLoaderProgressEvent } from \"core/Loading/sceneLoader\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { IProperty } from \"babylonjs-gltf2interface\";\r\nimport {\r\n    AnimationChannelTargetPath,\r\n    AnimationSamplerInterpolation,\r\n    AccessorType,\r\n    CameraType,\r\n    AccessorComponentType,\r\n    MaterialAlphaMode,\r\n    TextureMinFilter,\r\n    TextureWrapMode,\r\n    TextureMagFilter,\r\n    MeshPrimitiveMode,\r\n} from \"babylonjs-gltf2interface\";\r\nimport type {\r\n    IGLTF,\r\n    ISampler,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IAccessor,\r\n    ISkin,\r\n    ICamera,\r\n    IAnimation,\r\n    IBuffer,\r\n    IBufferView,\r\n    IMaterialPbrMetallicRoughness,\r\n    IMaterial,\r\n    ITextureInfo,\r\n    ITexture,\r\n    IImage,\r\n    IMeshPrimitive,\r\n    IArrayItem,\r\n    _ISamplerData,\r\n    IAnimationChannel,\r\n    IAnimationSampler,\r\n    _IAnimationSamplerData,\r\n} from \"./glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"./glTFLoaderExtension\";\r\nimport type { IGLTFLoader, IGLTFLoaderData } from \"../glTFFileLoader\";\r\nimport { GLTFFileLoader, GLTFLoaderState, GLTFLoaderCoordinateSystemMode, GLTFLoaderAnimationStartMode } from \"../glTFFileLoader\";\r\nimport type { IDataBuffer } from \"core/Misc/dataReader\";\r\nimport { DecodeBase64UrlToBinary, GetMimeType, IsBase64DataUrl, LoadFileError } from \"core/Misc/fileTools\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Light } from \"core/Lights/light\";\r\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\r\nimport type { AssetContainer } from \"core/assetContainer\";\r\nimport type { AnimationPropertyInfo } from \"./glTFLoaderAnimation\";\r\nimport type { IObjectInfo } from \"core/ObjectModel/objectModelInterfaces\";\r\nimport { registeredGLTFExtensions, registerGLTFExtension, unregisterGLTFExtension } from \"./glTFLoaderExtensionRegistry\";\r\nimport type { GLTFExtensionFactory } from \"./glTFLoaderExtensionRegistry\";\r\nimport type { IInterpolationPropertyInfo } from \"core/FlowGraph/typeDefinitions\";\r\nimport { GetMappingForKey } from \"./Extensions/objectModelMapping\";\r\nimport { deepMerge } from \"core/Misc/deepMerger\";\r\nimport { GetTypedArrayConstructor } from \"core/Buffers/bufferUtils\";\r\nimport { Lazy } from \"core/Misc/lazy\";\r\nimport type { IMaterialLoadingAdapter } from \"./materialLoadingAdapter\";\r\n\r\n// Caching these dynamic imports gives a surprising perf boost (compared to importing them directly each time).\r\nconst LazyAnimationGroupModulePromise = new Lazy(() => import(\"core/Animations/animationGroup\"));\r\nconst LazyLoaderAnimationModulePromise = new Lazy(() => import(\"./glTFLoaderAnimation\"));\r\n\r\nexport { GLTFFileLoader };\r\n\r\ninterface ILoaderProperty extends IProperty {\r\n    _activeLoaderExtensionFunctions: {\r\n        [id: string]: boolean;\r\n    };\r\n}\r\n\r\ninterface IWithMetadata {\r\n    metadata: any;\r\n    _internalMetadata: any;\r\n}\r\n\r\n/**\r\n * Helper class for working with arrays when loading the glTF asset\r\n */\r\nexport class ArrayItem {\r\n    /**\r\n     * Gets an item from the given array.\r\n     * @param context The context when loading the asset\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item\r\n     */\r\n    public static Get<T>(context: string, array: ArrayLike<T> | undefined, index: number | undefined): T {\r\n        if (!array || index == undefined || !array[index]) {\r\n            throw new Error(`${context}: Failed to find index (${index})`);\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Gets an item from the given array or returns null if not available.\r\n     * @param array The array to get the item from\r\n     * @param index The index to the array\r\n     * @returns The array item or null\r\n     */\r\n    public static TryGet<T>(array: ArrayLike<T> | undefined, index: number | undefined): Nullable<T> {\r\n        if (!array || index == undefined || !array[index]) {\r\n            return null;\r\n        }\r\n\r\n        return array[index];\r\n    }\r\n\r\n    /**\r\n     * Assign an `index` field to each item of the given array.\r\n     * @param array The array of items\r\n     */\r\n    public static Assign(array?: IArrayItem[]): void {\r\n        if (array) {\r\n            for (let index = 0; index < array.length; index++) {\r\n                array[index].index = index;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport interface IAnimationTargetInfo {\r\n    /** @internal */\r\n    target: unknown;\r\n\r\n    /** @internal */\r\n    properties: Array<AnimationPropertyInfo>;\r\n}\r\n\r\n/** @internal */\r\nexport function LoadBoundingInfoFromPositionAccessor(accessor: IAccessor): Nullable<BoundingInfo> {\r\n    if (accessor.min && accessor.max) {\r\n        const minArray = accessor.min as [number, number, number];\r\n        const maxArray = accessor.max as [number, number, number];\r\n        const minVector = TmpVectors.Vector3[0].copyFromFloats(minArray[0], minArray[1], minArray[2]);\r\n        const maxVector = TmpVectors.Vector3[1].copyFromFloats(maxArray[0], maxArray[1], maxArray[2]);\r\n        if (accessor.normalized && accessor.componentType !== AccessorComponentType.FLOAT) {\r\n            let divider = 1;\r\n            switch (accessor.componentType) {\r\n                case AccessorComponentType.BYTE:\r\n                    divider = 127.0;\r\n                    break;\r\n                case AccessorComponentType.UNSIGNED_BYTE:\r\n                    divider = 255.0;\r\n                    break;\r\n                case AccessorComponentType.SHORT:\r\n                    divider = 32767.0;\r\n                    break;\r\n                case AccessorComponentType.UNSIGNED_SHORT:\r\n                    divider = 65535.0;\r\n                    break;\r\n            }\r\n            const oneOverDivider = 1 / divider;\r\n            minVector.scaleInPlace(oneOverDivider);\r\n            maxVector.scaleInPlace(oneOverDivider);\r\n        }\r\n        return new BoundingInfo(minVector, maxVector);\r\n    }\r\n    return null;\r\n}\r\n\r\ntype PBRMaterialImplementation = {\r\n    materialClass: typeof Material;\r\n    adapterClass: new (material: Material) => IMaterialLoadingAdapter;\r\n};\r\n\r\n/**\r\n * The glTF 2.0 loader\r\n */\r\nexport class GLTFLoader implements IGLTFLoader {\r\n    /** @internal */\r\n    public readonly _completePromises = new Array<Promise<unknown>>();\r\n\r\n    /** @internal */\r\n    public _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    /** Storage */\r\n    public _babylonLights: Light[] = [];\r\n\r\n    /** @internal */\r\n    public _disableInstancedMesh = 0;\r\n\r\n    /** @internal */\r\n    public _allMaterialsDirtyRequired = false;\r\n\r\n    /** @internal */\r\n    public _skipStartAnimationStep = false;\r\n\r\n    private readonly _parent: GLTFFileLoader;\r\n    private readonly _extensions = new Array<IGLTFLoaderExtension>();\r\n    private _disposed = false;\r\n    private _rootUrl: Nullable<string> = null;\r\n    private _fileName: Nullable<string> = null;\r\n    private _uniqueRootUrl: Nullable<string> = null;\r\n    private _gltf: IGLTF;\r\n    private _bin: Nullable<IDataBuffer> = null;\r\n    private _babylonScene: Scene;\r\n    private _rootBabylonMesh: Nullable<TransformNode> = null;\r\n    private _defaultBabylonMaterialData: { [drawMode: number]: Material } = {};\r\n    private readonly _postSceneLoadActions = new Array<() => void>();\r\n    private readonly _materialAdapterCache = new WeakMap<Material, IMaterialLoadingAdapter>();\r\n\r\n    /** @internal */\r\n    public _pbrMaterialImpl: Nullable<Readonly<PBRMaterialImplementation>> | false = null;\r\n\r\n    /**\r\n     * The default glTF sampler.\r\n     */\r\n    public static readonly DefaultSampler: ISampler = { index: -1 };\r\n\r\n    /**\r\n     * Registers a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @param factory The factory function that creates the loader extension.\r\n     * @deprecated Please use registerGLTFExtension instead.\r\n     */\r\n    public static RegisterExtension(name: string, factory: GLTFExtensionFactory): void {\r\n        registerGLTFExtension(name, false, factory);\r\n    }\r\n\r\n    /**\r\n     * Unregisters a loader extension.\r\n     * @param name The name of the loader extension.\r\n     * @returns A boolean indicating whether the extension has been unregistered\r\n     * @deprecated Please use unregisterGLTFExtension instead.\r\n     */\r\n    public static UnregisterExtension(name: string): boolean {\r\n        return unregisterGLTFExtension(name);\r\n    }\r\n\r\n    /**\r\n     * The object that represents the glTF JSON.\r\n     */\r\n    public get gltf(): IGLTF {\r\n        if (!this._gltf) {\r\n            throw new Error(\"glTF JSON is not available\");\r\n        }\r\n\r\n        return this._gltf;\r\n    }\r\n\r\n    /**\r\n     * The BIN chunk of a binary glTF.\r\n     */\r\n    public get bin(): Nullable<IDataBuffer> {\r\n        return this._bin;\r\n    }\r\n\r\n    /**\r\n     * The parent file loader.\r\n     */\r\n    public get parent(): GLTFFileLoader {\r\n        return this._parent;\r\n    }\r\n\r\n    /**\r\n     * The Babylon scene when loading the asset.\r\n     */\r\n    public get babylonScene(): Scene {\r\n        if (!this._babylonScene) {\r\n            throw new Error(\"Scene is not available\");\r\n        }\r\n\r\n        return this._babylonScene;\r\n    }\r\n\r\n    /**\r\n     * The root Babylon node when loading the asset.\r\n     */\r\n    public get rootBabylonMesh(): Nullable<TransformNode> {\r\n        return this._rootBabylonMesh;\r\n    }\r\n\r\n    /**\r\n     * The root url when loading the asset.\r\n     */\r\n    public get rootUrl(): Nullable<string> {\r\n        return this._rootUrl;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(parent: GLTFFileLoader) {\r\n        this._parent = parent;\r\n    }\r\n\r\n    /**\r\n     * Creates or gets a cached material loading adapter with dynamic imports\r\n     * @param material The material to adapt\r\n     * @returns Promise that resolves to the appropriate adapter\r\n     * @internal\r\n     */\r\n    public _getOrCreateMaterialAdapter(material: Material): IMaterialLoadingAdapter {\r\n        let adapter = this._materialAdapterCache.get(material);\r\n        if (!adapter) {\r\n            if (this._pbrMaterialImpl) {\r\n                adapter = new this._pbrMaterialImpl.adapterClass(material);\r\n            } else {\r\n                throw new Error(`Appropriate material adapter class not found`);\r\n            }\r\n            this._materialAdapterCache.set(material, adapter);\r\n        }\r\n        return adapter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose(): void {\r\n        if (this._disposed) {\r\n            return;\r\n        }\r\n\r\n        this._disposed = true;\r\n\r\n        this._completePromises.length = 0;\r\n\r\n        this._extensions.forEach((extension) => extension.dispose && extension.dispose());\r\n        this._extensions.length = 0;\r\n\r\n        (this._gltf as Nullable<IGLTF>) = null; // TODO\r\n        this._bin = null;\r\n        (this._babylonScene as Nullable<Scene>) = null; // TODO\r\n        this._rootBabylonMesh = null;\r\n        this._defaultBabylonMaterialData = {};\r\n        this._postSceneLoadActions.length = 0;\r\n\r\n        this._parent.dispose();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: string | readonly string[] | null | undefined,\r\n        scene: Scene,\r\n        container: Nullable<AssetContainer>,\r\n        data: IGLTFLoaderData,\r\n        rootUrl: string,\r\n        onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        fileName = \"\"\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        // eslint-disable-next-line github/no-then\r\n        return await Promise.resolve().then(async () => {\r\n            this._babylonScene = scene;\r\n            this._assetContainer = container;\r\n            this._loadData(data);\r\n\r\n            let nodes: Nullable<Array<number>> = null;\r\n\r\n            if (meshesNames) {\r\n                const nodeMap: { [name: string]: number } = {};\r\n                if (this._gltf.nodes) {\r\n                    for (const node of this._gltf.nodes) {\r\n                        if (node.name) {\r\n                            nodeMap[node.name] = node.index;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                const names = meshesNames instanceof Array ? meshesNames : [meshesNames];\r\n                nodes = names.map((name) => {\r\n                    const node = nodeMap[name];\r\n                    if (node === undefined) {\r\n                        throw new Error(`Failed to find node '${name}'`);\r\n                    }\r\n\r\n                    return node;\r\n                });\r\n            }\r\n\r\n            return await this._loadAsync(rootUrl, fileName, nodes, () => {\r\n                return {\r\n                    meshes: this._getMeshes(),\r\n                    particleSystems: [],\r\n                    skeletons: this._getSkeletons(),\r\n                    animationGroups: this._getAnimationGroups(),\r\n                    lights: this._babylonLights,\r\n                    transformNodes: this._getTransformNodes(),\r\n                    geometries: this._getGeometries(),\r\n                    spriteManagers: [],\r\n                };\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public async loadAsync(scene: Scene, data: IGLTFLoaderData, rootUrl: string, onProgress?: (event: ISceneLoaderProgressEvent) => void, fileName = \"\"): Promise<void> {\r\n        this._babylonScene = scene;\r\n        this._loadData(data);\r\n        return await this._loadAsync(rootUrl, fileName, null, () => undefined);\r\n    }\r\n\r\n    private async _loadAsync<T>(rootUrl: string, fileName: string, nodes: Nullable<Array<number>>, resultFunc: () => T): Promise<T> {\r\n        return await Promise.resolve()\r\n            .then(async () => {\r\n                this._rootUrl = rootUrl;\r\n                this._uniqueRootUrl = !rootUrl.startsWith(\"file:\") && fileName ? rootUrl : `${rootUrl}${Date.now()}/`;\r\n                this._fileName = fileName;\r\n                this._allMaterialsDirtyRequired = false;\r\n\r\n                await this._loadExtensionsAsync();\r\n\r\n                // NOTE: Explicitly check _pbrMaterialImpl for null as a value of false means don't use PBR materials at all.\r\n                if (!this.parent.skipMaterials && this._pbrMaterialImpl == null) {\r\n                    if (this.parent.useOpenPBR || this.isExtensionUsed(\"KHR_materials_openpbr\")) {\r\n                        this._pbrMaterialImpl = {\r\n                            materialClass: (await import(\"core/Materials/PBR/openpbrMaterial\")).OpenPBRMaterial,\r\n                            adapterClass: (await import(\"./openpbrMaterialLoadingAdapter\")).OpenPBRMaterialLoadingAdapter,\r\n                        };\r\n                    } else {\r\n                        this._pbrMaterialImpl = {\r\n                            materialClass: (await import(\"core/Materials/PBR/pbrMaterial\")).PBRMaterial,\r\n                            adapterClass: (await import(\"./pbrMaterialLoadingAdapter\")).PBRMaterialLoadingAdapter,\r\n                        };\r\n                    }\r\n                }\r\n\r\n                const loadingToReadyCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.READY]}`;\r\n                const loadingToCompleteCounterName = `${GLTFLoaderState[GLTFLoaderState.LOADING]} => ${GLTFLoaderState[GLTFLoaderState.COMPLETE]}`;\r\n\r\n                this._parent._startPerformanceCounter(loadingToReadyCounterName);\r\n                this._parent._startPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                this._parent._setState(GLTFLoaderState.LOADING);\r\n                this._extensionsOnLoading();\r\n\r\n                const promises = new Array<Promise<unknown>>();\r\n\r\n                // Block the marking of materials dirty until the scene is loaded.\r\n                const oldBlockMaterialDirtyMechanism = this._babylonScene.blockMaterialDirtyMechanism;\r\n                this._babylonScene.blockMaterialDirtyMechanism = true;\r\n\r\n                if (!this.parent.loadOnlyMaterials) {\r\n                    if (nodes) {\r\n                        promises.push(this.loadSceneAsync(\"/nodes\", { nodes: nodes, index: -1 }));\r\n                    } else if (this._gltf.scene != undefined || (this._gltf.scenes && this._gltf.scenes[0])) {\r\n                        const scene = ArrayItem.Get(`/scene`, this._gltf.scenes, this._gltf.scene || 0);\r\n                        promises.push(this.loadSceneAsync(`/scenes/${scene.index}`, scene));\r\n                    }\r\n                }\r\n\r\n                if (!this.parent.skipMaterials && this.parent.loadAllMaterials && this._gltf.materials) {\r\n                    for (let m = 0; m < this._gltf.materials.length; ++m) {\r\n                        const material = this._gltf.materials[m];\r\n                        const context = \"/materials/\" + m;\r\n                        const babylonDrawMode = Material.TriangleFillMode;\r\n\r\n                        promises.push(this._loadMaterialAsync(context, material, null, babylonDrawMode, () => {}));\r\n                    }\r\n                }\r\n\r\n                // Restore the blocking of material dirty.\r\n                if (this._allMaterialsDirtyRequired) {\r\n                    // This can happen if we add a light for instance as it will impact the whole scene.\r\n                    // This automatically resets everything if needed.\r\n                    this._babylonScene.blockMaterialDirtyMechanism = oldBlockMaterialDirtyMechanism;\r\n                } else {\r\n                    // By default a newly created material is dirty so there is no need to flag the full scene as dirty.\r\n                    // For perf reasons, we then bypass blockMaterialDirtyMechanism as this would \"dirty\" the entire scene.\r\n                    this._babylonScene._forceBlockMaterialDirtyMechanism(oldBlockMaterialDirtyMechanism);\r\n                }\r\n\r\n                if (this._parent.compileMaterials) {\r\n                    promises.push(this._compileMaterialsAsync());\r\n                }\r\n\r\n                if (this._parent.compileShadowGenerators) {\r\n                    promises.push(this._compileShadowGeneratorsAsync());\r\n                }\r\n\r\n                const resultPromise = Promise.all(promises).then(() => {\r\n                    if (this._rootBabylonMesh && this._rootBabylonMesh !== this._parent.customRootNode) {\r\n                        this._rootBabylonMesh.setEnabled(true);\r\n                    }\r\n\r\n                    // Making sure we enable enough lights to have all lights together\r\n                    for (const material of this._babylonScene.materials) {\r\n                        const mat = material as any;\r\n\r\n                        if (mat.maxSimultaneousLights !== undefined) {\r\n                            mat.maxSimultaneousLights = Math.max(mat.maxSimultaneousLights, this._babylonScene.lights.length);\r\n                        }\r\n                    }\r\n\r\n                    this._extensionsOnReady();\r\n                    this._parent._setState(GLTFLoaderState.READY);\r\n                    if (!this._skipStartAnimationStep) {\r\n                        this._startAnimations();\r\n                    }\r\n\r\n                    return resultFunc();\r\n                });\r\n\r\n                return await resultPromise.then((result) => {\r\n                    this._parent._endPerformanceCounter(loadingToReadyCounterName);\r\n\r\n                    Tools.SetImmediate(() => {\r\n                        if (!this._disposed) {\r\n                            Promise.all(this._completePromises).then(\r\n                                () => {\r\n                                    this._parent._endPerformanceCounter(loadingToCompleteCounterName);\r\n\r\n                                    this._parent._setState(GLTFLoaderState.COMPLETE);\r\n\r\n                                    this._parent.onCompleteObservable.notifyObservers(undefined);\r\n                                    this._parent.onCompleteObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                },\r\n                                (error) => {\r\n                                    this._parent.onErrorObservable.notifyObservers(error);\r\n                                    this._parent.onErrorObservable.clear();\r\n\r\n                                    this.dispose();\r\n                                }\r\n                            );\r\n                        }\r\n                    });\r\n\r\n                    return result;\r\n                });\r\n            })\r\n            .catch((error) => {\r\n                if (!this._disposed) {\r\n                    this._parent.onErrorObservable.notifyObservers(error);\r\n                    this._parent.onErrorObservable.clear();\r\n\r\n                    this.dispose();\r\n                }\r\n\r\n                throw error;\r\n            });\r\n    }\r\n\r\n    private _loadData(data: IGLTFLoaderData): void {\r\n        this._gltf = data.json as IGLTF;\r\n        this._setupData();\r\n\r\n        if (data.bin) {\r\n            const buffers = this._gltf.buffers;\r\n            if (buffers && buffers[0] && !buffers[0].uri) {\r\n                const binaryBuffer = buffers[0];\r\n                if (binaryBuffer.byteLength < data.bin.byteLength - 3 || binaryBuffer.byteLength > data.bin.byteLength) {\r\n                    Logger.Warn(`Binary buffer length (${binaryBuffer.byteLength}) from JSON does not match chunk length (${data.bin.byteLength})`);\r\n                }\r\n\r\n                this._bin = data.bin;\r\n            } else {\r\n                Logger.Warn(\"Unexpected BIN chunk\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private _setupData(): void {\r\n        ArrayItem.Assign(this._gltf.accessors);\r\n        ArrayItem.Assign(this._gltf.animations);\r\n        ArrayItem.Assign(this._gltf.buffers);\r\n        ArrayItem.Assign(this._gltf.bufferViews);\r\n        ArrayItem.Assign(this._gltf.cameras);\r\n        ArrayItem.Assign(this._gltf.images);\r\n        ArrayItem.Assign(this._gltf.materials);\r\n        ArrayItem.Assign(this._gltf.meshes);\r\n        ArrayItem.Assign(this._gltf.nodes);\r\n        ArrayItem.Assign(this._gltf.samplers);\r\n        ArrayItem.Assign(this._gltf.scenes);\r\n        ArrayItem.Assign(this._gltf.skins);\r\n        ArrayItem.Assign(this._gltf.textures);\r\n\r\n        if (this._gltf.nodes) {\r\n            const nodeParents: { [index: number]: number } = {};\r\n            for (const node of this._gltf.nodes) {\r\n                if (node.children) {\r\n                    for (const index of node.children) {\r\n                        nodeParents[index] = node.index;\r\n                    }\r\n                }\r\n            }\r\n\r\n            const rootNode = this._createRootNode();\r\n            for (const node of this._gltf.nodes) {\r\n                const parentIndex = nodeParents[node.index];\r\n                node.parent = parentIndex === undefined ? rootNode : this._gltf.nodes[parentIndex];\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _loadExtensionsAsync() {\r\n        const extensionPromises: Promise<IGLTFLoaderExtension>[] = [];\r\n\r\n        registeredGLTFExtensions.forEach((registeredExtension, name) => {\r\n            // Don't load explicitly disabled extensions.\r\n            if (this.parent.extensionOptions[name]?.enabled === false) {\r\n                // But warn if the disabled extension is used by the model.\r\n                if (registeredExtension.isGLTFExtension && this.isExtensionUsed(name)) {\r\n                    Logger.Warn(`Extension ${name} is used but has been explicitly disabled.`);\r\n                }\r\n            }\r\n            // Load loader extensions that are not a glTF extension, as well as extensions that are glTF extensions and are used by the model.\r\n            else if (!registeredExtension.isGLTFExtension || this.isExtensionUsed(name)) {\r\n                extensionPromises.push(\r\n                    (async () => {\r\n                        const extension = await registeredExtension.factory(this);\r\n                        if (extension.name !== name) {\r\n                            Logger.Warn(`The name of the glTF loader extension instance does not match the registered name: ${extension.name} !== ${name}`);\r\n                        }\r\n\r\n                        this._parent.onExtensionLoadedObservable.notifyObservers(extension);\r\n                        return extension;\r\n                    })()\r\n                );\r\n            }\r\n        });\r\n\r\n        this._extensions.push(...(await Promise.all(extensionPromises)));\r\n\r\n        this._extensions.sort((a, b) => (a.order || Number.MAX_VALUE) - (b.order || Number.MAX_VALUE));\r\n        this._parent.onExtensionLoadedObservable.clear();\r\n\r\n        if (this._gltf.extensionsRequired) {\r\n            for (const name of this._gltf.extensionsRequired) {\r\n                const available = this._extensions.some((extension) => extension.name === name && extension.enabled);\r\n                if (!available) {\r\n                    if (this.parent.extensionOptions[name]?.enabled === false) {\r\n                        throw new Error(`Required extension ${name} is disabled`);\r\n                    }\r\n                    throw new Error(`Required extension ${name} is not available`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private _createRootNode(): INode {\r\n        if (this._parent.customRootNode !== undefined) {\r\n            this._rootBabylonMesh = this._parent.customRootNode;\r\n            return {\r\n                // eslint-disable-next-line @typescript-eslint/naming-convention\r\n                _babylonTransformNode: this._rootBabylonMesh === null ? undefined : this._rootBabylonMesh,\r\n                index: -1,\r\n            };\r\n        }\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const rootMesh = new Mesh(\"__root__\", this._babylonScene);\r\n        this._rootBabylonMesh = rootMesh;\r\n        this._rootBabylonMesh._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        this._rootBabylonMesh.setEnabled(false);\r\n\r\n        const rootNode: INode = {\r\n            // eslint-disable-next-line @typescript-eslint/naming-convention\r\n            _babylonTransformNode: this._rootBabylonMesh,\r\n            index: -1,\r\n        };\r\n\r\n        switch (this._parent.coordinateSystemMode) {\r\n            case GLTFLoaderCoordinateSystemMode.AUTO: {\r\n                if (!this._babylonScene.useRightHandedSystem) {\r\n                    rootNode.rotation = [0, 1, 0, 0];\r\n                    rootNode.scale = [1, 1, -1];\r\n                    GLTFLoader._LoadTransform(rootNode, this._rootBabylonMesh);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderCoordinateSystemMode.FORCE_RIGHT_HANDED: {\r\n                this._babylonScene.useRightHandedSystem = true;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`Invalid coordinate system mode (${this._parent.coordinateSystemMode})`);\r\n            }\r\n        }\r\n\r\n        this._parent.onMeshLoadedObservable.notifyObservers(rootMesh);\r\n        return rootNode;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF scene.\r\n     * @param context The context when loading the asset\r\n     * @param scene The glTF scene property\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public loadSceneAsync(context: string, scene: IScene): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadSceneAsync(context, scene);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${scene.name || \"\"}`);\r\n\r\n        if (scene.nodes) {\r\n            for (const index of scene.nodes) {\r\n                const node = ArrayItem.Get(`${context}/nodes/${index}`, this._gltf.nodes, index);\r\n                promises.push(\r\n                    this.loadNodeAsync(`/nodes/${node.index}`, node, (babylonMesh) => {\r\n                        babylonMesh.parent = this._rootBabylonMesh;\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        for (const action of this._postSceneLoadActions) {\r\n            action();\r\n        }\r\n\r\n        promises.push(this._loadAnimationsAsync());\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private _forEachPrimitive(node: INode, callback: (babylonMesh: AbstractMesh) => void): void {\r\n        if (node._primitiveBabylonMeshes) {\r\n            for (const babylonMesh of node._primitiveBabylonMeshes) {\r\n                callback(babylonMesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _getGeometries(): Geometry[] {\r\n        const geometries: Geometry[] = [];\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    const geometry = (babylonMesh as Mesh).geometry;\r\n                    if (geometry && geometries.indexOf(geometry) === -1) {\r\n                        geometries.push(geometry);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return geometries;\r\n    }\r\n\r\n    private _getMeshes(): AbstractMesh[] {\r\n        const meshes: AbstractMesh[] = [];\r\n\r\n        // Root mesh is always first, if available.\r\n        if (this._rootBabylonMesh instanceof AbstractMesh) {\r\n            meshes.push(this._rootBabylonMesh);\r\n        }\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                this._forEachPrimitive(node, (babylonMesh) => {\r\n                    meshes.push(babylonMesh);\r\n                });\r\n            }\r\n        }\r\n\r\n        return meshes;\r\n    }\r\n\r\n    private _getTransformNodes(): TransformNode[] {\r\n        const transformNodes: TransformNode[] = [];\r\n\r\n        const nodes = this._gltf.nodes;\r\n        if (nodes) {\r\n            for (const node of nodes) {\r\n                if (node._babylonTransformNode && node._babylonTransformNode.getClassName() === \"TransformNode\") {\r\n                    transformNodes.push(node._babylonTransformNode);\r\n                }\r\n                if (node._babylonTransformNodeForSkin) {\r\n                    transformNodes.push(node._babylonTransformNodeForSkin);\r\n                }\r\n            }\r\n        }\r\n\r\n        return transformNodes;\r\n    }\r\n\r\n    private _getSkeletons(): Skeleton[] {\r\n        const skeletons: Skeleton[] = [];\r\n\r\n        const skins = this._gltf.skins;\r\n        if (skins) {\r\n            for (const skin of skins) {\r\n                if (skin._data) {\r\n                    skeletons.push(skin._data.babylonSkeleton);\r\n                }\r\n            }\r\n        }\r\n\r\n        return skeletons;\r\n    }\r\n\r\n    private _getAnimationGroups(): AnimationGroup[] {\r\n        const animationGroups: AnimationGroup[] = [];\r\n\r\n        const animations = this._gltf.animations;\r\n        if (animations) {\r\n            for (const animation of animations) {\r\n                if (animation._babylonAnimationGroup) {\r\n                    animationGroups.push(animation._babylonAnimationGroup);\r\n                }\r\n            }\r\n        }\r\n\r\n        return animationGroups;\r\n    }\r\n\r\n    private _startAnimations(): void {\r\n        switch (this._parent.animationStartMode) {\r\n            case GLTFLoaderAnimationStartMode.NONE: {\r\n                // do nothing\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.FIRST: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                if (babylonAnimationGroups.length !== 0) {\r\n                    babylonAnimationGroups[0].start(true);\r\n                }\r\n                break;\r\n            }\r\n            case GLTFLoaderAnimationStartMode.ALL: {\r\n                const babylonAnimationGroups = this._getAnimationGroups();\r\n                for (const babylonAnimationGroup of babylonAnimationGroups) {\r\n                    babylonAnimationGroup.start(true);\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                Logger.Error(`Invalid animation start mode (${this._parent.animationStartMode})`);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF node.\r\n     * @param context The context when loading the asset\r\n     * @param node The glTF node property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon mesh when the load is complete\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void = () => {}): Promise<TransformNode> {\r\n        const extensionPromise = this._extensionsLoadNodeAsync(context, node, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (node._babylonTransformNode) {\r\n            throw new Error(`${context}: Invalid recursive node hierarchy`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${node.name || \"\"}`);\r\n\r\n        const loadNode = (babylonTransformNode: TransformNode) => {\r\n            GLTFLoader.AddPointerMetadata(babylonTransformNode, context);\r\n            GLTFLoader._LoadTransform(node, babylonTransformNode);\r\n\r\n            if (node.camera != undefined) {\r\n                const camera = ArrayItem.Get(`${context}/camera`, this._gltf.cameras, node.camera);\r\n                promises.push(\r\n                    this.loadCameraAsync(`/cameras/${camera.index}`, camera, (babylonCamera) => {\r\n                        babylonCamera.parent = babylonTransformNode;\r\n                        if (!this._babylonScene.useRightHandedSystem) {\r\n                            babylonTransformNode.scaling.x = -1; // Cancelling root node scaling for handedness so the view matrix does not end up flipped.\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (node.children) {\r\n                for (const index of node.children) {\r\n                    const childNode = ArrayItem.Get(`${context}/children/${index}`, this._gltf.nodes, index);\r\n                    promises.push(\r\n                        this.loadNodeAsync(`/nodes/${childNode.index}`, childNode, (childBabylonMesh) => {\r\n                            childBabylonMesh.parent = babylonTransformNode;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            assign(babylonTransformNode);\r\n        };\r\n\r\n        const hasMesh = node.mesh != undefined;\r\n        const hasSkin = this._parent.loadSkins && node.skin != undefined;\r\n\r\n        if (!hasMesh || hasSkin) {\r\n            const nodeName = node.name || `node${node.index}`;\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const transformNode = new TransformNode(nodeName, this._babylonScene);\r\n            transformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            if (node.mesh == undefined) {\r\n                node._babylonTransformNode = transformNode;\r\n            } else {\r\n                node._babylonTransformNodeForSkin = transformNode;\r\n            }\r\n            loadNode(transformNode);\r\n        }\r\n\r\n        if (hasMesh) {\r\n            if (hasSkin) {\r\n                // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n                // This code path will place the skinned mesh as a sibling of the skeleton root node without loading the\r\n                // transform, which effectively ignores the transform of the skinned mesh, as per spec.\r\n\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(\r\n                    this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, (babylonTransformNode) => {\r\n                        const babylonTransformNodeForSkin = node._babylonTransformNodeForSkin!;\r\n\r\n                        // Merge the metadata from the skin node to the skinned mesh in case a loader extension added metadata.\r\n                        babylonTransformNode.metadata = deepMerge(babylonTransformNodeForSkin.metadata, babylonTransformNode.metadata || {});\r\n\r\n                        const skin = ArrayItem.Get(`${context}/skin`, this._gltf.skins, node.skin);\r\n                        promises.push(\r\n                            this._loadSkinAsync(`/skins/${skin.index}`, node, skin, (babylonSkeleton) => {\r\n                                this._forEachPrimitive(node, (babylonMesh) => {\r\n                                    babylonMesh.skeleton = babylonSkeleton;\r\n                                });\r\n\r\n                                // Wait until all the nodes are parented before parenting the skinned mesh.\r\n                                this._postSceneLoadActions.push(() => {\r\n                                    if (skin.skeleton != undefined) {\r\n                                        // Place the skinned mesh node as a sibling of the skeleton root node.\r\n                                        // Handle special case when the parent of the skeleton root is the skinned mesh.\r\n                                        const parentNode = ArrayItem.Get(`/skins/${skin.index}/skeleton`, this._gltf.nodes, skin.skeleton).parent!;\r\n                                        if (node.index === parentNode.index) {\r\n                                            babylonTransformNode.parent = babylonTransformNodeForSkin.parent;\r\n                                        } else {\r\n                                            babylonTransformNode.parent = parentNode._babylonTransformNode!;\r\n                                        }\r\n                                    } else {\r\n                                        babylonTransformNode.parent = this._rootBabylonMesh;\r\n                                    }\r\n\r\n                                    this._parent.onSkinLoadedObservable.notifyObservers({ node: babylonTransformNodeForSkin, skinnedNode: babylonTransformNode });\r\n                                });\r\n                            })\r\n                        );\r\n                    })\r\n                );\r\n            } else {\r\n                const mesh = ArrayItem.Get(`${context}/mesh`, this._gltf.meshes, node.mesh);\r\n                promises.push(this._loadMeshAsync(`/meshes/${mesh.index}`, node, mesh, loadNode));\r\n            }\r\n        }\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._forEachPrimitive(node, (babylonMesh) => {\r\n                const asMesh = babylonMesh as Mesh;\r\n                if (!asMesh.isAnInstance && asMesh.geometry && asMesh.geometry.useBoundingInfoFromGeometry) {\r\n                    // simply apply the world matrices to the bounding info - the extends are already ok\r\n                    babylonMesh._updateBoundingInfo();\r\n                } else {\r\n                    babylonMesh.refreshBoundingInfo(true, true);\r\n                }\r\n            });\r\n\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadMeshAsync(context: string, node: INode, mesh: IMesh, assign: (babylonTransformNode: TransformNode) => void): Promise<TransformNode> {\r\n        const primitives = mesh.primitives;\r\n        if (!primitives || !primitives.length) {\r\n            throw new Error(`${context}: Primitives are missing`);\r\n        }\r\n\r\n        if (primitives[0].index == undefined) {\r\n            ArrayItem.Assign(primitives);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${mesh.name || \"\"}`);\r\n\r\n        const name = node.name || `node${node.index}`;\r\n\r\n        if (primitives.length === 1) {\r\n            const primitive = mesh.primitives[0];\r\n            promises.push(\r\n                this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, name, node, mesh, primitive, (babylonMesh) => {\r\n                    node._babylonTransformNode = babylonMesh;\r\n                    node._primitiveBabylonMeshes = [babylonMesh];\r\n                })\r\n            );\r\n        } else {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            node._babylonTransformNode = new TransformNode(name, this._babylonScene);\r\n            node._babylonTransformNode._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            node._primitiveBabylonMeshes = [];\r\n            for (const primitive of primitives) {\r\n                promises.push(\r\n                    this._loadMeshPrimitiveAsync(`${context}/primitives/${primitive.index}`, `${name}_primitive${primitive.index}`, node, mesh, primitive, (babylonMesh) => {\r\n                        babylonMesh.parent = node._babylonTransformNode!;\r\n                        node._primitiveBabylonMeshes!.push(babylonMesh);\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        assign(node._babylonTransformNode!);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return node._babylonTransformNode!;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal Define this method to modify the default behavior when loading data for mesh primitives.\r\n     * @param context The context when loading the asset\r\n     * @param name The mesh name when loading the asset\r\n     * @param node The glTF node when loading the asset\r\n     * @param mesh The glTF mesh when loading the asset\r\n     * @param primitive The glTF mesh primitive property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded mesh when the load is complete or null if not handled\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public _loadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Promise<AbstractMesh> {\r\n        const extensionPromise = this._extensionsLoadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        const shouldInstance = this._disableInstancedMesh === 0 && this._parent.createInstances && node.skin == undefined && !mesh.primitives[0].targets;\r\n\r\n        let babylonAbstractMesh: AbstractMesh;\r\n        let promise: Promise<unknown>;\r\n\r\n        if (shouldInstance && primitive._instanceData) {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            babylonAbstractMesh = primitive._instanceData.babylonSourceMesh.createInstance(name);\r\n            babylonAbstractMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            promise = primitive._instanceData.promise;\r\n        } else {\r\n            const promises = new Array<Promise<unknown>>();\r\n\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonMesh = new Mesh(name, this._babylonScene);\r\n            babylonMesh._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            babylonMesh.sideOrientation = this._babylonScene.useRightHandedSystem ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;\r\n\r\n            this._createMorphTargets(context, node, mesh, primitive, babylonMesh);\r\n            promises.push(\r\n                this._loadVertexDataAsync(context, primitive, babylonMesh).then(async (babylonGeometry) => {\r\n                    return await this._loadMorphTargetsAsync(context, primitive, babylonMesh, babylonGeometry).then(() => {\r\n                        if (this._disposed) {\r\n                            return;\r\n                        }\r\n\r\n                        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n                        babylonGeometry.applyToMesh(babylonMesh);\r\n                        babylonGeometry._parentContainer = this._assetContainer;\r\n                        this._babylonScene._blockEntityCollection = false;\r\n                    });\r\n                })\r\n            );\r\n\r\n            if (!this.parent.skipMaterials) {\r\n                const babylonDrawMode = GLTFLoader._GetDrawMode(context, primitive.mode);\r\n                if (primitive.material == undefined) {\r\n                    let babylonMaterial = this._defaultBabylonMaterialData[babylonDrawMode];\r\n                    if (!babylonMaterial) {\r\n                        babylonMaterial = this._createDefaultMaterial(\"__GLTFLoader._default\", babylonDrawMode);\r\n                        this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n                        this._defaultBabylonMaterialData[babylonDrawMode] = babylonMaterial;\r\n                    }\r\n                    babylonMesh.material = babylonMaterial;\r\n                } else {\r\n                    const material = ArrayItem.Get(`${context}/material`, this._gltf.materials, primitive.material);\r\n                    promises.push(\r\n                        this._loadMaterialAsync(`/materials/${material.index}`, material, babylonMesh, babylonDrawMode, (babylonMaterial) => {\r\n                            babylonMesh.material = babylonMaterial;\r\n                        })\r\n                    );\r\n                }\r\n            }\r\n\r\n            promise = Promise.all(promises);\r\n\r\n            if (shouldInstance) {\r\n                primitive._instanceData = {\r\n                    babylonSourceMesh: babylonMesh,\r\n                    promise: promise,\r\n                };\r\n            }\r\n\r\n            babylonAbstractMesh = babylonMesh;\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonAbstractMesh, context);\r\n        this._parent.onMeshLoadedObservable.notifyObservers(babylonAbstractMesh);\r\n        assign(babylonAbstractMesh);\r\n\r\n        this.logClose();\r\n\r\n        return promise.then(() => {\r\n            return babylonAbstractMesh;\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Promise<Geometry> {\r\n        const extensionPromise = this._extensionsLoadVertexDataAsync(context, primitive, babylonMesh);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const attributes = primitive.attributes;\r\n        if (!attributes) {\r\n            throw new Error(`${context}: Attributes are missing`);\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const babylonGeometry = new Geometry(babylonMesh.name, this._babylonScene);\r\n\r\n        if (primitive.indices == undefined) {\r\n            babylonMesh.isUnIndexed = true;\r\n        } else {\r\n            const accessor = ArrayItem.Get(`${context}/indices`, this._gltf.accessors, primitive.indices);\r\n            promises.push(\r\n                this._loadIndicesAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    babylonGeometry.setIndices(data);\r\n                })\r\n            );\r\n        }\r\n\r\n        const loadAttribute = (name: string, kind: string, callback?: (accessor: IAccessor) => void) => {\r\n            if (attributes[name] == undefined) {\r\n                return;\r\n            }\r\n\r\n            babylonMesh._delayInfo = babylonMesh._delayInfo || [];\r\n            if (babylonMesh._delayInfo.indexOf(kind) === -1) {\r\n                babylonMesh._delayInfo.push(kind);\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/attributes/${name}`, this._gltf.accessors, attributes[name]);\r\n            promises.push(\r\n                this._loadVertexAccessorAsync(`/accessors/${accessor.index}`, accessor, kind).then((babylonVertexBuffer) => {\r\n                    if (babylonVertexBuffer.getKind() === VertexBuffer.PositionKind && !this.parent.alwaysComputeBoundingBox && !babylonMesh.skeleton) {\r\n                        const babylonBoundingInfo = LoadBoundingInfoFromPositionAccessor(accessor);\r\n                        if (babylonBoundingInfo) {\r\n                            babylonGeometry._boundingInfo = babylonBoundingInfo;\r\n                            babylonGeometry.useBoundingInfoFromGeometry = true;\r\n                        }\r\n                    }\r\n                    babylonGeometry.setVerticesBuffer(babylonVertexBuffer, accessor.count);\r\n                })\r\n            );\r\n\r\n            if (kind == VertexBuffer.MatricesIndicesExtraKind) {\r\n                babylonMesh.numBoneInfluencers = 8;\r\n            }\r\n\r\n            if (callback) {\r\n                callback(accessor);\r\n            }\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind);\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind);\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind);\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind);\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind);\r\n        loadAttribute(\"TEXCOORD_2\", VertexBuffer.UV3Kind);\r\n        loadAttribute(\"TEXCOORD_3\", VertexBuffer.UV4Kind);\r\n        loadAttribute(\"TEXCOORD_4\", VertexBuffer.UV5Kind);\r\n        loadAttribute(\"TEXCOORD_5\", VertexBuffer.UV6Kind);\r\n        loadAttribute(\"JOINTS_0\", VertexBuffer.MatricesIndicesKind);\r\n        loadAttribute(\"WEIGHTS_0\", VertexBuffer.MatricesWeightsKind);\r\n        loadAttribute(\"JOINTS_1\", VertexBuffer.MatricesIndicesExtraKind);\r\n        loadAttribute(\"WEIGHTS_1\", VertexBuffer.MatricesWeightsExtraKind);\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (accessor) => {\r\n            if (accessor.type === AccessorType.VEC4) {\r\n                babylonMesh.hasVertexAlpha = true;\r\n            }\r\n        });\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonGeometry;\r\n        });\r\n    }\r\n\r\n    private _createMorphTargets(context: string, node: INode, mesh: IMesh, primitive: IMeshPrimitive, babylonMesh: Mesh): void {\r\n        if (!primitive.targets || !this._parent.loadMorphTargets) {\r\n            return;\r\n        }\r\n\r\n        if (node._numMorphTargets == undefined) {\r\n            node._numMorphTargets = primitive.targets.length;\r\n        } else if (primitive.targets.length !== node._numMorphTargets) {\r\n            throw new Error(`${context}: Primitives do not have the same number of targets`);\r\n        }\r\n\r\n        const targetNames = mesh.extras ? mesh.extras.targetNames : null;\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        babylonMesh.morphTargetManager = new MorphTargetManager(this._babylonScene);\r\n        babylonMesh.morphTargetManager._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        babylonMesh.morphTargetManager.areUpdatesFrozen = true;\r\n\r\n        for (let index = 0; index < primitive.targets.length; index++) {\r\n            const weight = node.weights ? node.weights[index] : mesh.weights ? mesh.weights[index] : 0;\r\n            const name = targetNames ? targetNames[index] : `morphTarget${index}`;\r\n            babylonMesh.morphTargetManager.addTarget(new MorphTarget(name, weight, babylonMesh.getScene()));\r\n            // TODO: tell the target whether it has positions, normals, tangents\r\n        }\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadMorphTargetsAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh, babylonGeometry: Geometry): Promise<void> {\r\n        if (!primitive.targets || !this._parent.loadMorphTargets) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const morphTargetManager = babylonMesh.morphTargetManager!;\r\n        for (let index = 0; index < morphTargetManager.numTargets; index++) {\r\n            const babylonMorphTarget = morphTargetManager.getTarget(index);\r\n            promises.push(this._loadMorphTargetVertexDataAsync(`${context}/targets/${index}`, babylonGeometry, primitive.targets[index], babylonMorphTarget));\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            morphTargetManager.areUpdatesFrozen = false;\r\n        });\r\n    }\r\n\r\n    private async _loadMorphTargetVertexDataAsync(\r\n        context: string,\r\n        babylonGeometry: Geometry,\r\n        attributes: { [name: string]: number },\r\n        babylonMorphTarget: MorphTarget\r\n    ): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const loadAttribute = (attribute: string, kind: string, setData: (babylonVertexBuffer: VertexBuffer, data: Float32Array) => void) => {\r\n            if (attributes[attribute] == undefined) {\r\n                return;\r\n            }\r\n\r\n            const babylonVertexBuffer = babylonGeometry.getVertexBuffer(kind);\r\n            if (!babylonVertexBuffer) {\r\n                return;\r\n            }\r\n\r\n            const accessor = ArrayItem.Get(`${context}/${attribute}`, this._gltf.accessors, attributes[attribute]);\r\n            promises.push(\r\n                this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor).then((data) => {\r\n                    setData(babylonVertexBuffer, data);\r\n                })\r\n            );\r\n        };\r\n\r\n        loadAttribute(\"POSITION\", VertexBuffer.PositionKind, (babylonVertexBuffer, data) => {\r\n            const positions = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                positions[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setPositions(positions);\r\n        });\r\n\r\n        loadAttribute(\"NORMAL\", VertexBuffer.NormalKind, (babylonVertexBuffer, data) => {\r\n            const normals = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(normals.length, (value, index) => {\r\n                normals[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setNormals(normals);\r\n        });\r\n\r\n        loadAttribute(\"TANGENT\", VertexBuffer.TangentKind, (babylonVertexBuffer, data) => {\r\n            const tangents = new Float32Array((data.length / 3) * 4);\r\n            let dataIndex = 0;\r\n            babylonVertexBuffer.forEach((data.length / 3) * 4, (value, index) => {\r\n                // Tangent data for morph targets is stored as xyz delta.\r\n                // The vertexData.tangent is stored as xyzw.\r\n                // So we need to skip every fourth vertexData.tangent.\r\n                if ((index + 1) % 4 !== 0) {\r\n                    tangents[dataIndex] = data[dataIndex] + value;\r\n                    dataIndex++;\r\n                }\r\n            });\r\n            babylonMorphTarget.setTangents(tangents);\r\n        });\r\n\r\n        loadAttribute(\"TEXCOORD_0\", VertexBuffer.UVKind, (babylonVertexBuffer, data) => {\r\n            const uvs = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                uvs[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setUVs(uvs);\r\n        });\r\n\r\n        loadAttribute(\"TEXCOORD_1\", VertexBuffer.UV2Kind, (babylonVertexBuffer, data) => {\r\n            const uvs = new Float32Array(data.length);\r\n            babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                uvs[index] = data[index] + value;\r\n            });\r\n\r\n            babylonMorphTarget.setUV2s(uvs);\r\n        });\r\n\r\n        loadAttribute(\"COLOR_0\", VertexBuffer.ColorKind, (babylonVertexBuffer, data) => {\r\n            let colors = null;\r\n            const componentSize = babylonVertexBuffer.getSize();\r\n            if (componentSize === 3) {\r\n                colors = new Float32Array((data.length / 3) * 4);\r\n                babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                    const pixid = Math.floor(index / 3);\r\n                    const channel = index % 3;\r\n                    colors[4 * pixid + channel] = data[3 * pixid + channel] + value;\r\n                });\r\n                for (let i = 0; i < data.length / 3; ++i) {\r\n                    colors[4 * i + 3] = 1;\r\n                }\r\n            } else if (componentSize === 4) {\r\n                colors = new Float32Array(data.length);\r\n                babylonVertexBuffer.forEach(data.length, (value, index) => {\r\n                    colors[index] = data[index] + value;\r\n                });\r\n            } else {\r\n                throw new Error(`${context}: Invalid number of components (${componentSize}) for COLOR_0 attribute`);\r\n            }\r\n            babylonMorphTarget.setColors(colors);\r\n        });\r\n\r\n        return await Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    private static _LoadTransform(node: INode, babylonNode: TransformNode): void {\r\n        // Ignore the TRS of skinned nodes.\r\n        // See https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins (second implementation note)\r\n        if (node.skin != undefined) {\r\n            return;\r\n        }\r\n\r\n        let position = Vector3.Zero();\r\n        let rotation = Quaternion.Identity();\r\n        let scaling = Vector3.One();\r\n\r\n        if (node.matrix) {\r\n            const matrix = Matrix.FromArray(node.matrix);\r\n            matrix.decompose(scaling, rotation, position);\r\n        } else {\r\n            if (node.translation) {\r\n                position = Vector3.FromArray(node.translation);\r\n            }\r\n            if (node.rotation) {\r\n                rotation = Quaternion.FromArray(node.rotation);\r\n            }\r\n            if (node.scale) {\r\n                scaling = Vector3.FromArray(node.scale);\r\n            }\r\n        }\r\n\r\n        babylonNode.position = position;\r\n        babylonNode.rotationQuaternion = rotation;\r\n        babylonNode.scaling = scaling;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _loadSkinAsync(context: string, node: INode, skin: ISkin, assign: (babylonSkeleton: Skeleton) => void): Promise<void> {\r\n        if (!this._parent.loadSkins) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const extensionPromise = this._extensionsLoadSkinAsync(context, node, skin);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (skin._data) {\r\n            assign(skin._data.babylonSkeleton);\r\n            return skin._data.promise;\r\n        }\r\n\r\n        const skeletonId = `skeleton${skin.index}`;\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonSkeleton = new Skeleton(skin.name || skeletonId, skeletonId, this._babylonScene);\r\n        babylonSkeleton._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n\r\n        this._loadBones(context, skin, babylonSkeleton);\r\n        const promise = this._loadSkinInverseBindMatricesDataAsync(context, skin).then((inverseBindMatricesData) => {\r\n            this._updateBoneMatrices(babylonSkeleton, inverseBindMatricesData);\r\n        });\r\n\r\n        skin._data = {\r\n            babylonSkeleton: babylonSkeleton,\r\n            promise: promise,\r\n        };\r\n\r\n        assign(babylonSkeleton);\r\n\r\n        return promise;\r\n    }\r\n\r\n    private _loadBones(context: string, skin: ISkin, babylonSkeleton: Skeleton): void {\r\n        if (skin.skeleton == undefined || this._parent.alwaysComputeSkeletonRootNode) {\r\n            const rootNode = this._findSkeletonRootNode(`${context}/joints`, skin.joints);\r\n            if (rootNode) {\r\n                if (skin.skeleton === undefined) {\r\n                    skin.skeleton = rootNode.index;\r\n                } else {\r\n                    const isParent = (a: INode, b: INode): boolean => {\r\n                        for (; b.parent; b = b.parent) {\r\n                            if (b.parent === a) {\r\n                                return true;\r\n                            }\r\n                        }\r\n\r\n                        return false;\r\n                    };\r\n\r\n                    const skeletonNode = ArrayItem.Get(`${context}/skeleton`, this._gltf.nodes, skin.skeleton);\r\n                    if (skeletonNode !== rootNode && !isParent(skeletonNode, rootNode)) {\r\n                        Logger.Warn(`${context}/skeleton: Overriding with nearest common ancestor as skeleton node is not a common root`);\r\n                        skin.skeleton = rootNode.index;\r\n                    }\r\n                }\r\n            } else {\r\n                Logger.Warn(`${context}: Failed to find common root`);\r\n            }\r\n        }\r\n\r\n        const babylonBones: { [index: number]: Bone } = {};\r\n        for (const index of skin.joints) {\r\n            const node = ArrayItem.Get(`${context}/joints/${index}`, this._gltf.nodes, index);\r\n            this._loadBone(node, skin, babylonSkeleton, babylonBones);\r\n        }\r\n    }\r\n\r\n    private _findSkeletonRootNode(context: string, joints: Array<number>): Nullable<INode> {\r\n        if (joints.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const paths: { [joint: number]: Array<INode> } = {};\r\n        for (const index of joints) {\r\n            const path: INode[] = [];\r\n            let node = ArrayItem.Get(`${context}/${index}`, this._gltf.nodes, index);\r\n            while (node.index !== -1) {\r\n                path.unshift(node);\r\n                node = node.parent!;\r\n            }\r\n            paths[index] = path;\r\n        }\r\n\r\n        let rootNode: Nullable<INode> = null;\r\n        for (let i = 0; ; ++i) {\r\n            let path = paths[joints[0]];\r\n            if (i >= path.length) {\r\n                return rootNode;\r\n            }\r\n\r\n            const node = path[i];\r\n            for (let j = 1; j < joints.length; ++j) {\r\n                path = paths[joints[j]];\r\n                if (i >= path.length || node !== path[i]) {\r\n                    return rootNode;\r\n                }\r\n            }\r\n\r\n            rootNode = node;\r\n        }\r\n    }\r\n\r\n    private _loadBone(node: INode, skin: ISkin, babylonSkeleton: Skeleton, babylonBones: { [index: number]: Bone }): Bone {\r\n        node._isJoint = true;\r\n\r\n        let babylonBone = babylonBones[node.index];\r\n        if (babylonBone) {\r\n            return babylonBone;\r\n        }\r\n\r\n        let parentBabylonBone: Nullable<Bone> = null;\r\n        if (node.index !== skin.skeleton) {\r\n            if (node.parent && node.parent.index !== -1) {\r\n                parentBabylonBone = this._loadBone(node.parent, skin, babylonSkeleton, babylonBones);\r\n            } else if (skin.skeleton !== undefined) {\r\n                Logger.Warn(`/skins/${skin.index}/skeleton: Skeleton node is not a common root`);\r\n            }\r\n        }\r\n\r\n        const boneIndex = skin.joints.indexOf(node.index);\r\n        babylonBone = new Bone(node.name || `joint${node.index}`, babylonSkeleton, parentBabylonBone, this._getNodeMatrix(node), null, null, boneIndex);\r\n        babylonBones[node.index] = babylonBone;\r\n\r\n        // Wait until the scene is loaded to ensure the transform nodes are loaded.\r\n        this._postSceneLoadActions.push(() => {\r\n            // Link the Babylon bone with the corresponding Babylon transform node.\r\n            // A glTF joint is a pointer to a glTF node in the glTF node hierarchy similar to Unity3D.\r\n            babylonBone.linkTransformNode(node._babylonTransformNode!);\r\n        });\r\n\r\n        return babylonBone;\r\n    }\r\n\r\n    private _loadSkinInverseBindMatricesDataAsync(context: string, skin: ISkin): Promise<Nullable<Float32Array>> {\r\n        if (skin.inverseBindMatrices == undefined) {\r\n            return Promise.resolve(null);\r\n        }\r\n\r\n        const accessor = ArrayItem.Get(`${context}/inverseBindMatrices`, this._gltf.accessors, skin.inverseBindMatrices);\r\n        return this._loadFloatAccessorAsync(`/accessors/${accessor.index}`, accessor);\r\n    }\r\n\r\n    private _updateBoneMatrices(babylonSkeleton: Skeleton, inverseBindMatricesData: Nullable<Float32Array>): void {\r\n        for (const babylonBone of babylonSkeleton.bones) {\r\n            const baseMatrix = Matrix.Identity();\r\n            const boneIndex = babylonBone._index!;\r\n            if (inverseBindMatricesData && boneIndex !== -1) {\r\n                Matrix.FromArrayToRef(inverseBindMatricesData, boneIndex * 16, baseMatrix);\r\n                baseMatrix.invertToRef(baseMatrix);\r\n            }\r\n\r\n            const babylonParentBone = babylonBone.getParent();\r\n            if (babylonParentBone) {\r\n                baseMatrix.multiplyToRef(babylonParentBone.getAbsoluteInverseBindMatrix(), baseMatrix);\r\n            }\r\n\r\n            babylonBone.updateMatrix(baseMatrix, false, false);\r\n            babylonBone._updateAbsoluteBindMatrices(undefined, false);\r\n        }\r\n    }\r\n\r\n    private _getNodeMatrix(node: INode): Matrix {\r\n        return node.matrix\r\n            ? Matrix.FromArray(node.matrix)\r\n            : Matrix.Compose(\r\n                  node.scale ? Vector3.FromArray(node.scale) : Vector3.One(),\r\n                  node.rotation ? Quaternion.FromArray(node.rotation) : Quaternion.Identity(),\r\n                  node.translation ? Vector3.FromArray(node.translation) : Vector3.Zero()\r\n              );\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF camera.\r\n     * @param context The context when loading the asset\r\n     * @param camera The glTF camera property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon camera when the load is complete\r\n     */\r\n    public loadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void = () => {}): Promise<Camera> {\r\n        const extensionPromise = this._extensionsLoadCameraAsync(context, camera, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        this.logOpen(`${context} ${camera.name || \"\"}`);\r\n\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonCamera = new FreeCamera(camera.name || `camera${camera.index}`, Vector3.Zero(), this._babylonScene, false);\r\n        babylonCamera._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        camera._babylonCamera = babylonCamera;\r\n\r\n        // glTF cameras look towards the local -Z axis.\r\n        babylonCamera.setTarget(new Vector3(0, 0, -1));\r\n\r\n        switch (camera.type) {\r\n            case CameraType.PERSPECTIVE: {\r\n                const perspective = camera.perspective;\r\n                if (!perspective) {\r\n                    throw new Error(`${context}: Camera perspective properties are missing`);\r\n                }\r\n\r\n                babylonCamera.fov = perspective.yfov;\r\n                babylonCamera.minZ = perspective.znear;\r\n                babylonCamera.maxZ = perspective.zfar || 0;\r\n                break;\r\n            }\r\n            case CameraType.ORTHOGRAPHIC: {\r\n                if (!camera.orthographic) {\r\n                    throw new Error(`${context}: Camera orthographic properties are missing`);\r\n                }\r\n\r\n                babylonCamera.mode = Camera.ORTHOGRAPHIC_CAMERA;\r\n                babylonCamera.orthoLeft = -camera.orthographic.xmag;\r\n                babylonCamera.orthoRight = camera.orthographic.xmag;\r\n                babylonCamera.orthoBottom = -camera.orthographic.ymag;\r\n                babylonCamera.orthoTop = camera.orthographic.ymag;\r\n                babylonCamera.minZ = camera.orthographic.znear;\r\n                babylonCamera.maxZ = camera.orthographic.zfar;\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}: Invalid camera type (${camera.type})`);\r\n            }\r\n        }\r\n\r\n        GLTFLoader.AddPointerMetadata(babylonCamera, context);\r\n        this._parent.onCameraLoadedObservable.notifyObservers(babylonCamera);\r\n        assign(babylonCamera);\r\n\r\n        this.logClose();\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonCamera;\r\n        });\r\n    }\r\n\r\n    private _loadAnimationsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Load animations\");\r\n\r\n        const animations = this._gltf.animations;\r\n        if (!animations) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const promises = new Array<Promise<void>>();\r\n\r\n        for (let index = 0; index < animations.length; index++) {\r\n            const animation = animations[index];\r\n            promises.push(\r\n                this.loadAnimationAsync(`/animations/${animation.index}`, animation).then((animationGroup) => {\r\n                    // Delete the animation group if it ended up not having any animations in it.\r\n                    if (animationGroup.targetedAnimations.length === 0) {\r\n                        animationGroup.dispose();\r\n                    }\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Load animations\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF animation.\r\n     * @param context The context when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @returns A promise that resolves with the loaded Babylon animation group when the load is complete\r\n     */\r\n    public loadAnimationAsync(context: string, animation: IAnimation): Promise<AnimationGroup> {\r\n        this._parent._startPerformanceCounter(\"Load animation\");\r\n\r\n        const promise = this._extensionsLoadAnimationAsync(context, animation);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        // eslint-disable-next-line @typescript-eslint/naming-convention\r\n        return LazyAnimationGroupModulePromise.value.then(({ AnimationGroup }) => {\r\n            this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n            const babylonAnimationGroup = new AnimationGroup(animation.name || `animation${animation.index}`, this._babylonScene);\r\n            babylonAnimationGroup._parentContainer = this._assetContainer;\r\n            this._babylonScene._blockEntityCollection = false;\r\n            animation._babylonAnimationGroup = babylonAnimationGroup;\r\n\r\n            const promises = new Array<Promise<unknown>>();\r\n\r\n            ArrayItem.Assign(animation.channels);\r\n            ArrayItem.Assign(animation.samplers);\r\n\r\n            for (const channel of animation.channels) {\r\n                promises.push(\r\n                    this._loadAnimationChannelAsync(`${context}/channels/${channel.index}`, context, animation, channel, (babylonTarget, babylonAnimation) => {\r\n                        babylonTarget.animations = babylonTarget.animations || [];\r\n                        babylonTarget.animations.push(babylonAnimation);\r\n                        babylonAnimationGroup.addTargetedAnimation(babylonAnimation, babylonTarget);\r\n                    })\r\n                );\r\n            }\r\n\r\n            this._parent._endPerformanceCounter(\"Load animation\");\r\n\r\n            return Promise.all(promises).then(() => {\r\n                babylonAnimationGroup.normalize(0);\r\n                return babylonAnimationGroup;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const promise = this._extensionsLoadAnimationChannelAsync(context, animationContext, animation, channel, onLoad);\r\n        if (promise) {\r\n            return promise;\r\n        }\r\n\r\n        if (channel.target.node == undefined) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        const targetNode = ArrayItem.Get(`${context}/target/node`, this._gltf.nodes, channel.target.node);\r\n        const channelTargetPath = channel.target.path;\r\n        const pathIsWeights = channelTargetPath === AnimationChannelTargetPath.WEIGHTS;\r\n\r\n        // Ignore animations that have no animation targets.\r\n        if ((pathIsWeights && !targetNode._numMorphTargets) || (!pathIsWeights && !targetNode._babylonTransformNode)) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Don't load node animations if disabled.\r\n        if (!this._parent.loadNodeAnimations && !pathIsWeights && !targetNode._isJoint) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // async-load the animation sampler to provide the interpolation of the channelTargetPath\r\n        return LazyLoaderAnimationModulePromise.value.then(() => {\r\n            let properties: IInterpolationPropertyInfo[];\r\n            switch (channelTargetPath) {\r\n                case AnimationChannelTargetPath.TRANSLATION: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/translation\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.ROTATION: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/rotation\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.SCALE: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/scale\")?.interpolation!;\r\n                    break;\r\n                }\r\n                case AnimationChannelTargetPath.WEIGHTS: {\r\n                    properties = GetMappingForKey(\"/nodes/{}/weights\")?.interpolation!;\r\n                    break;\r\n                }\r\n                default: {\r\n                    throw new Error(`${context}/target/path: Invalid value (${channel.target.path})`);\r\n                }\r\n            }\r\n            // stay safe\r\n            if (!properties) {\r\n                throw new Error(`${context}/target/path: Could not find interpolation properties for target path (${channel.target.path})`);\r\n            }\r\n\r\n            const targetInfo: IObjectInfo<IInterpolationPropertyInfo[]> = {\r\n                object: targetNode,\r\n                info: properties,\r\n            };\r\n\r\n            return this._loadAnimationChannelFromTargetInfoAsync(context, animationContext, animation, channel, targetInfo, onLoad);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @hidden\r\n     * Loads a glTF animation channel.\r\n     * @param context The context when loading the asset\r\n     * @param animationContext The context of the animation when loading the asset\r\n     * @param animation The glTF animation property\r\n     * @param channel The glTF animation channel property\r\n     * @param targetInfo The glTF target and properties\r\n     * @param onLoad Called for each animation loaded\r\n     * @returns A void promise that resolves when the load is complete\r\n     */\r\n    public _loadAnimationChannelFromTargetInfoAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        targetInfo: IObjectInfo<IInterpolationPropertyInfo[]>,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Promise<void> {\r\n        const fps = this.parent.targetFps;\r\n        const invfps = 1 / fps;\r\n\r\n        const sampler = ArrayItem.Get(`${context}/sampler`, animation.samplers, channel.sampler);\r\n        return this._loadAnimationSamplerAsync(`${animationContext}/samplers/${channel.sampler}`, sampler).then((data) => {\r\n            let numAnimations = 0;\r\n\r\n            const target = targetInfo.object;\r\n            const propertyInfos = targetInfo.info;\r\n            // Extract the corresponding values from the read value.\r\n            // GLTF values may be dispatched to several Babylon properties.\r\n            // For example, baseColorFactor [`r`, `g`, `b`, `a`] is dispatched to\r\n            // - albedoColor as Color3(`r`, `g`, `b`)\r\n            // - alpha as `a`\r\n            for (const propertyInfo of propertyInfos) {\r\n                const stride = propertyInfo.getStride(target);\r\n                const input = data.input;\r\n                const output = data.output;\r\n                const keys = new Array<IAnimationKey>(input.length);\r\n                let outputOffset = 0;\r\n\r\n                switch (data.interpolation) {\r\n                    case AnimationSamplerInterpolation.STEP: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                                interpolation: AnimationKeyInterpolation.STEP,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const inTangent = propertyInfo.getValue(target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n                            const outTangent = propertyInfo.getValue(target, output, outputOffset, invfps);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                inTangent: inTangent,\r\n                                value: value,\r\n                                outTangent: outTangent,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                    case AnimationSamplerInterpolation.LINEAR: {\r\n                        for (let index = 0; index < input.length; index++) {\r\n                            const value = propertyInfo.getValue(target, output, outputOffset, 1);\r\n                            outputOffset += stride;\r\n\r\n                            keys[index] = {\r\n                                frame: input[index] * fps,\r\n                                value: value,\r\n                            };\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (outputOffset > 0) {\r\n                    const name = `${animation.name || `animation${animation.index}`}_channel${channel.index}_${numAnimations}`;\r\n                    const babylonAnimations = propertyInfo.buildAnimations(target, name, fps, keys);\r\n                    for (const babylonAnimation of babylonAnimations) {\r\n                        numAnimations++;\r\n                        onLoad(babylonAnimation.babylonAnimatable, babylonAnimation.babylonAnimation);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadAnimationSamplerAsync(context: string, sampler: IAnimationSampler): Promise<_IAnimationSamplerData> {\r\n        if (sampler._data) {\r\n            return sampler._data;\r\n        }\r\n\r\n        const interpolation = sampler.interpolation || AnimationSamplerInterpolation.LINEAR;\r\n        switch (interpolation) {\r\n            case AnimationSamplerInterpolation.STEP:\r\n            case AnimationSamplerInterpolation.LINEAR:\r\n            case AnimationSamplerInterpolation.CUBICSPLINE: {\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/interpolation: Invalid value (${sampler.interpolation})`);\r\n            }\r\n        }\r\n\r\n        const inputAccessor = ArrayItem.Get(`${context}/input`, this._gltf.accessors, sampler.input);\r\n        const outputAccessor = ArrayItem.Get(`${context}/output`, this._gltf.accessors, sampler.output);\r\n        sampler._data = Promise.all([\r\n            this._loadFloatAccessorAsync(`/accessors/${inputAccessor.index}`, inputAccessor),\r\n            this._loadFloatAccessorAsync(`/accessors/${outputAccessor.index}`, outputAccessor),\r\n        ]).then(([inputData, outputData]) => {\r\n            return {\r\n                input: inputData,\r\n                interpolation: interpolation,\r\n                output: outputData,\r\n            };\r\n        });\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer.\r\n     * @param context The context when loading the asset\r\n     * @param buffer The glTF buffer property\r\n     * @param byteOffset The byte offset to use\r\n     * @param byteLength The byte length to use\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferAsync(context, buffer, byteOffset, byteLength);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!buffer._data) {\r\n            if (buffer.uri) {\r\n                buffer._data = this.loadUriAsync(`${context}/uri`, buffer, buffer.uri);\r\n            } else {\r\n                if (!this._bin) {\r\n                    throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\r\n                }\r\n\r\n                buffer._data = this._bin.readAsync(0, buffer.byteLength);\r\n            }\r\n        }\r\n\r\n        return buffer._data.then((data) => {\r\n            try {\r\n                return new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);\r\n            } catch (e) {\r\n                throw new Error(`${context}: ${e.message}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF buffer view.\r\n     * @param context The context when loading the asset\r\n     * @param bufferView The glTF buffer view property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadBufferViewAsync(context: string, bufferView: IBufferView): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadBufferViewAsync(context, bufferView);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (bufferView._data) {\r\n            return bufferView._data;\r\n        }\r\n\r\n        const buffer = ArrayItem.Get(`${context}/buffer`, this._gltf.buffers, bufferView.buffer);\r\n        bufferView._data = this.loadBufferAsync(`/buffers/${buffer.index}`, buffer, bufferView.byteOffset || 0, bufferView.byteLength);\r\n\r\n        return bufferView._data;\r\n    }\r\n\r\n    private _loadAccessorAsync(context: string, accessor: IAccessor, constructor: TypedArrayConstructor): Promise<ArrayBufferView> {\r\n        if (accessor._data) {\r\n            return accessor._data;\r\n        }\r\n\r\n        const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n        const byteStride = numComponents * VertexBuffer.GetTypeByteLength(accessor.componentType);\r\n        const length = numComponents * accessor.count;\r\n\r\n        if (accessor.bufferView == undefined) {\r\n            accessor._data = Promise.resolve(new constructor(length));\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized && (!bufferView.byteStride || bufferView.byteStride === byteStride)) {\r\n                    return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, length);\r\n                } else {\r\n                    const typedArray = new constructor(length);\r\n                    VertexBuffer.ForEach(\r\n                        data,\r\n                        accessor.byteOffset || 0,\r\n                        bufferView.byteStride || byteStride,\r\n                        numComponents,\r\n                        accessor.componentType,\r\n                        typedArray.length,\r\n                        accessor.normalized || false,\r\n                        (value, index) => {\r\n                            typedArray[index] = value;\r\n                        }\r\n                    );\r\n                    return typedArray;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const sparse = accessor.sparse;\r\n            accessor._data = accessor._data.then((data) => {\r\n                const typedArray = data as TypedArray;\r\n                const indicesBufferView = ArrayItem.Get(`${context}/sparse/indices/bufferView`, this._gltf.bufferViews, sparse.indices.bufferView);\r\n                const valuesBufferView = ArrayItem.Get(`${context}/sparse/values/bufferView`, this._gltf.bufferViews, sparse.values.bufferView);\r\n                return Promise.all([\r\n                    this.loadBufferViewAsync(`/bufferViews/${indicesBufferView.index}`, indicesBufferView),\r\n                    this.loadBufferViewAsync(`/bufferViews/${valuesBufferView.index}`, valuesBufferView),\r\n                ]).then(([indicesData, valuesData]) => {\r\n                    const indices = GLTFLoader._GetTypedArray(\r\n                        `${context}/sparse/indices`,\r\n                        sparse.indices.componentType,\r\n                        indicesData,\r\n                        sparse.indices.byteOffset,\r\n                        sparse.count\r\n                    ) as IndicesArray;\r\n\r\n                    const sparseLength = numComponents * sparse.count;\r\n                    let values: TypedArray;\r\n\r\n                    if (accessor.componentType === AccessorComponentType.FLOAT && !accessor.normalized) {\r\n                        values = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                    } else {\r\n                        const sparseData = GLTFLoader._GetTypedArray(`${context}/sparse/values`, accessor.componentType, valuesData, sparse.values.byteOffset, sparseLength);\r\n                        values = new constructor(sparseLength);\r\n                        VertexBuffer.ForEach(sparseData, 0, byteStride, numComponents, accessor.componentType, values.length, accessor.normalized || false, (value, index) => {\r\n                            values[index] = value;\r\n                        });\r\n                    }\r\n\r\n                    let valuesIndex = 0;\r\n                    for (let indicesIndex = 0; indicesIndex < indices.length; indicesIndex++) {\r\n                        let dataIndex = indices[indicesIndex] * numComponents;\r\n                        for (let componentIndex = 0; componentIndex < numComponents; componentIndex++) {\r\n                            typedArray[dataIndex++] = values[valuesIndex++];\r\n                        }\r\n                    }\r\n\r\n                    return typedArray;\r\n                });\r\n            });\r\n        }\r\n\r\n        return accessor._data;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadFloatAccessorAsync(context: string, accessor: IAccessor): Promise<Float32Array> {\r\n        return this._loadAccessorAsync(context, accessor, Float32Array) as Promise<Float32Array>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadIndicesAccessorAsync(context: string, accessor: IAccessor): Promise<IndicesArray> {\r\n        if (accessor.type !== AccessorType.SCALAR) {\r\n            throw new Error(`${context}/type: Invalid value ${accessor.type}`);\r\n        }\r\n\r\n        if (\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_BYTE &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_SHORT &&\r\n            accessor.componentType !== AccessorComponentType.UNSIGNED_INT\r\n        ) {\r\n            throw new Error(`${context}/componentType: Invalid value ${accessor.componentType}`);\r\n        }\r\n\r\n        if (accessor._data) {\r\n            return accessor._data as Promise<IndicesArray>;\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, accessor.componentType);\r\n            accessor._data = this._loadAccessorAsync(context, accessor, constructor);\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n                return GLTFLoader._GetTypedArray(context, accessor.componentType, data, accessor.byteOffset, accessor.count);\r\n            });\r\n        }\r\n\r\n        return accessor._data as Promise<IndicesArray>;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexBufferViewAsync(bufferView: IBufferView): Promise<Buffer> {\r\n        if (bufferView._babylonBuffer) {\r\n            return bufferView._babylonBuffer;\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n        bufferView._babylonBuffer = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView).then((data) => {\r\n            return new Buffer(engine, data, false);\r\n        });\r\n\r\n        return bufferView._babylonBuffer;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadVertexAccessorAsync(context: string, accessor: IAccessor, kind: string): Promise<VertexBuffer> {\r\n        if (accessor._babylonVertexBuffer?.[kind]) {\r\n            return accessor._babylonVertexBuffer[kind];\r\n        }\r\n\r\n        if (!accessor._babylonVertexBuffer) {\r\n            accessor._babylonVertexBuffer = {};\r\n        }\r\n\r\n        const engine = this._babylonScene.getEngine();\r\n\r\n        if (accessor.sparse || accessor.bufferView == undefined) {\r\n            accessor._babylonVertexBuffer[kind] = this._loadFloatAccessorAsync(context, accessor).then((data) => {\r\n                return new VertexBuffer(engine, data, kind, false);\r\n            });\r\n        } else {\r\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, accessor.bufferView);\r\n            accessor._babylonVertexBuffer[kind] = this._loadVertexBufferViewAsync(bufferView).then((babylonBuffer) => {\r\n                const numComponents = GLTFLoader._GetNumComponents(context, accessor.type);\r\n                return new VertexBuffer(\r\n                    engine,\r\n                    babylonBuffer,\r\n                    kind,\r\n                    false,\r\n                    undefined,\r\n                    bufferView.byteStride,\r\n                    undefined,\r\n                    accessor.byteOffset,\r\n                    numComponents,\r\n                    accessor.componentType,\r\n                    accessor.normalized,\r\n                    true,\r\n                    undefined,\r\n                    true\r\n                );\r\n            });\r\n        }\r\n\r\n        return accessor._babylonVertexBuffer[kind];\r\n    }\r\n\r\n    private _loadMaterialMetallicRoughnessPropertiesAsync(context: string, properties: IMaterialPbrMetallicRoughness, babylonMaterial: Material): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        if (properties) {\r\n            // Set base color and alpha using adapter\r\n            if (properties.baseColorFactor) {\r\n                adapter.baseColor = Color3.FromArray(properties.baseColorFactor);\r\n                adapter.geometryOpacity = properties.baseColorFactor[3];\r\n            } else {\r\n                adapter.baseColor = Color3.White();\r\n            }\r\n\r\n            // Set metallic and roughness using adapter\r\n            adapter.baseMetalness = properties.metallicFactor == undefined ? 1 : properties.metallicFactor;\r\n            adapter.specularRoughness = properties.roughnessFactor == undefined ? 1 : properties.roughnessFactor;\r\n\r\n            if (properties.baseColorTexture) {\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/baseColorTexture`, properties.baseColorTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Base Color)`;\r\n                        adapter.baseColorTexture = texture;\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (properties.metallicRoughnessTexture) {\r\n                properties.metallicRoughnessTexture.nonColorData = true;\r\n                promises.push(\r\n                    this.loadTextureInfoAsync(`${context}/metallicRoughnessTexture`, properties.metallicRoughnessTexture, (texture) => {\r\n                        texture.name = `${babylonMaterial.name} (Metallic Roughness)`;\r\n                        adapter.baseMetalnessTexture = texture;\r\n                        adapter.specularRoughnessTexture = texture;\r\n                    })\r\n                );\r\n\r\n                // Configure texture channel usage using adapter\r\n                adapter.useRoughnessFromMetallicTextureGreen = true;\r\n                adapter.useMetallicFromMetallicTextureBlue = true;\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void = () => {}\r\n    ): Promise<Material> {\r\n        const extensionPromise = this._extensionsLoadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        material._data = material._data || {};\r\n        let babylonData = material._data[babylonDrawMode];\r\n        if (!babylonData) {\r\n            this.logOpen(`${context} ${material.name || \"\"}`);\r\n\r\n            const babylonMaterial = this.createMaterial(context, material, babylonDrawMode);\r\n\r\n            babylonData = {\r\n                babylonMaterial: babylonMaterial,\r\n                babylonMeshes: [],\r\n                promise: this.loadMaterialPropertiesAsync(context, material, babylonMaterial),\r\n            };\r\n\r\n            material._data[babylonDrawMode] = babylonData;\r\n\r\n            GLTFLoader.AddPointerMetadata(babylonMaterial, context);\r\n            this._parent.onMaterialLoadedObservable.notifyObservers(babylonMaterial);\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        if (babylonMesh) {\r\n            babylonData.babylonMeshes.push(babylonMesh);\r\n\r\n            babylonMesh.onDisposeObservable.addOnce(() => {\r\n                const index = babylonData.babylonMeshes.indexOf(babylonMesh);\r\n                if (index !== -1) {\r\n                    babylonData.babylonMeshes.splice(index, 1);\r\n                }\r\n            });\r\n        }\r\n\r\n        assign(babylonData.babylonMaterial);\r\n\r\n        return babylonData.promise.then(() => {\r\n            return babylonData.babylonMaterial;\r\n        });\r\n    }\r\n\r\n    private _createDefaultMaterial(name: string, babylonDrawMode: number): Material {\r\n        if (!this._pbrMaterialImpl) {\r\n            throw new Error(\"PBR Material class not loaded\");\r\n        }\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const babylonMaterial = new this._pbrMaterialImpl.materialClass(name, this._babylonScene);\r\n        babylonMaterial._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        babylonMaterial.fillMode = babylonDrawMode;\r\n        babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_OPAQUE;\r\n        // Create the material adapter and set some default properties.\r\n        // We don't need to wait for the promise to resolve here.\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n        adapter.transparencyAsAlphaCoverage = this._parent.transparencyAsCoverage;\r\n\r\n        // Set default metallic and roughness values\r\n        adapter.baseMetalness = 1.0;\r\n        adapter.specularRoughness = 1.0;\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Creates a Babylon material from a glTF material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonDrawMode The draw mode for the Babylon material\r\n     * @returns The Babylon material\r\n     */\r\n    public createMaterial(context: string, material: IMaterial, babylonDrawMode: number): Material {\r\n        const extensionMaterial = this._extensionsCreateMaterial(context, material, babylonDrawMode);\r\n        if (extensionMaterial) {\r\n            return extensionMaterial;\r\n        }\r\n\r\n        const name = material.name || `material${material.index}`;\r\n        const babylonMaterial = this._createDefaultMaterial(name, babylonDrawMode);\r\n\r\n        return babylonMaterial;\r\n    }\r\n\r\n    /**\r\n     * Loads properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const extensionPromise = this._extensionsLoadMaterialPropertiesAsync(context, material, babylonMaterial);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        promises.push(this.loadMaterialBasePropertiesAsync(context, material, babylonMaterial));\r\n\r\n        if (material.pbrMetallicRoughness) {\r\n            promises.push(this._loadMaterialMetallicRoughnessPropertiesAsync(`${context}/pbrMetallicRoughness`, material.pbrMetallicRoughness, babylonMaterial));\r\n        }\r\n\r\n        this.loadMaterialAlphaProperties(context, material, babylonMaterial);\r\n\r\n        return Promise.all(promises).then(() => {});\r\n    }\r\n\r\n    /**\r\n     * Loads the normal, occlusion, and emissive properties from a glTF material into a Babylon material.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     * @returns A promise that resolves when the load is complete\r\n     */\r\n    public loadMaterialBasePropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<void> {\r\n        const promises = new Array<Promise<unknown>>();\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n\r\n        // Set emission color using adapter\r\n        adapter.emissionColor = material.emissiveFactor ? Color3.FromArray(material.emissiveFactor) : new Color3(0, 0, 0);\r\n\r\n        // Set double-sided properties using adapter\r\n        if (material.doubleSided) {\r\n            adapter.backFaceCulling = false;\r\n            adapter.twoSidedLighting = true;\r\n        }\r\n\r\n        if (material.normalTexture) {\r\n            material.normalTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/normalTexture`, material.normalTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Normal)`;\r\n                    adapter.geometryNormalTexture = texture;\r\n                    if (material.normalTexture?.scale != undefined) {\r\n                        texture.level = material.normalTexture.scale;\r\n                    }\r\n                })\r\n            );\r\n\r\n            // Set normal map inversions using adapter\r\n            adapter.setNormalMapInversions(!this._babylonScene.useRightHandedSystem, this._babylonScene.useRightHandedSystem);\r\n        }\r\n\r\n        let aoTexture: BaseTexture;\r\n        let aoStrength: number = 1.0;\r\n        let emissionTexture: BaseTexture;\r\n\r\n        if (material.occlusionTexture) {\r\n            material.occlusionTexture.nonColorData = true;\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/occlusionTexture`, material.occlusionTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Occlusion)`;\r\n                    aoTexture = texture;\r\n                })\r\n            );\r\n\r\n            if (material.occlusionTexture.strength != undefined) {\r\n                aoStrength = material.occlusionTexture.strength;\r\n            }\r\n        }\r\n\r\n        if (material.emissiveTexture) {\r\n            promises.push(\r\n                this.loadTextureInfoAsync(`${context}/emissiveTexture`, material.emissiveTexture, (texture) => {\r\n                    texture.name = `${babylonMaterial.name} (Emissive)`;\r\n                    emissionTexture = texture;\r\n                })\r\n            );\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            // Set ambient occlusion and emissive textures using adapter\r\n            if (aoTexture) {\r\n                adapter.ambientOcclusionTexture = aoTexture;\r\n                adapter.ambientOcclusionTextureStrength = aoStrength;\r\n            }\r\n\r\n            if (emissionTexture) {\r\n                adapter.emissionColorTexture = emissionTexture;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Loads the alpha properties from a glTF material into a Babylon material.\r\n     * Must be called after the setting the albedo texture of the Babylon material when the material has an albedo texture.\r\n     * @param context The context when loading the asset\r\n     * @param material The glTF material property\r\n     * @param babylonMaterial The Babylon material\r\n     */\r\n    public loadMaterialAlphaProperties(context: string, material: IMaterial, babylonMaterial: Material): void {\r\n        if (!this._pbrMaterialImpl) {\r\n            throw new Error(`${context}: Material type not supported`);\r\n        }\r\n\r\n        const adapter = this._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const baseColorTexture = adapter.baseColorTexture;\r\n\r\n        const alphaMode = material.alphaMode || MaterialAlphaMode.OPAQUE;\r\n        switch (alphaMode) {\r\n            case MaterialAlphaMode.OPAQUE: {\r\n                babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_OPAQUE;\r\n                babylonMaterial.alpha = 1.0; // Force alpha to 1.0 for opaque mode.\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.MASK: {\r\n                babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_ALPHATEST;\r\n                adapter.alphaCutOff = material.alphaCutoff == undefined ? 0.5 : material.alphaCutoff;\r\n                if (baseColorTexture) {\r\n                    baseColorTexture.hasAlpha = true;\r\n                }\r\n                break;\r\n            }\r\n            case MaterialAlphaMode.BLEND: {\r\n                babylonMaterial.transparencyMode = this._pbrMaterialImpl.materialClass.MATERIAL_ALPHABLEND;\r\n                if (baseColorTexture) {\r\n                    baseColorTexture.hasAlpha = true;\r\n                    adapter.useAlphaFromBaseColorTexture = true;\r\n                }\r\n                break;\r\n            }\r\n            default: {\r\n                throw new Error(`${context}/alphaMode: Invalid value (${material.alphaMode})`);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF texture info.\r\n     * @param context The context when loading the asset\r\n     * @param textureInfo The glTF texture info property\r\n     * @param assign A function called synchronously after parsing the glTF properties\r\n     * @returns A promise that resolves with the loaded Babylon texture when the load is complete\r\n     */\r\n    public loadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureInfoAsync(context, textureInfo, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context}`);\r\n\r\n        if (textureInfo.texCoord! >= 6) {\r\n            throw new Error(`${context}/texCoord: Invalid value (${textureInfo.texCoord})`);\r\n        }\r\n\r\n        const texture = ArrayItem.Get(`${context}/index`, this._gltf.textures, textureInfo.index);\r\n        texture._textureInfo = textureInfo;\r\n\r\n        const promise = this._loadTextureAsync(`/textures/${textureInfo.index}`, texture, (babylonTexture) => {\r\n            babylonTexture.coordinatesIndex = textureInfo.texCoord || 0;\r\n            GLTFLoader.AddPointerMetadata(babylonTexture, context);\r\n            this._parent.onTextureLoadedObservable.notifyObservers(babylonTexture);\r\n            assign(babylonTexture);\r\n        });\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _loadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void = () => {}): Promise<BaseTexture> {\r\n        const extensionPromise = this._extensionsLoadTextureAsync(context, texture, assign);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        this.logOpen(`${context} ${texture.name || \"\"}`);\r\n\r\n        const sampler = texture.sampler == undefined ? GLTFLoader.DefaultSampler : ArrayItem.Get(`${context}/sampler`, this._gltf.samplers, texture.sampler);\r\n        const image = ArrayItem.Get(`${context}/source`, this._gltf.images, texture.source);\r\n        const promise = this._createTextureAsync(context, sampler, image, assign, undefined, !texture._textureInfo.nonColorData);\r\n\r\n        this.logClose();\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public _createTextureAsync(\r\n        context: string,\r\n        sampler: ISampler,\r\n        image: IImage,\r\n        assign: (babylonTexture: BaseTexture) => void = () => {},\r\n        textureLoaderOptions?: unknown,\r\n        useSRGBBuffer?: boolean\r\n    ): Promise<BaseTexture> {\r\n        const samplerData = this._loadSampler(`/samplers/${sampler.index}`, sampler);\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const deferred = new Deferred<void>();\r\n        this._babylonScene._blockEntityCollection = !!this._assetContainer;\r\n        const textureCreationOptions: ITextureCreationOptions = {\r\n            noMipmap: samplerData.noMipMaps,\r\n            invertY: false,\r\n            samplingMode: samplerData.samplingMode,\r\n            onLoad: () => {\r\n                if (!this._disposed) {\r\n                    deferred.resolve();\r\n                }\r\n            },\r\n            onError: (message?: string, exception?: any) => {\r\n                if (!this._disposed) {\r\n                    deferred.reject(new Error(`${context}: ${exception && exception.message ? exception.message : message || \"Failed to load texture\"}`));\r\n                }\r\n            },\r\n            mimeType: image.mimeType ?? GetMimeType(image.uri ?? \"\"),\r\n            loaderOptions: textureLoaderOptions,\r\n            useSRGBBuffer: !!useSRGBBuffer && this._parent.useSRGBBuffers,\r\n        };\r\n        const babylonTexture = new Texture(null, this._babylonScene, textureCreationOptions);\r\n        babylonTexture._parentContainer = this._assetContainer;\r\n        this._babylonScene._blockEntityCollection = false;\r\n        promises.push(deferred.promise);\r\n\r\n        promises.push(\r\n            this.loadImageAsync(`/images/${image.index}`, image).then((data) => {\r\n                const name = image.uri || `${this._fileName}#image${image.index}`;\r\n                const dataUrl = `data:${this._uniqueRootUrl}${name}`;\r\n                babylonTexture.updateURL(dataUrl, data);\r\n\r\n                // Set the internal texture label.\r\n                const internalTexture = babylonTexture.getInternalTexture();\r\n                if (internalTexture) {\r\n                    internalTexture.label = image.name;\r\n                }\r\n            })\r\n        );\r\n\r\n        babylonTexture.wrapU = samplerData.wrapU;\r\n        babylonTexture.wrapV = samplerData.wrapV;\r\n        assign(babylonTexture);\r\n\r\n        if (this._parent.useGltfTextureNames) {\r\n            babylonTexture.name = image.name || image.uri || `image${image.index}`;\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            return babylonTexture;\r\n        });\r\n    }\r\n\r\n    private _loadSampler(context: string, sampler: ISampler): _ISamplerData {\r\n        if (!sampler._data) {\r\n            sampler._data = {\r\n                noMipMaps: sampler.minFilter === TextureMinFilter.NEAREST || sampler.minFilter === TextureMinFilter.LINEAR,\r\n                samplingMode: GLTFLoader._GetTextureSamplingMode(context, sampler),\r\n                wrapU: GLTFLoader._GetTextureWrapMode(`${context}/wrapS`, sampler.wrapS),\r\n                wrapV: GLTFLoader._GetTextureWrapMode(`${context}/wrapT`, sampler.wrapT),\r\n            };\r\n        }\r\n\r\n        return sampler._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF image.\r\n     * @param context The context when loading the asset\r\n     * @param image The glTF image property\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadImageAsync(context: string, image: IImage): Promise<ArrayBufferView> {\r\n        if (!image._data) {\r\n            this.logOpen(`${context} ${image.name || \"\"}`);\r\n\r\n            if (image.uri) {\r\n                image._data = this.loadUriAsync(`${context}/uri`, image, image.uri);\r\n            } else {\r\n                const bufferView = ArrayItem.Get(`${context}/bufferView`, this._gltf.bufferViews, image.bufferView);\r\n                image._data = this.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\r\n            }\r\n\r\n            this.logClose();\r\n        }\r\n\r\n        return image._data;\r\n    }\r\n\r\n    /**\r\n     * Loads a glTF uri.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property associated with the uri\r\n     * @param uri The base64 or relative uri\r\n     * @returns A promise that resolves with the loaded data when the load is complete\r\n     */\r\n    public loadUriAsync(context: string, property: IProperty, uri: string): Promise<ArrayBufferView> {\r\n        const extensionPromise = this._extensionsLoadUriAsync(context, property, uri);\r\n        if (extensionPromise) {\r\n            return extensionPromise;\r\n        }\r\n\r\n        if (!GLTFLoader._ValidateUri(uri)) {\r\n            throw new Error(`${context}: '${uri}' is invalid`);\r\n        }\r\n\r\n        if (IsBase64DataUrl(uri)) {\r\n            const data = new Uint8Array(DecodeBase64UrlToBinary(uri));\r\n            this.log(`${context}: Decoded ${uri.substring(0, 64)}... (${data.length} bytes)`);\r\n            return Promise.resolve(data);\r\n        }\r\n\r\n        this.log(`${context}: Loading ${uri}`);\r\n\r\n        return this._parent.preprocessUrlAsync(this._rootUrl + uri).then((url) => {\r\n            return new Promise((resolve, reject) => {\r\n                this._parent._loadFile(\r\n                    this._babylonScene,\r\n                    url,\r\n                    (data) => {\r\n                        if (!this._disposed) {\r\n                            this.log(`${context}: Loaded ${uri} (${(data as ArrayBuffer).byteLength} bytes)`);\r\n                            resolve(new Uint8Array(data as ArrayBuffer));\r\n                        }\r\n                    },\r\n                    true,\r\n                    (request) => {\r\n                        reject(new LoadFileError(`${context}: Failed to load '${uri}'${request ? \": \" + request.status + \" \" + request.statusText : \"\"}`, request));\r\n                    }\r\n                );\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Adds a JSON pointer to the _internalMetadata of the Babylon object at `<object>._internalMetadata.gltf.pointers`.\r\n     * @param babylonObject the Babylon object with _internalMetadata\r\n     * @param pointer the JSON pointer\r\n     */\r\n    public static AddPointerMetadata(babylonObject: IWithMetadata, pointer: string): void {\r\n        babylonObject.metadata = babylonObject.metadata || {};\r\n        const metadata = (babylonObject._internalMetadata = babylonObject._internalMetadata || {});\r\n        const gltf = (metadata.gltf = metadata.gltf || {});\r\n        const pointers = (gltf.pointers = gltf.pointers || []);\r\n        pointers.push(pointer);\r\n    }\r\n\r\n    private static _GetTextureWrapMode(context: string, mode: TextureWrapMode | undefined): number {\r\n        // Set defaults if undefined\r\n        mode = mode == undefined ? TextureWrapMode.REPEAT : mode;\r\n\r\n        switch (mode) {\r\n            case TextureWrapMode.CLAMP_TO_EDGE:\r\n                return Texture.CLAMP_ADDRESSMODE;\r\n            case TextureWrapMode.MIRRORED_REPEAT:\r\n                return Texture.MIRROR_ADDRESSMODE;\r\n            case TextureWrapMode.REPEAT:\r\n                return Texture.WRAP_ADDRESSMODE;\r\n            default:\r\n                Logger.Warn(`${context}: Invalid value (${mode})`);\r\n                return Texture.WRAP_ADDRESSMODE;\r\n        }\r\n    }\r\n\r\n    private static _GetTextureSamplingMode(context: string, sampler: ISampler): number {\r\n        // Set defaults if undefined\r\n        const magFilter = sampler.magFilter == undefined ? TextureMagFilter.LINEAR : sampler.magFilter;\r\n        const minFilter = sampler.minFilter == undefined ? TextureMinFilter.LINEAR_MIPMAP_LINEAR : sampler.minFilter;\r\n\r\n        if (magFilter === TextureMagFilter.LINEAR) {\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.LINEAR_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.LINEAR_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.LINEAR_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.LINEAR_LINEAR_MIPLINEAR;\r\n            }\r\n        } else {\r\n            if (magFilter !== TextureMagFilter.NEAREST) {\r\n                Logger.Warn(`${context}/magFilter: Invalid value (${magFilter})`);\r\n            }\r\n\r\n            switch (minFilter) {\r\n                case TextureMinFilter.NEAREST:\r\n                    return Texture.NEAREST_NEAREST;\r\n                case TextureMinFilter.LINEAR:\r\n                    return Texture.NEAREST_LINEAR;\r\n                case TextureMinFilter.NEAREST_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n                case TextureMinFilter.LINEAR_MIPMAP_NEAREST:\r\n                    return Texture.NEAREST_LINEAR_MIPNEAREST;\r\n                case TextureMinFilter.NEAREST_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_NEAREST_MIPLINEAR;\r\n                case TextureMinFilter.LINEAR_MIPMAP_LINEAR:\r\n                    return Texture.NEAREST_LINEAR_MIPLINEAR;\r\n                default:\r\n                    Logger.Warn(`${context}/minFilter: Invalid value (${minFilter})`);\r\n                    return Texture.NEAREST_NEAREST_MIPNEAREST;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArrayConstructor(context: string, componentType: AccessorComponentType): TypedArrayConstructor {\r\n        try {\r\n            return GetTypedArrayConstructor(componentType);\r\n        } catch (e) {\r\n            throw new Error(`${context}: ${e.message}`);\r\n        }\r\n    }\r\n\r\n    private static _GetTypedArray(context: string, componentType: AccessorComponentType, bufferView: ArrayBufferView, byteOffset: number | undefined, length: number): TypedArray {\r\n        const buffer = bufferView.buffer;\r\n        byteOffset = bufferView.byteOffset + (byteOffset || 0);\r\n\r\n        const constructor = GLTFLoader._GetTypedArrayConstructor(`${context}/componentType`, componentType);\r\n\r\n        const componentTypeLength = VertexBuffer.GetTypeByteLength(componentType);\r\n        if (byteOffset % componentTypeLength !== 0) {\r\n            // HACK: Copy the buffer if byte offset is not a multiple of component type byte length.\r\n            Logger.Warn(`${context}: Copying buffer as byte offset (${byteOffset}) is not a multiple of component type byte length (${componentTypeLength})`);\r\n            return new constructor(buffer.slice(byteOffset, byteOffset + length * componentTypeLength), 0);\r\n        }\r\n\r\n        return new constructor(buffer, byteOffset, length);\r\n    }\r\n\r\n    private static _GetNumComponents(context: string, type: string): number {\r\n        switch (type) {\r\n            case \"SCALAR\":\r\n                return 1;\r\n            case \"VEC2\":\r\n                return 2;\r\n            case \"VEC3\":\r\n                return 3;\r\n            case \"VEC4\":\r\n                return 4;\r\n            case \"MAT2\":\r\n                return 4;\r\n            case \"MAT3\":\r\n                return 9;\r\n            case \"MAT4\":\r\n                return 16;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid type (${type})`);\r\n    }\r\n\r\n    private static _ValidateUri(uri: string): boolean {\r\n        return Tools.IsBase64(uri) || uri.indexOf(\"..\") === -1;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _GetDrawMode(context: string, mode: number | undefined): number {\r\n        if (mode == undefined) {\r\n            mode = MeshPrimitiveMode.TRIANGLES;\r\n        }\r\n\r\n        switch (mode) {\r\n            case MeshPrimitiveMode.POINTS:\r\n                return Material.PointListDrawMode;\r\n            case MeshPrimitiveMode.LINES:\r\n                return Material.LineListDrawMode;\r\n            case MeshPrimitiveMode.LINE_LOOP:\r\n                return Material.LineLoopDrawMode;\r\n            case MeshPrimitiveMode.LINE_STRIP:\r\n                return Material.LineStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLES:\r\n                return Material.TriangleFillMode;\r\n            case MeshPrimitiveMode.TRIANGLE_STRIP:\r\n                return Material.TriangleStripDrawMode;\r\n            case MeshPrimitiveMode.TRIANGLE_FAN:\r\n                return Material.TriangleFanDrawMode;\r\n        }\r\n\r\n        throw new Error(`${context}: Invalid mesh primitive mode (${mode})`);\r\n    }\r\n\r\n    private _compileMaterialsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile materials\");\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        if (this._gltf.materials) {\r\n            for (const material of this._gltf.materials) {\r\n                if (material._data) {\r\n                    for (const babylonDrawMode in material._data) {\r\n                        const babylonData = material._data[babylonDrawMode];\r\n                        for (const babylonMesh of babylonData.babylonMeshes) {\r\n                            // Ensure nonUniformScaling is set if necessary.\r\n                            babylonMesh.computeWorldMatrix(true);\r\n\r\n                            const babylonMaterial = babylonData.babylonMaterial;\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh));\r\n                            promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { useInstances: true }));\r\n                            if (this._parent.useClipPlane) {\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true }));\r\n                                promises.push(babylonMaterial.forceCompilationAsync(babylonMesh, { clipPlane: true, useInstances: true }));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile materials\");\r\n        });\r\n    }\r\n\r\n    private _compileShadowGeneratorsAsync(): Promise<void> {\r\n        this._parent._startPerformanceCounter(\"Compile shadow generators\");\r\n\r\n        const promises = new Array<Promise<unknown>>();\r\n\r\n        const lights = this._babylonScene.lights;\r\n        for (const light of lights) {\r\n            const generator = light.getShadowGenerator();\r\n            if (generator) {\r\n                promises.push(generator.forceCompilationAsync());\r\n            }\r\n        }\r\n\r\n        return Promise.all(promises).then(() => {\r\n            this._parent._endPerformanceCounter(\"Compile shadow generators\");\r\n        });\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFLoaderExtension) => void): void {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _applyExtensions<T>(property: IProperty, functionName: string, actionAsync: (extension: IGLTFLoaderExtension) => Nullable<T> | undefined): Nullable<T> {\r\n        for (const extension of this._extensions) {\r\n            if (extension.enabled) {\r\n                const id = `${extension.name}.${functionName}`;\r\n                const loaderProperty = property as ILoaderProperty;\r\n                loaderProperty._activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions || {};\r\n                const activeLoaderExtensionFunctions = loaderProperty._activeLoaderExtensionFunctions;\r\n                if (!activeLoaderExtensionFunctions[id]) {\r\n                    activeLoaderExtensionFunctions[id] = true;\r\n\r\n                    try {\r\n                        const result = actionAsync(extension);\r\n                        if (result) {\r\n                            return result;\r\n                        }\r\n                    } finally {\r\n                        delete activeLoaderExtensionFunctions[id];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private _extensionsOnLoading(): void {\r\n        this._forEachExtensions((extension) => extension.onLoading && extension.onLoading());\r\n    }\r\n\r\n    private _extensionsOnReady(): void {\r\n        this._forEachExtensions((extension) => extension.onReady && extension.onReady());\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadSceneAsync(context: string, scene: IScene): Nullable<Promise<void>> {\r\n        return this._applyExtensions(scene, \"loadScene\", (extension) => extension.loadSceneAsync && extension.loadSceneAsync(context, scene));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadNodeAsync(context: string, node: INode, assign: (babylonTransformNode: TransformNode) => void): Nullable<Promise<TransformNode>> {\r\n        return this._applyExtensions(node, \"loadNode\", (extension) => extension.loadNodeAsync && extension.loadNodeAsync(context, node, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadCameraAsync(context: string, camera: ICamera, assign: (babylonCamera: Camera) => void): Nullable<Promise<Camera>> {\r\n        return this._applyExtensions(camera, \"loadCamera\", (extension) => extension.loadCameraAsync && extension.loadCameraAsync(context, camera, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadVertexDataAsync(context: string, primitive: IMeshPrimitive, babylonMesh: Mesh): Nullable<Promise<Geometry>> {\r\n        return this._applyExtensions(primitive, \"loadVertexData\", (extension) => extension._loadVertexDataAsync && extension._loadVertexDataAsync(context, primitive, babylonMesh));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMeshPrimitiveAsync(\r\n        context: string,\r\n        name: string,\r\n        node: INode,\r\n        mesh: IMesh,\r\n        primitive: IMeshPrimitive,\r\n        assign: (babylonMesh: AbstractMesh) => void\r\n    ): Nullable<Promise<AbstractMesh>> {\r\n        return this._applyExtensions(\r\n            primitive,\r\n            \"loadMeshPrimitive\",\r\n            (extension) => extension._loadMeshPrimitiveAsync && extension._loadMeshPrimitiveAsync(context, name, node, mesh, primitive, assign)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMaterialAsync(\r\n        context: string,\r\n        material: IMaterial,\r\n        babylonMesh: Nullable<Mesh>,\r\n        babylonDrawMode: number,\r\n        assign: (babylonMaterial: Material) => void\r\n    ): Nullable<Promise<Material>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterial\",\r\n            (extension) => extension._loadMaterialAsync && extension._loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign)\r\n        );\r\n    }\r\n\r\n    private _extensionsCreateMaterial(context: string, material: IMaterial, babylonDrawMode: number): Nullable<Material> {\r\n        return this._applyExtensions(material, \"createMaterial\", (extension) => extension.createMaterial && extension.createMaterial(context, material, babylonDrawMode));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            material,\r\n            \"loadMaterialProperties\",\r\n            (extension) => extension.loadMaterialPropertiesAsync && extension.loadMaterialPropertiesAsync(context, material, babylonMaterial)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadTextureInfoAsync(context: string, textureInfo: ITextureInfo, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(textureInfo, \"loadTextureInfo\", (extension) => extension.loadTextureInfoAsync && extension.loadTextureInfoAsync(context, textureInfo, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadTextureAsync(context: string, texture: ITexture, assign: (babylonTexture: BaseTexture) => void): Nullable<Promise<BaseTexture>> {\r\n        return this._applyExtensions(texture, \"loadTexture\", (extension) => extension._loadTextureAsync && extension._loadTextureAsync(context, texture, assign));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadAnimationAsync(context: string, animation: IAnimation): Nullable<Promise<AnimationGroup>> {\r\n        return this._applyExtensions(animation, \"loadAnimation\", (extension) => extension.loadAnimationAsync && extension.loadAnimationAsync(context, animation));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadAnimationChannelAsync(\r\n        context: string,\r\n        animationContext: string,\r\n        animation: IAnimation,\r\n        channel: IAnimationChannel,\r\n        onLoad: (babylonAnimatable: IAnimatable, babylonAnimation: Animation) => void\r\n    ): Nullable<Promise<void>> {\r\n        return this._applyExtensions(\r\n            animation,\r\n            \"loadAnimationChannel\",\r\n            (extension) => extension._loadAnimationChannelAsync && extension._loadAnimationChannelAsync(context, animationContext, animation, channel, onLoad)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadSkinAsync(context: string, node: INode, skin: ISkin): Nullable<Promise<void>> {\r\n        return this._applyExtensions(skin, \"loadSkin\", (extension) => extension._loadSkinAsync && extension._loadSkinAsync(context, node, skin));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadUriAsync(context: string, property: IProperty, uri: string): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(property, \"loadUri\", (extension) => extension._loadUriAsync && extension._loadUriAsync(context, property, uri));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadBufferViewAsync(context: string, bufferView: IBufferView): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(bufferView, \"loadBufferView\", (extension) => extension.loadBufferViewAsync && extension.loadBufferViewAsync(context, bufferView));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    private _extensionsLoadBufferAsync(context: string, buffer: IBuffer, byteOffset: number, byteLength: number): Nullable<Promise<ArrayBufferView>> {\r\n        return this._applyExtensions(buffer, \"loadBuffer\", (extension) => extension.loadBufferAsync && extension.loadBufferAsync(context, buffer, byteOffset, byteLength));\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load an glTF extension.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extension from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extension does not exist\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\n    public static LoadExtensionAsync<TExtension = unknown, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extensionContext: string, extension: TExtension) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extensions) {\r\n            return null;\r\n        }\r\n\r\n        const extensions = property.extensions;\r\n\r\n        const extension = extensions[extensionName] as TExtension;\r\n        if (!extension) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extensions/${extensionName}`, extension);\r\n    }\r\n\r\n    /**\r\n     * Helper method called by a loader extension to load a glTF extra.\r\n     * @param context The context when loading the asset\r\n     * @param property The glTF property to load the extra from\r\n     * @param extensionName The name of the extension to load\r\n     * @param actionAsync The action to run\r\n     * @returns The promise returned by actionAsync or null if the extra does not exist\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/naming-convention\r\n    public static LoadExtraAsync<TExtra = unknown, TResult = void>(\r\n        context: string,\r\n        property: IProperty,\r\n        extensionName: string,\r\n        actionAsync: (extraContext: string, extra: TExtra) => Nullable<Promise<TResult>>\r\n    ): Nullable<Promise<TResult>> {\r\n        if (!property.extras) {\r\n            return null;\r\n        }\r\n\r\n        const extras = property.extras;\r\n\r\n        const extra = extras[extensionName] as TExtra;\r\n        if (!extra) {\r\n            return null;\r\n        }\r\n\r\n        return actionAsync(`${context}/extras/${extensionName}`, extra);\r\n    }\r\n\r\n    /**\r\n     * Checks for presence of an extension.\r\n     * @param name The name of the extension to check\r\n     * @returns A boolean indicating the presence of the given extension name in `extensionsUsed`\r\n     */\r\n    public isExtensionUsed(name: string): boolean {\r\n        return !!this._gltf.extensionsUsed && this._gltf.extensionsUsed.indexOf(name) !== -1;\r\n    }\r\n\r\n    /**\r\n     * Increments the indentation level and logs a message.\r\n     * @param message The message to log\r\n     */\r\n    public logOpen(message: string): void {\r\n        this._parent._logOpen(message);\r\n    }\r\n\r\n    /**\r\n     * Decrements the indentation level.\r\n     */\r\n    public logClose(): void {\r\n        this._parent._logClose();\r\n    }\r\n\r\n    /**\r\n     * Logs a message\r\n     * @param message The message to log\r\n     */\r\n    public log(message: string): void {\r\n        this._parent._log(message);\r\n    }\r\n\r\n    /**\r\n     * Starts a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public startPerformanceCounter(counterName: string): void {\r\n        this._parent._startPerformanceCounter(counterName);\r\n    }\r\n\r\n    /**\r\n     * Ends a performance counter.\r\n     * @param counterName The name of the performance counter\r\n     */\r\n    public endPerformanceCounter(counterName: string): void {\r\n        this._parent._endPerformanceCounter(counterName);\r\n    }\r\n}\r\n\r\nGLTFFileLoader._CreateGLTF2Loader = (parent) => new GLTFLoader(parent);\r\n"],"names":["MorphTargetManager","areUpdatesFrozen","block","this","_blockCounter","_syncActiveTargets","_forceUpdateWhenUnfrozen","scene","_targets","Array","_targetInfluenceChangedObservers","_targetDataLayoutChangedObservers","_activeTargets","_supportsPositions","_supportsNormals","_supportsTangents","_supportsUVs","_supportsUV2s","_supportsColors","_vertexCount","_uniqueId","_tempInfluences","_canUseTextureForTargets","_mustSynchronize","_textureVertexStride","_textureWidth","_textureHeight","_parentContainer","optimizeInfluencers","enablePositionMorphing","enableNormalMorphing","enableTangentMorphing","enableUVMorphing","enableUV2Morphing","enableColorMorphing","_numMaxInfluencers","_useTextureToStoreTargets","metadata","_influencesAreDirty","_needUpdateInfluences","LastCreatedScene","_scene","addMorphTargetManager","getUniqueId","engineCaps","getEngine","getCaps","canUseGLVertexID","textureFloat","maxVertexTextureImageUnits","texture2DArrayMaxLayerCount","numMaxInfluencers","ConstantTargetCountForTextureMode","isUsingTextureForTargets","value","uniqueId","vertexCount","supportsPositions","supportsNormals","supportsTangents","supportsUVs","supportsUV2s","supportsColors","hasPositions","hasNormals","hasTangents","hasUVs","hasUV2s","hasColors","numTargets","length","numInfluencers","influences","_influences","useTextureToStoreTargets","EnableTextureStorage","disableMorphTargetTexture","getActiveTarget","index","data","getTarget","getTargetByName","name","target","addTarget","push","onInfluenceChanged","add","needUpdate","_onDataLayoutChanged","removeTarget","indexOf","splice","remove","stopAnimation","_bind","effect","setFloat3","setFloatArray","_morphTargetTextureIndices","setTexture","_targetStoreTexture","setFloat","clone","copy","serialize","serializationObject","id","targets","wasUsingTextureForTargets","synchronize","influenceCount","reset","Float32Array","targetIndex","influence","MaxActiveMorphTargetsInVertexAttributeMode","slice","mesh","meshes","morphTargetManager","_markSubMeshesAsAttributesDirty","_syncGeometryWithMorphTargetManager","engine","dispose","Error","maxTextureSize","Math","ceil","targetCount","offset","positions","getPositions","normals","getNormals","uvs","getUVs","tangents","getTangents","uv2s","getUV2s","colors","getColors","vertex","CreateRGBATexture","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_FLOAT","removeMorphTargetManager","morphTargetManagers","morph","Parse","result","targetData","M","DataReader","constructor","buffer","byteOffset","loadAsync","byteLength","readAsync","_dataView","DataView","_dataByteOffset","readUint32","getUint32","readUint8Array","Uint8Array","readString","skipBytes","ValidateAsync","rootUrl","fileName","getExternalResource","options","externalResourceFunction","uri","ArrayBuffer","isView","GLTFValidator","validateBytes","validateString","WorkerFunc","pendingExternalResources","onmessage","message","importScripts","url","Promise","resolve","reject","postMessage","then","reason","GLTFValidation","Worker","workerContent","workerBlobUrl","URL","createObjectURL","Blob","type","worker","onError","error","removeEventListener","onMessage","terminate","addEventListener","GetBabylonScriptURL","Configuration","slicedData","_LoadScriptPromise","LoadBabylonScriptAsync","_DefaultCdnUrl","GLTFLoaderCoordinateSystemMode","GLTFLoaderAnimationStartMode","GLTFLoaderState","arrayBuffer","e","GLTFLoaderBaseOptions","alwaysComputeBoundingBox","alwaysComputeSkeletonRootNode","animationStartMode","FIRST","compileMaterials","compileShadowGenerators","coordinateSystemMode","AUTO","createInstances","loadAllMaterials","loadMorphTargets","loadNodeAnimations","loadOnlyMaterials","loadSkins","skipMaterials","targetFps","transparencyAsCoverage","useClipPlane","useGltfTextureNames","useRangeRequests","useSRGBBuffers","validate","useOpenPBR","dontUseTransmissionHelper","GLTFLoaderDefaultOptions","GLTFLoaderOptions","extensionOptions","preprocessUrlAsync","copyFrom","capturePerformanceCounters","customRootNode","loggingEnabled","onCameraLoaded","onMaterialLoaded","onMeshLoaded","onParsed","onSkinLoaded","onTextureLoaded","onValidated","GLTFFileLoader","super","onParsedObservable","onMeshLoadedObservable","onSkinLoadedObservable","onTextureLoadedObservable","onMaterialLoadedObservable","onCameraLoadedObservable","onCompleteObservable","onErrorObservable","onDisposeObservable","onExtensionLoadedObservable","onValidatedObservable","_loader","_state","_requests","extensions","onLoaderStateChangedObservable","_logIndentLevel","_loggingEnabled","_log","_logDisabled","_capturePerformanceCounters","_startPerformanceCounter","_startPerformanceCounterDisabled","_endPerformanceCounter","_endPerformanceCounterDisabled","Object","assign","callback","_onParsedObserver","_onMeshLoadedObserver","_onSkinLoadedObserver","node","skinnedNode","_onTextureLoadedObserver","_onMaterialLoadedObserver","_onCameraLoadedObserver","onComplete","_onCompleteObserver","_onErrorObserver","onDispose","_onDisposeObserver","onExtensionLoaded","_onExtensionLoadedObserver","_logEnabled","_startPerformanceCounterEnabled","_endPerformanceCounterEnabled","_onValidatedObserver","request","abort","_progressCallback","clear","notifyObservers","undefined","loadFile","fileOrUrl","onSuccess","onProgress","useArrayBuffer","_loadBinary","GetFilename","Warn","fileRequest","dataBuffer","_loadFile","webRequest","setRequestHeader","_unpackBinaryAsync","loaderData","_validate","json","_parseJson","arrayBufferView","RangeError","readViewAsync","importMeshAsync","meshesNames","_getLoader","loadAssetContainerAsync","container","materials","material","textures","texture","cameras","camera","prototype","apply","geometries","particleSystems","skeletons","animationGroups","lights","transformNodes","canDirectLoad","directLoad","startsWith","createPlugin","loaderState","whenCompleteAsync","addOnce","_setState","state","onOpened","event","_onProgress","_lengthComputable","_total","_loaded","lengthComputable","loaded","total","_loadFileAsync","asset","version","minVersion","generator","_parseVersion","_compareVersion","major","minor","createLoader","_CreateGLTF1Loader","_CreateGLTF2Loader","parsed","JSON","parse","dataReader","magic","GLTFLoaderUnexpectedMagicError","unpacked","_unpackBinaryV1Async","_unpackBinaryV2Async","contentLength","contentFormat","bodyLength","bin","startByteOffset","ChunkFormat","chunkLength","match","parseInt","a","b","_logOpen","_logClose","spaces","_logSpaces","substring","Log","counterName","StartPerformanceCounter","EndPerformanceCounter","IncrementalLoading","HomogeneousCoordinates","Lazy","factory","_factory","_value","LazyAnimationGroupModulePromise","LazyLoaderAnimationModulePromise","ArrayItem","Get","context","array","TryGet","Assign","LoadBoundingInfoFromPositionAccessor","accessor","min","max","minArray","maxArray","minVector","Vector3","copyFromFloats","maxVector","normalized","componentType","divider","oneOverDivider","scaleInPlace","GLTFLoader","RegisterExtension","UnregisterExtension","gltf","_gltf","_bin","parent","_parent","babylonScene","_babylonScene","rootBabylonMesh","_rootBabylonMesh","_rootUrl","_completePromises","_assetContainer","_babylonLights","_disableInstancedMesh","_allMaterialsDirtyRequired","_skipStartAnimationStep","_extensions","_disposed","_fileName","_uniqueRootUrl","_defaultBabylonMaterialData","_postSceneLoadActions","_materialAdapterCache","WeakMap","_pbrMaterialImpl","_getOrCreateMaterialAdapter","adapter","get","adapterClass","set","forEach","extension","async","_loadData","nodes","nodeMap","map","_loadAsync","_getMeshes","_getSkeletons","_getAnimationGroups","_getTransformNodes","_getGeometries","spriteManagers","resultFunc","Date","now","_loadExtensionsAsync","isExtensionUsed","materialClass","OpenPBRMaterial","OpenPBRMaterialLoadingAdapter","PBRMaterial","PBRMaterialLoadingAdapter","loadingToReadyCounterName","LOADING","READY","loadingToCompleteCounterName","COMPLETE","_extensionsOnLoading","promises","oldBlockMaterialDirtyMechanism","blockMaterialDirtyMechanism","loadSceneAsync","scenes","m","babylonDrawMode","TriangleFillMode","_loadMaterialAsync","_forceBlockMaterialDirtyMechanism","_compileMaterialsAsync","_compileShadowGeneratorsAsync","resultPromise","all","setEnabled","mat","maxSimultaneousLights","_extensionsOnReady","_startAnimations","SetImmediate","catch","_setupData","buffers","binaryBuffer","accessors","animations","bufferViews","images","samplers","skins","nodeParents","children","rootNode","_createRootNode","parentIndex","extensionPromises","registeredExtension","enabled","isGLTFExtension","sort","order","Number","MAX_VALUE","extensionsRequired","some","_babylonTransformNode","_blockEntityCollection","rootMesh","useRightHandedSystem","rotation","scale","_LoadTransform","FORCE_RIGHT_HANDED","extensionPromise","_extensionsLoadSceneAsync","logOpen","loadNodeAsync","babylonMesh","action","_loadAnimationsAsync","logClose","_forEachPrimitive","_primitiveBabylonMeshes","geometry","getClassName","_babylonTransformNodeForSkin","skin","_data","babylonSkeleton","animation","_babylonAnimationGroup","NONE","babylonAnimationGroups","start","ALL","babylonAnimationGroup","_extensionsLoadNodeAsync","loadNode","babylonTransformNode","AddPointerMetadata","loadCameraAsync","babylonCamera","scaling","x","childNode","childBabylonMesh","hasMesh","hasSkin","nodeName","transformNode","_loadMeshAsync","babylonTransformNodeForSkin","_loadSkinAsync","skeleton","parentNode","asMesh","isAnInstance","useBoundingInfoFromGeometry","_updateBoundingInfo","refreshBoundingInfo","primitives","primitive","_loadMeshPrimitiveAsync","_extensionsLoadMeshPrimitiveAsync","shouldInstance","babylonAbstractMesh","promise","_instanceData","babylonSourceMesh","createInstance","sideOrientation","CounterClockWiseSideOrientation","ClockWiseSideOrientation","_createMorphTargets","_loadVertexDataAsync","babylonGeometry","_loadMorphTargetsAsync","applyToMesh","_GetDrawMode","mode","babylonMaterial","_createDefaultMaterial","_extensionsLoadVertexDataAsync","attributes","indices","isUnIndexed","_loadIndicesAccessorAsync","setIndices","loadAttribute","kind","_delayInfo","_loadVertexAccessorAsync","babylonVertexBuffer","getKind","PositionKind","babylonBoundingInfo","_boundingInfo","setVerticesBuffer","count","MatricesIndicesExtraKind","numBoneInfluencers","NormalKind","TangentKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","MatricesIndicesKind","MatricesWeightsKind","MatricesWeightsExtraKind","ColorKind","hasVertexAlpha","_numMorphTargets","targetNames","extras","weight","weights","getScene","babylonMorphTarget","_loadMorphTargetVertexDataAsync","attribute","setData","getVertexBuffer","_loadFloatAccessorAsync","setPositions","setNormals","dataIndex","setTangents","setUVs","setUV2s","componentSize","getSize","pixid","floor","channel","i","setColors","babylonNode","position","Zero","Identity","One","matrix","FromArray","decompose","translation","rotationQuaternion","_extensionsLoadSkinAsync","skeletonId","_loadBones","_loadSkinInverseBindMatricesDataAsync","inverseBindMatricesData","_updateBoneMatrices","_findSkeletonRootNode","joints","isParent","skeletonNode","babylonBones","_loadBone","paths","path","unshift","j","_isJoint","babylonBone","parentBabylonBone","boneIndex","_getNodeMatrix","linkTransformNode","inverseBindMatrices","bones","baseMatrix","_index","FromArrayToRef","invertToRef","babylonParentBone","getParent","multiplyToRef","getAbsoluteInverseBindMatrix","updateMatrix","_updateAbsoluteBindMatrices","Compose","_extensionsLoadCameraAsync","_babylonCamera","setTarget","perspective","fov","yfov","minZ","znear","maxZ","zfar","orthographic","ORTHOGRAPHIC_CAMERA","orthoLeft","xmag","orthoRight","orthoBottom","ymag","orthoTop","loadAnimationAsync","animationGroup","targetedAnimations","_extensionsLoadAnimationAsync","AnimationGroup","channels","_loadAnimationChannelAsync","babylonTarget","babylonAnimation","addTargetedAnimation","normalize","animationContext","onLoad","_extensionsLoadAnimationChannelAsync","targetNode","channelTargetPath","pathIsWeights","properties","interpolation","targetInfo","object","info","_loadAnimationChannelFromTargetInfoAsync","fps","invfps","sampler","_loadAnimationSamplerAsync","numAnimations","propertyInfos","propertyInfo","stride","getStride","input","output","keys","outputOffset","getValue","frame","inTangent","outTangent","babylonAnimations","buildAnimations","babylonAnimatable","inputAccessor","outputAccessor","inputData","outputData","loadBufferAsync","_extensionsLoadBufferAsync","loadUriAsync","loadBufferViewAsync","bufferView","_extensionsLoadBufferViewAsync","_loadAccessorAsync","numComponents","_GetNumComponents","byteStride","GetTypeByteLength","typedArray","ForEach","_GetTypedArray","sparse","indicesBufferView","valuesBufferView","values","indicesData","valuesData","sparseLength","sparseData","valuesIndex","indicesIndex","componentIndex","_GetTypedArrayConstructor","_loadVertexBufferViewAsync","_babylonBuffer","_babylonVertexBuffer","babylonBuffer","_loadMaterialMetallicRoughnessPropertiesAsync","baseColorFactor","baseColor","geometryOpacity","White","baseMetalness","metallicFactor","specularRoughness","roughnessFactor","baseColorTexture","loadTextureInfoAsync","metallicRoughnessTexture","nonColorData","baseMetalnessTexture","specularRoughnessTexture","useRoughnessFromMetallicTextureGreen","useMetallicFromMetallicTextureBlue","_extensionsLoadMaterialAsync","babylonData","createMaterial","babylonMeshes","loadMaterialPropertiesAsync","fillMode","transparencyMode","MATERIAL_OPAQUE","transparencyAsAlphaCoverage","extensionMaterial","_extensionsCreateMaterial","_extensionsLoadMaterialPropertiesAsync","loadMaterialBasePropertiesAsync","pbrMetallicRoughness","loadMaterialAlphaProperties","aoTexture","emissionColor","emissiveFactor","doubleSided","backFaceCulling","twoSidedLighting","normalTexture","geometryNormalTexture","level","setNormalMapInversions","emissionTexture","aoStrength","occlusionTexture","strength","emissiveTexture","ambientOcclusionTexture","ambientOcclusionTextureStrength","emissionColorTexture","alphaMode","alpha","MATERIAL_ALPHATEST","alphaCutOff","alphaCutoff","hasAlpha","MATERIAL_ALPHABLEND","useAlphaFromBaseColorTexture","textureInfo","_extensionsLoadTextureInfoAsync","texCoord","_textureInfo","_loadTextureAsync","babylonTexture","coordinatesIndex","_extensionsLoadTextureAsync","DefaultSampler","image","source","_createTextureAsync","textureLoaderOptions","useSRGBBuffer","samplerData","_loadSampler","deferred","textureCreationOptions","noMipmap","noMipMaps","invertY","samplingMode","exception","mimeType","loaderOptions","loadImageAsync","dataUrl","updateURL","internalTexture","getInternalTexture","label","wrapU","wrapV","minFilter","_GetTextureSamplingMode","_GetTextureWrapMode","wrapS","wrapT","property","_extensionsLoadUriAsync","_ValidateUri","log","status","statusText","babylonObject","pointer","_internalMetadata","pointers","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","WRAP_ADDRESSMODE","magFilter","LINEAR_NEAREST","LINEAR_LINEAR","LINEAR_NEAREST_MIPNEAREST","LINEAR_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR","NEAREST_NEAREST_MIPNEAREST","NEAREST_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPLINEAR","NEAREST_LINEAR_MIPLINEAR","componentTypeLength","IsBase64","PointListDrawMode","LineListDrawMode","LineLoopDrawMode","LineStripDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","computeWorldMatrix","forceCompilationAsync","useInstances","clipPlane","light","getShadowGenerator","_forEachExtensions","_applyExtensions","functionName","actionAsync","loaderProperty","_activeLoaderExtensionFunctions","activeLoaderExtensionFunctions","onLoading","onReady","_loadUriAsync","LoadExtensionAsync","extensionName","LoadExtraAsync","extra","extensionsUsed","startPerformanceCounter","endPerformanceCounter"],"ignoreList":[],"sourceRoot":""}