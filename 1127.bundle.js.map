{"version":3,"file":"1127.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractSoundSource.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractSound.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractSoundInstance.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/staticSound.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/staticSoundBuffer.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/staticSoundInstance.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/webAudio/webAudioStaticSound.ts?"],"sourcesContent":["import type { Nullable } from \"../../types\";\nimport { AudioNodeType } from \"./abstractAudioNode\";\nimport type { IAbstractAudioOutNodeOptions } from \"./abstractAudioOutNode\";\nimport { AbstractAudioOutNode } from \"./abstractAudioOutNode\";\nimport type { PrimaryAudioBus } from \"./audioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { AbstractSpatialAudio, ISpatialAudioOptions } from \"./subProperties/abstractSpatialAudio\";\nimport type { AbstractStereoAudio, IStereoAudioOptions } from \"./subProperties/abstractStereoAudio\";\n\n/**\n * Options for creating a sound source.\n */\nexport interface ISoundSourceOptions extends IAbstractAudioOutNodeOptions, ISpatialAudioOptions, IStereoAudioOptions {\n    /**\n     * The output bus for the sound source. Defaults to `null`.\n     * - If not set or `null`, and `outBusAutoDefault` is `true`, then the sound source is automatically connected to the audio engine's default main bus.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    outBus: Nullable<PrimaryAudioBus>;\n\n    /**\n     * Whether the sound's `outBus` should default to the audio engine's main bus. Defaults to `true` for all sound sources except microphones.\n     */\n    outBusAutoDefault: boolean;\n}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSoundSource extends AbstractAudioOutNode {\n    private readonly _spatialAutoUpdate: boolean = true;\n    private readonly _spatialMinUpdateTime: number = 0;\n    private _outBus: Nullable<PrimaryAudioBus> = null;\n    private _spatial: Nullable<AbstractSpatialAudio> = null;\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<ISoundSourceOptions>, nodeType: AudioNodeType = AudioNodeType.HAS_OUTPUTS) {\n        super(name, engine, nodeType);\n\n        if (typeof options.spatialAutoUpdate === \"boolean\") {\n            this._spatialAutoUpdate = options.spatialAutoUpdate;\n        }\n\n        if (typeof options.spatialMinUpdateTime === \"number\") {\n            this._spatialMinUpdateTime = options.spatialMinUpdateTime;\n        }\n    }\n\n    /**\n     * The output bus for the sound.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    public get outBus(): Nullable<PrimaryAudioBus> {\n        return this._outBus;\n    }\n\n    public set outBus(outBus: Nullable<PrimaryAudioBus>) {\n        if (this._outBus === outBus) {\n            return;\n        }\n\n        if (this._outBus) {\n            if (this._onOutBusDisposed) {\n                this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);\n                this._onOutBusDisposed = null;\n            }\n            if (!this._disconnect(this._outBus)) {\n                throw new Error(\"Disconnect failed\");\n            }\n        }\n\n        this._outBus = outBus;\n\n        if (this._outBus) {\n            this._onOutBusDisposed = () => {\n                this._outBus = null;\n            };\n            this._outBus.onDisposeObservable.add(this._onOutBusDisposed);\n            if (!this._connect(this._outBus)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n    }\n\n    /**\n     * The spatial audio features.\n     */\n    public get spatial(): AbstractSpatialAudio {\n        if (this._spatial) {\n            return this._spatial;\n        }\n        return this._initSpatialProperty();\n    }\n\n    /**\n     * The stereo features of the sound.\n     */\n    public abstract stereo: AbstractStereoAudio;\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this._spatial?.dispose();\n        this._spatial = null;\n\n        if (this._outBus && this._onOutBusDisposed) {\n            this._outBus.onDisposeObservable.removeCallback(this._onOutBusDisposed);\n            this._onOutBusDisposed = null;\n        }\n        this._outBus = null;\n    }\n\n    protected abstract _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio;\n\n    protected _initSpatialProperty(): AbstractSpatialAudio {\n        return (this._spatial = this._createSpatialProperty(this._spatialAutoUpdate, this._spatialMinUpdateTime));\n    }\n\n    private _onOutBusDisposed: Nullable<() => void> = null;\n\n    /** @internal */\n    public get _isSpatial(): boolean {\n        return this._spatial !== null;\n    }\n\n    public set _isSpatial(value: boolean) {\n        if (value && !this._spatial) {\n            this._initSpatialProperty();\n        } else if (!value && this._spatial) {\n            this._spatial.dispose();\n            this._spatial = null;\n        }\n    }\n}\n","import { Observable } from \"../../Misc/observable\";\nimport type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport { AudioNodeType } from \"./abstractAudioNode\";\nimport type { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport { AbstractSoundSource, type ISoundSourceOptions } from \"./abstractSoundSource\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IVolumeAudioOptions } from \"./subNodes/volumeAudioSubNode\";\n\n/** @internal */\nexport interface IAbstractSoundOptionsBase {\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    autoplay: boolean;\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    maxInstances: number;\n}\n\n/** @internal */\nexport interface IAbstractSoundPlayOptionsBase {\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    loop: boolean;\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    startOffset: number;\n}\n\n/**\n * Options for creating a sound.\n */\nexport interface IAbstractSoundOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptions, ISoundSourceOptions {}\n\n/**\n * Options for playing a sound.\n */\nexport interface IAbstractSoundPlayOptions extends IAbstractSoundPlayOptionsBase, IVolumeAudioOptions {}\n\n/**\n * Options stored in a sound.\n * @internal\n */\nexport interface IAbstractSoundStoredOptions extends IAbstractSoundOptionsBase, IAbstractSoundPlayOptionsBase {}\n\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport abstract class AbstractSound extends AbstractSoundSource {\n    private _newestInstance: Nullable<_AbstractSoundInstance> = null;\n    private _privateInstances = new Set<_AbstractSoundInstance>();\n    private _state: SoundState = SoundState.Stopped;\n\n    protected _instances: ReadonlySet<_AbstractSoundInstance> = this._privateInstances;\n    protected abstract readonly _options: IAbstractSoundStoredOptions;\n\n    /**\n     * Observable for when the sound stops playing.\n     */\n    public readonly onEndedObservable = new Observable<AbstractSound>();\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IAbstractSoundOptions>) {\n        super(name, engine, options, AudioNodeType.HAS_INPUTS_AND_OUTPUTS); // Inputs are for instances.\n    }\n\n    /**\n     * The number of active instances of the sound that are currently playing.\n     */\n    public get activeInstancesCount(): number {\n        return this._instances.size;\n    }\n\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    public get autoplay(): boolean {\n        return this._options.autoplay;\n    }\n\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    public get currentTime(): number {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n\n    public set currentTime(value: number) {\n        this.startOffset = value;\n\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    public get loop(): boolean {\n        return this._options.loop;\n    }\n\n    public set loop(value: boolean) {\n        this._options.loop = value;\n    }\n\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    public get maxInstances(): number {\n        return this._options.maxInstances;\n    }\n\n    public set maxInstances(value: number) {\n        this._options.maxInstances = value;\n    }\n\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    public get startOffset(): number {\n        return this._options.startOffset;\n    }\n\n    public set startOffset(value: number) {\n        this._options.startOffset = value;\n    }\n\n    /**\n     * The state of the sound.\n     */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /**\n     * Releases associated resources.\n     */\n    public override dispose(): void {\n        super.dispose();\n\n        this.stop();\n\n        this._newestInstance = null;\n\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public abstract play(options?: Partial<IAbstractSoundPlayOptions>): void;\n\n    /**\n     * Pauses the sound.\n     */\n    public pause(): void {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n\n        this._state = SoundState.Paused;\n    }\n\n    /**\n     * Resumes the sound.\n     */\n    public resume(): void {\n        if (this._state !== SoundState.Paused) {\n            return;\n        }\n\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n\n        this._state = SoundState.Started;\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     */\n    public abstract stop(): void;\n\n    protected _beforePlay(instance: _AbstractSoundInstance): void {\n        if (this.state === SoundState.Paused && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n\n    protected _afterPlay(instance: _AbstractSoundInstance): void {\n        this._state = instance.state;\n    }\n\n    protected _getNewestInstance(): Nullable<_AbstractSoundInstance> {\n        if (this._instances.size === 0) {\n            return null;\n        }\n\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n\n        return this._newestInstance;\n    }\n\n    protected _setState(state: SoundState): void {\n        this._state = state;\n    }\n\n    protected abstract _createInstance(): _AbstractSoundInstance;\n\n    protected _stopExcessInstances(): void {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === SoundState.Started).length - this.maxInstances;\n            const it = this._instances.values();\n\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n\n    private _onInstanceEnded: (instance: _AbstractSoundInstance) => void = (instance) => {\n        if (this._newestInstance === instance) {\n            this._newestInstance = null;\n        }\n\n        this._privateInstances.delete(instance);\n\n        if (this._instances.size === 0) {\n            this._state = SoundState.Stopped;\n            this.onEndedObservable.notifyObservers(this);\n        }\n\n        instance.dispose();\n    };\n}\n","import { Observable } from \"../../Misc/observable\";\nimport { SoundState } from \"../soundState\";\nimport { AbstractAudioNode, AudioNodeType } from \"./abstractAudioNode\";\nimport type { AbstractSound, IAbstractSoundPlayOptions, IAbstractSoundPlayOptionsBase } from \"./abstractSound\";\n\n/**\n * Options for creating a sound instance.\n * @internal\n * */\nexport interface IAbstractSoundInstanceOptions extends IAbstractSoundPlayOptionsBase {}\n\n/** @internal */\nexport abstract class _AbstractSoundInstance extends AbstractAudioNode {\n    protected _sound: AbstractSound;\n    protected _state: SoundState = SoundState.Stopped;\n\n    /** Observable triggered when the sound instance's playback ends */\n    public readonly onEndedObservable = new Observable<_AbstractSoundInstance>();\n\n    /** Observable triggered if the sound instance encounters an error and can not be played */\n    public readonly onErrorObservable = new Observable<any>();\n\n    /** Observable triggered when the sound instance's state changes */\n    public readonly onStateChangedObservable = new Observable<_AbstractSoundInstance>();\n\n    protected abstract readonly _options: IAbstractSoundInstanceOptions;\n\n    protected constructor(sound: AbstractSound) {\n        super(sound.engine, AudioNodeType.HAS_OUTPUTS);\n\n        this._sound = sound;\n    }\n\n    public abstract currentTime: number;\n\n    public abstract readonly startTime: number;\n\n    /** The playback state of the sound instance */\n    public get state(): SoundState {\n        return this._state;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n\n    public abstract play(options: Partial<IAbstractSoundPlayOptions>): void;\n    public abstract pause(): void;\n    public abstract resume(): void;\n    public abstract stop(): void;\n\n    protected _setState(value: SoundState) {\n        if (this._state === value) {\n            return;\n        }\n\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n\n        if (this._state === SoundState.Stopped) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n    }\n}\n","import type { Nullable } from \"../../types\";\nimport { SoundState } from \"../soundState\";\nimport type { IAbstractSoundOptions, IAbstractSoundPlayOptions, IAbstractSoundStoredOptions } from \"./abstractSound\";\nimport { AbstractSound } from \"./abstractSound\";\nimport type { PrimaryAudioBus } from \"./audioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IStaticSoundBufferOptions, StaticSoundBuffer } from \"./staticSoundBuffer\";\nimport type { _StaticSoundInstance } from \"./staticSoundInstance\";\n\n/** @internal */\nexport interface IStaticSoundOptionsBase {\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    duration: number;\n    /**\n     * The end of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     * - Has no effect if {@link loop} is `false`.\n     */\n    loopEnd: number;\n    /**\n     * The start of the loop range in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     * - Has no effect if {@link loop} is `false`.\n     *\n     */\n    loopStart: number;\n}\n\n/**\n * Options stored in a static sound.\n * @internal\n */\nexport interface IStaticSoundStoredOptions extends IAbstractSoundStoredOptions, IStaticSoundOptionsBase {\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Can be combined with {@link playbackRate}.\n     */\n    pitch: number;\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Can be combined with {@link pitch}.\n     */\n    playbackRate: number;\n}\n\n/**\n * Options for creating a static sound.\n */\nexport interface IStaticSoundOptions extends IAbstractSoundOptions, IStaticSoundBufferOptions, IStaticSoundStoredOptions {}\n\n/**\n * Options for playing a static sound.\n */\nexport interface IStaticSoundPlayOptions extends IAbstractSoundPlayOptions, IStaticSoundOptionsBase {\n    /**\n     * The time to wait before playing the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Options for stopping a static sound.\n */\nexport interface IStaticSoundStopOptions {\n    /**\n     * The time to wait before stopping the sound, in seconds. Defaults to `0`.\n     */\n    waitTime: number;\n}\n\n/**\n * Options for cloning a static sound.\n * - @see {@link StaticSound.clone}.\n */\nexport interface IStaticSoundCloneOptions {\n    /**\n     * Whether to clone the sound buffer when cloning the sound. Defaults to `false`.\n     * - If `true`, the original sound's buffer is cloned, and the cloned sound will use its own copy.\n     * - If `false`, the sound buffer is shared with the original sound.\n     */\n    cloneBuffer: boolean;\n\n    /**\n     * The output bus for the cloned sound. Defaults to `null`.\n     * - If not set or `null`, the cloned sound uses the original sound's `outBus`.\n     * @see {@link AudioEngineV2.defaultMainBus}\n     */\n    outBus: Nullable<PrimaryAudioBus>;\n}\n\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport abstract class StaticSound extends AbstractSound {\n    protected override _instances: Set<_StaticSoundInstance>;\n    protected abstract override readonly _options: IStaticSoundStoredOptions;\n\n    /**\n     * The sound buffer that the sound uses.\n     *\n     * This buffer can be shared with other static sounds.\n     */\n    public abstract readonly buffer: StaticSoundBuffer;\n\n    protected constructor(name: string, engine: AudioEngineV2, options: Partial<IStaticSoundOptions>) {\n        super(name, engine, options);\n    }\n\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    public get duration(): number {\n        return this._options.duration;\n    }\n\n    public set duration(value: number) {\n        this._options.duration = value;\n    }\n\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    public get loopStart(): number {\n        return this._options.loopStart;\n    }\n\n    public set loopStart(value: number) {\n        this._options.loopStart = value;\n    }\n\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    public get loopEnd(): number {\n        return this._options.loopEnd;\n    }\n\n    public set loopEnd(value: number) {\n        this._options.loopEnd = value;\n    }\n\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    public get pitch(): number {\n        return this._options.pitch;\n    }\n\n    public set pitch(value: number) {\n        this._options.pitch = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    public get playbackRate(): number {\n        return this._options.playbackRate;\n    }\n\n    public set playbackRate(value: number) {\n        this._options.playbackRate = value;\n\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n\n    /**\n     * Clones the sound.\n     * @param options Options for cloning the sound.\n     */\n    public abstract cloneAsync(options?: Partial<IStaticSoundCloneOptions>): Promise<StaticSound>;\n\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this.state === SoundState.Paused) {\n            this.resume();\n            return;\n        }\n\n        options.duration ??= this.duration;\n        options.loop ??= this.loop;\n        options.loopStart ??= this.loopStart;\n        options.loopEnd ??= this.loopEnd;\n        options.startOffset ??= this.startOffset;\n        options.volume ??= 1;\n        options.waitTime ??= 0;\n\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n\n        this._stopExcessInstances();\n    }\n\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(SoundState.Stopping);\n        } else {\n            this._setState(SoundState.Stopped);\n        }\n\n        if (!this._instances) {\n            return;\n        }\n\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n\n    protected abstract override _createInstance(): _StaticSoundInstance;\n}\n","import type { AudioEngineV2 } from \"./audioEngineV2\";\n\nlet StaticSoundBufferId = 1;\n\n/**\n * Options for creating a static sound buffer.\n */\nexport interface IStaticSoundBufferOptions {\n    /**\n     * Whether to skip codec checking before attempting to load each source URL when `source` is a string array. Defaults to `false`.\n     * - Has no effect if the sound's source is not a string array.\n     * @see {@link CreateSoundAsync} `source` parameter.\n     */\n    skipCodecCheck: boolean;\n}\n\n/**\n * Options for cloning a static sound buffer.\n * - @see {@link StaticSoundBuffer.clone}.\n */\nexport interface IStaticSoundBufferCloneOptions {\n    /**\n     * The name of the cloned sound buffer. Defaults to `StaticSoundBuffer #${id}`.\n     */\n    name: string;\n}\n\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport abstract class StaticSoundBuffer {\n    /**\n     * The engine that the sound buffer belongs to.\n     */\n    public readonly engine: AudioEngineV2;\n\n    /**\n     * The name of the sound buffer.\n     */\n    public name: string = `StaticSoundBuffer #${StaticSoundBufferId++}`;\n\n    protected constructor(engine: AudioEngineV2) {\n        this.engine = engine;\n    }\n\n    /**\n     * The sample rate of the sound buffer.\n     */\n    public abstract readonly sampleRate: number;\n\n    /**\n     * The length of the sound buffer, in sample frames.\n     */\n    public abstract readonly length: number;\n\n    /**\n     * The duration of the sound buffer, in seconds.\n     */\n    public abstract readonly duration: number;\n\n    /**\n     * The number of channels in the sound buffer.\n     */\n    public abstract readonly channelCount: number;\n\n    /**\n     * Clones the sound buffer.\n     * @param options Options for cloning the sound buffer.\n     */\n    public abstract clone(options?: Partial<IStaticSoundBufferCloneOptions>): StaticSoundBuffer;\n}\n","import type { IAbstractSoundInstanceOptions } from \"./abstractSoundInstance\";\nimport { _AbstractSoundInstance } from \"./abstractSoundInstance\";\nimport type { IStaticSoundOptionsBase, IStaticSoundPlayOptions, IStaticSoundStopOptions } from \"./staticSound\";\n\n/**\n * Options for creating a static sound instance.\n * @internal\n */\nexport interface IStaticSoundInstanceOptions extends IAbstractSoundInstanceOptions, IStaticSoundOptionsBase {}\n\n/** @internal */\nexport abstract class _StaticSoundInstance extends _AbstractSoundInstance {\n    protected abstract override readonly _options: IStaticSoundInstanceOptions;\n\n    public abstract pitch: number;\n    public abstract playbackRate: number;\n\n    public abstract override play(options: Partial<IStaticSoundPlayOptions>): void;\n    public abstract override stop(options?: Partial<IStaticSoundStopOptions>): void;\n}\n","import type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { IStaticSoundCloneOptions, IStaticSoundOptions, IStaticSoundPlayOptions, IStaticSoundStopOptions, IStaticSoundStoredOptions } from \"../abstractAudio/staticSound\";\nimport { StaticSound } from \"../abstractAudio/staticSound\";\nimport type { IStaticSoundBufferCloneOptions, IStaticSoundBufferOptions } from \"../abstractAudio/staticSoundBuffer\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport type { IStaticSoundInstanceOptions } from \"../abstractAudio/staticSoundInstance\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance\";\nimport { _HasSpatialAudioOptions, type AbstractSpatialAudio } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils\";\nimport { SoundState } from \"../soundState\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioOutNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\ntype StaticSoundSourceType = ArrayBuffer | AudioBuffer | StaticSoundBuffer | string | string[];\n\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound implements IWebAudioSuperNode {\n    private _buffer: _WebAudioStaticSoundBuffer;\n    private _stereo: Nullable<_StereoAudio> = null;\n\n    protected override readonly _options: IStaticSoundStoredOptions;\n    protected _subGraph: _WebAudioBusAndSoundSubGraph;\n\n    /** @internal */\n    public _audioContext: AudioContext | OfflineAudioContext;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine, options: Partial<IStaticSoundOptions>) {\n        super(name, engine, options);\n\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _initAsync(source: StaticSoundSourceType, options: Partial<IStaticSoundOptions>): Promise<void> {\n        this._audioContext = this.engine._audioContext;\n\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source;\n        } else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options)) as _WebAudioStaticSoundBuffer;\n        }\n\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        } else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n\n        await this._subGraph.initAsync(options);\n\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n\n        if (options.autoplay) {\n            this.play();\n        }\n\n        this.engine._addSound(this);\n    }\n\n    /** @internal */\n    public get buffer(): _WebAudioStaticSoundBuffer {\n        return this._buffer;\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    /** @internal */\n    public override get stereo(): _StereoAudio {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n\n    /** @internal */\n    public override async cloneAsync(options: Nullable<Partial<IStaticSoundCloneOptions>> = null): Promise<StaticSound> {\n        const clone = await this.engine.createSoundAsync(this.name, options?.cloneBuffer ? this.buffer.clone() : this.buffer, this._options);\n\n        clone.outBus = options?.outBus ? options.outBus : this.outBus;\n\n        return clone;\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._stereo = null;\n\n        this._subGraph.dispose();\n\n        this.engine._removeSound(this);\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSound\";\n    }\n\n    protected _createInstance(): _WebAudioStaticSoundInstance {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _createSpatialProperty(autoUpdate: boolean, minUpdateTime: number): AbstractSpatialAudio {\n        return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);\n    }\n\n    public _getOptions(): IStaticSoundStoredOptions {\n        return this._options;\n    }\n\n    private static _SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n        protected override _owner: _WebAudioStaticSound;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n\n        protected get _upstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._upstreamNodes ?? null;\n        }\n    };\n}\n\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    public _audioBuffer: AudioBuffer;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(engine: _WebAudioEngine) {\n        super(engine);\n    }\n\n    public async _initAsync(source: StaticSoundSourceType, options: Partial<IStaticSoundBufferOptions>): Promise<void> {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        } else if (typeof source === \"string\") {\n            await this._initFromUrlAsync(source);\n        } else if (Array.isArray(source)) {\n            await this._initFromUrlsAsync(source, options.skipCodecCheck ?? false);\n        } else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBufferAsync(source);\n        }\n    }\n\n    /** @internal */\n    public get channelCount(): number {\n        return this._audioBuffer.numberOfChannels;\n    }\n\n    /** @internal */\n    public get duration(): number {\n        return this._audioBuffer.duration;\n    }\n\n    /** @internal */\n    public get length(): number {\n        return this._audioBuffer.length;\n    }\n\n    /** @internal */\n    public get sampleRate(): number {\n        return this._audioBuffer.sampleRate;\n    }\n\n    /** @internal */\n    public override clone(options: Nullable<Partial<IStaticSoundBufferCloneOptions>> = null): StaticSoundBuffer {\n        const audioBuffer = new AudioBuffer({\n            length: this._audioBuffer.length,\n            numberOfChannels: this._audioBuffer.numberOfChannels,\n            sampleRate: this._audioBuffer.sampleRate,\n        });\n\n        for (let i = 0; i < this._audioBuffer.numberOfChannels; i++) {\n            audioBuffer.copyToChannel(this._audioBuffer.getChannelData(i), i);\n        }\n\n        const buffer = new _WebAudioStaticSoundBuffer(this.engine);\n        buffer._audioBuffer = audioBuffer;\n        buffer.name = options?.name ? options.name : this.name;\n\n        return buffer;\n    }\n\n    private async _initFromArrayBufferAsync(arrayBuffer: ArrayBuffer): Promise<void> {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n\n    private async _initFromUrlAsync(url: string): Promise<void> {\n        url = _CleanUrl(url);\n        await this._initFromArrayBufferAsync(await (await fetch(url)).arrayBuffer());\n    }\n\n    private async _initFromUrlsAsync(urls: string[], skipCodecCheck: boolean): Promise<void> {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                // eslint-disable-next-line no-await-in-loop\n                await this._initFromUrlAsync(url);\n            } else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this._initFromUrlAsync(url);\n                    } catch {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance implements IWebAudioOutNode {\n    private _enginePlayTime: number = 0;\n    private _enginePauseTime: number = 0;\n    private _isConnected: boolean = false;\n    private _pitch: Nullable<_WebAudioParameterComponent> = null;\n    private _playbackRate: Nullable<_WebAudioParameterComponent> = null;\n    private _sourceNode: Nullable<AudioBufferSourceNode> = null;\n    private _volumeNode: GainNode;\n\n    protected override readonly _options: IStaticSoundInstanceOptions;\n    protected override _sound: _WebAudioStaticSound;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    public constructor(sound: _WebAudioStaticSound, options: IStaticSoundInstanceOptions) {\n        super(sound);\n\n        this._options = options;\n\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this._pitch?.dispose();\n        this._playbackRate?.dispose();\n\n        this._sourceNode = null;\n\n        this.stop();\n\n        this._deinitSourceNode();\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n\n    /** @internal */\n    public get currentTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        const timeSinceLastStart = this._state === SoundState.Paused ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n\n    public set currentTime(value: number) {\n        const restart = this._state === SoundState.Starting || this._state === SoundState.Started;\n\n        if (restart) {\n            // Stop source node without sending `onEndedObservable` so instance's `dispose` function is not called.\n            const sourceNode = this._sourceNode;\n            this._deinitSourceNode();\n            sourceNode?.stop();\n            this._state = SoundState.Stopped;\n        }\n\n        if (this.state === SoundState.Paused) {\n            this._enginePauseTime = 0;\n        }\n\n        this._options.startOffset = value;\n\n        if (restart) {\n            this.play();\n        }\n    }\n\n    public get _outNode(): Nullable<AudioNode> {\n        return this._volumeNode;\n    }\n\n    /** @internal */\n    public set pitch(value: number) {\n        this._pitch?.setTargetValue(value);\n    }\n\n    /** @internal */\n    public set playbackRate(value: number) {\n        this._playbackRate?.setTargetValue(value);\n    }\n\n    /** @internal */\n    public get startTime(): number {\n        if (this._state === SoundState.Stopped) {\n            return 0;\n        }\n\n        return this._enginePlayTime;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n\n    /** @internal */\n    public play(options: Partial<IStaticSoundPlayOptions> = {}): void {\n        if (this._state === SoundState.Started) {\n            return;\n        }\n\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n\n        let startOffset = this._options.startOffset;\n\n        if (this._state === SoundState.Paused) {\n            startOffset += this._enginePauseTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n\n        this._volumeNode.gain.value = options.volume ?? 1;\n\n        this._initSourceNode();\n\n        if (this.engine.state === \"running\") {\n            this._setState(SoundState.Started);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        } else if (this._options.loop) {\n            this._setState(SoundState.Starting);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n\n    /** @internal */\n    public pause(): void {\n        if (this._state === SoundState.Paused) {\n            return;\n        }\n\n        this._setState(SoundState.Paused);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n\n        if (this._state === SoundState.Started) {\n            this._sourceNode?.stop();\n        } else {\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n\n        this._deinitSourceNode();\n    }\n\n    /** @internal */\n    public resume(): void {\n        if (this._state === SoundState.Paused) {\n            this.play();\n        }\n    }\n\n    /** @internal */\n    public stop(options: Partial<IStaticSoundStopOptions> = {}): void {\n        if (this._state === SoundState.Stopped) {\n            return;\n        }\n\n        if (this._state === SoundState.Started) {\n            const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n            this._sourceNode?.stop(engineStopTime);\n        }\n\n        if (options.waitTime === undefined || options.waitTime <= 0) {\n            this._setState(SoundState.Stopped);\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n    }\n\n    protected override _connect(node: AbstractAudioNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n            this._isConnected = true;\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: AbstractAudioNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n            this._isConnected = false;\n        }\n\n        return true;\n    }\n\n    protected _onEnded = () => {\n        this._enginePlayTime = 0;\n\n        if (this._state !== SoundState.Paused) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n\n        this._deinitSourceNode();\n    };\n\n    private _deinitSourceNode(): void {\n        if (!this._sourceNode) {\n            return;\n        }\n\n        if (this._isConnected && !this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n\n        this._sourceNode = null;\n    }\n\n    private _initSourceNode(): void {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n\n            this._pitch = new _WebAudioParameterComponent(this.engine, this._sourceNode.detune);\n            this._playbackRate = new _WebAudioParameterComponent(this.engine, this._sourceNode.playbackRate);\n        }\n\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n\n    private _onEngineStateChanged = () => {\n        if (this.engine.state !== \"running\") {\n            return;\n        }\n\n        if (this._options.loop && this.state === SoundState.Starting) {\n            this.play();\n        }\n\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    };\n}\n"],"names":["AbstractSoundSource","name","engine","options","nodeType","super","_spatialAutoUpdate","_spatialMinUpdateTime","_outBus","_spatial","_onOutBusDisposed","spatialAutoUpdate","this","spatialMinUpdateTime","outBus","onDisposeObservable","removeCallback","_disconnect","Error","add","_connect","spatial","_initSpatialProperty","dispose","_createSpatialProperty","_isSpatial","value","AbstractSound","_newestInstance","_privateInstances","Set","_state","_instances","onEndedObservable","_onInstanceEnded","instance","delete","size","notifyObservers","activeInstancesCount","autoplay","_options","currentTime","_getNewestInstance","startOffset","loop","maxInstances","state","stop","clear","pause","it","values","next","done","resume","_beforePlay","addOnce","_afterPlay","_setState","_stopExcessInstances","Infinity","numberOfInstancesToStop","Array","from","filter","length","i","_AbstractSoundInstance","sound","onErrorObservable","onStateChangedObservable","_sound","StaticSound","duration","loopStart","loopEnd","pitch","playbackRate","play","volume","waitTime","_createInstance","StaticSoundBufferId","StaticSoundBuffer","_StaticSoundInstance","_WebAudioStaticSound","_stereo","_subGraph","_SubGraph","_initAsync","source","_audioContext","_WebAudioStaticSoundBuffer","_buffer","isArray","ArrayBuffer","AudioBuffer","createSoundBufferAsync","outBusAutoDefault","isReadyPromise","defaultMainBus","initAsync","_addSound","buffer","_inNode","_outNode","stereo","cloneAsync","clone","createSoundAsync","cloneBuffer","_removeSound","getClassName","_WebAudioStaticSoundInstance","node","connect","disconnect","autoUpdate","minUpdateTime","_getOptions","_downstreamNodes","_owner","_upstreamNodes","_audioBuffer","_initFromUrlAsync","_initFromUrlsAsync","skipCodecCheck","_initFromArrayBufferAsync","channelCount","numberOfChannels","sampleRate","audioBuffer","copyToChannel","getChannelData","arrayBuffer","decodeAudioData","url","fetch","urls","matches","match","format","at","isFormatValid","flagInvalidFormat","_enginePlayTime","_enginePauseTime","_isConnected","_pitch","_playbackRate","_sourceNode","_onEnded","_deinitSourceNode","_onEngineStateChanged","stateChangedObservable","_volumeNode","GainNode","_initSourceNode","timeSinceLastStart","restart","sourceNode","setTargetValue","startTime","undefined","gain","start","engineStopTime","removeEventListener","AudioBufferSourceNode","addEventListener","once","detune"],"ignoreList":[],"sourceRoot":""}