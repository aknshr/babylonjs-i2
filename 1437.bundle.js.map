{"version":3,"file":"1437.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/SPLAT/sog.ts?","webpack://@dev/inspector-v2/../loaders/src/SPLAT/splatFileLoader.ts?","webpack://@dev/inspector-v2/../loaders/src/SPLAT/spz.ts?"],"sourcesContent":["import type { Scene } from \"core/scene\";\r\nimport type { IParsedSplat } from \"./splatDefs\";\r\nimport { Mode } from \"./splatDefs\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport type { AbstractEngine } from \"core/Engines\";\r\n\r\n/**\r\n * Definition of a SOG data file\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface SOGDataFile {\r\n    /**\r\n     * index 0 is number of splats index 1 is number of components per splat (3 for vec3, 4 for vec4, etc.)\r\n     */\r\n    shape: number[];\r\n    /**\r\n     * type of components\r\n     */\r\n    dtype: string;\r\n    /**\r\n     * min range of data\r\n     */\r\n    mins?: number | number[];\r\n    /**\r\n     * max range of data\r\n     */\r\n    maxs?: number | number[];\r\n    /**\r\n     * palette for indexed data (quantized)\r\n     */\r\n    codebook?: number[]; // Only for version 2\r\n    /**\r\n     * type of encoding\r\n     */\r\n    encoding?: string;\r\n    /**\r\n     * number of bits for quantization (if any)\r\n     */\r\n    quantization?: number;\r\n    /**\r\n     * webp file names\r\n     */\r\n    files: string[];\r\n    /**\r\n     * SH band count (if applicable)\r\n     */\r\n    bands?: number;\r\n}\r\n\r\n/**\r\n * Definition of the root SOG data file\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface SOGRootData {\r\n    /**\r\n     * version of the SOG format\r\n     */\r\n    version?: number;\r\n    /**\r\n     * mean positions of the splats\r\n     */\r\n    means: SOGDataFile;\r\n    /**\r\n     * scales of the splats\r\n     */\r\n    scales: SOGDataFile;\r\n    /**\r\n     * quaternions of the splats\r\n     */\r\n    quats: SOGDataFile;\r\n    /**\r\n     * SH0 coefficients of the splats (base color)\r\n     */\r\n    sh0: SOGDataFile;\r\n    /**\r\n     *  Optional higher order SH coefficients of the splats (lighting information)\r\n     */\r\n    shN?: SOGDataFile;\r\n    /**\r\n     * number of splats (optional, can be inferred from means.shape[0])\r\n     */\r\n    count?: number;\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\ninterface IWebPImage {\r\n    bits: Uint8Array;\r\n    width: number;\r\n}\r\nconst SH_C0 = 0.28209479177387814;\r\n\r\nasync function LoadWebpImageData(rootUrlOrData: string | Uint8Array, filename: string, engine: AbstractEngine): Promise<IWebPImage> {\r\n    const promise = new Promise<IWebPImage>((resolve, reject) => {\r\n        const image = engine.createCanvasImage();\r\n        if (!image) {\r\n            throw new Error(\"Failed to create ImageBitmap\");\r\n        }\r\n        image.onload = () => {\r\n            try {\r\n                // Draw to canvas\r\n                const canvas = engine.createCanvas(image.width, image.height);\r\n                if (!canvas) {\r\n                    throw new Error(\"Failed to create canvas\");\r\n                }\r\n                const ctx = canvas.getContext(\"2d\");\r\n                if (!ctx) {\r\n                    throw new Error(\"Failed to get 2D context\");\r\n                }\r\n                ctx.drawImage(image, 0, 0);\r\n\r\n                // Extract pixel data (RGBA per pixel)\r\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n                resolve({ bits: new Uint8Array(imageData.data.buffer), width: imageData.width });\r\n            } catch (error) {\r\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                reject(`Error loading image ${image.src} with exception: ${error}`);\r\n            }\r\n        };\r\n        image.onerror = (error) => {\r\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n            reject(`Error loading image ${image.src} with exception: ${error}`);\r\n        };\r\n\r\n        image.crossOrigin = \"anonymous\"; // To avoid CORS issues\r\n        let objectUrl: string | undefined;\r\n        if (typeof rootUrlOrData === \"string\") {\r\n            // old behavior: URL + filename\r\n            if (!filename) {\r\n                throw new Error(\"filename is required when using a URL\");\r\n            }\r\n            image.src = rootUrlOrData + filename;\r\n        } else {\r\n            // new behavior: Uint8Array\r\n            const blob = new Blob([rootUrlOrData as any], { type: \"image/webp\" });\r\n            objectUrl = URL.createObjectURL(blob);\r\n            image.src = objectUrl;\r\n        }\r\n    });\r\n    return await promise;\r\n}\r\n\r\nasync function ParseSogDatas(data: SOGRootData, imageDataArrays: IWebPImage[], scene: Scene): Promise<IParsedSplat> {\r\n    const splatCount = data.count ? data.count : data.means.shape[0];\r\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\r\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\r\n\r\n    const position = new Float32Array(buffer);\r\n    const scale = new Float32Array(buffer);\r\n    const rgba = new Uint8ClampedArray(buffer);\r\n    const rot = new Uint8ClampedArray(buffer);\r\n\r\n    // Undo the symmetric log transform used at encode time:\r\n    const unlog = (n: number) => Math.sign(n) * (Math.exp(Math.abs(n)) - 1);\r\n\r\n    const meansl = imageDataArrays[0].bits;\r\n    const meansu = imageDataArrays[1].bits;\r\n    // Check that data.means.mins is an array\r\n    if (!Array.isArray(data.means.mins) || !Array.isArray(data.means.maxs)) {\r\n        throw new Error(\"Missing arrays in SOG data.\");\r\n    }\r\n\r\n    // --- Positions\r\n    for (let i = 0; i < splatCount; i++) {\r\n        const index = i * 4;\r\n        for (let j = 0; j < 3; j++) {\r\n            const meansMin = data.means.mins[j];\r\n            const meansMax = data.means.maxs[j];\r\n            const meansup = meansu[index + j];\r\n            const meanslow = meansl[index + j];\r\n            const q = (meansup << 8) | meanslow;\r\n            const n = Scalar.Lerp(meansMin, meansMax, q / 65535);\r\n            position[i * 8 + j] = unlog(n);\r\n        }\r\n    }\r\n\r\n    // --- Scales\r\n    const scales = imageDataArrays[2].bits;\r\n    if (data.version === 2) {\r\n        if (!data.scales.codebook) {\r\n            throw new Error(\"Missing codebook in SOG version 2 scales data.\");\r\n        }\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 3; j++) {\r\n                const sc = data.scales.codebook[scales[index + j]];\r\n                const sce = Math.exp(sc);\r\n                scale[i * 8 + 3 + j] = sce;\r\n            }\r\n        }\r\n    } else {\r\n        if (!Array.isArray(data.scales.mins) || !Array.isArray(data.scales.maxs)) {\r\n            throw new Error(\"Missing arrays in SOG scales data.\");\r\n        }\r\n\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 3; j++) {\r\n                const sc = scales[index + j];\r\n                const lsc = Scalar.Lerp(data.scales.mins[j], data.scales.maxs[j], sc / 255);\r\n                const lsce = Math.exp(lsc);\r\n                scale[i * 8 + 3 + j] = lsce;\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Colors/SH0\r\n    const colors = imageDataArrays[4].bits;\r\n    if (data.version === 2) {\r\n        if (!data.sh0.codebook) {\r\n            throw new Error(\"Missing codebook in SOG version 2 sh0 data.\");\r\n        }\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 3; j++) {\r\n                const component = 0.5 + data.sh0.codebook[colors[index + j]] * SH_C0;\r\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * component)));\r\n            }\r\n            rgba[i * 32 + 24 + 3] = colors[index + 3];\r\n        }\r\n    } else {\r\n        if (!Array.isArray(data.sh0.mins) || !Array.isArray(data.sh0.maxs)) {\r\n            throw new Error(\"Missing arrays in SOG sh0 data.\");\r\n        }\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const index = i * 4;\r\n            for (let j = 0; j < 4; j++) {\r\n                const colorsMin = data.sh0.mins[j];\r\n                const colorsMax = data.sh0.maxs[j];\r\n\r\n                const colort = colors[index + j];\r\n                const c = Scalar.Lerp(colorsMin, colorsMax, colort / 255);\r\n\r\n                let csh;\r\n                if (j < 3) {\r\n                    csh = 0.5 + c * SH_C0;\r\n                } else {\r\n                    csh = 1.0 / (1.0 + Math.exp(-c));\r\n                }\r\n\r\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * csh)));\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Rotations\r\n    // Dequantize the stored three components:\r\n    const toComp = (c: number) => ((c / 255 - 0.5) * 2.0) / Math.SQRT2;\r\n\r\n    const quatArray = imageDataArrays[3].bits;\r\n    for (let i = 0; i < splatCount; i++) {\r\n        const quatsr = quatArray[i * 4 + 0];\r\n        const quatsg = quatArray[i * 4 + 1];\r\n        const quatsb = quatArray[i * 4 + 2];\r\n        const quatsa = quatArray[i * 4 + 3];\r\n\r\n        const a = toComp(quatsr);\r\n        const b = toComp(quatsg);\r\n        const c = toComp(quatsb);\r\n\r\n        const mode = quatsa - 252; // 0..3 (R,G,B,A is one of the four components)\r\n\r\n        // Reconstruct the omitted component so that ||q|| = 1 and w.l.o.g. the omitted one is non-negative\r\n        const t = a * a + b * b + c * c;\r\n        const d = Math.sqrt(Math.max(0, 1 - t));\r\n\r\n        // Place components according to mode\r\n        let q: [number, number, number, number];\r\n        switch (mode) {\r\n            case 0:\r\n                q = [d, a, b, c];\r\n                break; // omitted = x\r\n            case 1:\r\n                q = [a, d, b, c];\r\n                break; // omitted = y\r\n            case 2:\r\n                q = [a, b, d, c];\r\n                break; // omitted = z\r\n            case 3:\r\n                q = [a, b, c, d];\r\n                break; // omitted = w\r\n            default:\r\n                throw new Error(\"Invalid quaternion mode\");\r\n        }\r\n\r\n        rot[i * 32 + 28 + 0] = q[0] * 127.5 + 127.5;\r\n        rot[i * 32 + 28 + 1] = q[1] * 127.5 + 127.5;\r\n        rot[i * 32 + 28 + 2] = q[2] * 127.5 + 127.5;\r\n        rot[i * 32 + 28 + 3] = q[3] * 127.5 + 127.5;\r\n    }\r\n\r\n    // --- SH\r\n    if (data.shN) {\r\n        const coeffCounts = [0, 3, 8, 15];\r\n        const coeffs = data.shN.bands ? coeffCounts[data.shN.bands] : data.shN.shape[1] / 3; // 3 components per coeff\r\n        const shCentroids = imageDataArrays[5].bits;\r\n        const shLabelsData = imageDataArrays[6].bits;\r\n        const shCentroidsWidth = imageDataArrays[5].width;\r\n\r\n        const shComponentCount = coeffs * 3;\r\n\r\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n        //let shIndexRead = byteOffset;\r\n\r\n        // sh is an array of uint8array that will be used to create sh textures\r\n        const sh: Uint8Array[] = [];\r\n\r\n        const engine = scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n        const height = Math.ceil(splatCount / width);\r\n        // create array for the number of textures needed.\r\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n            sh.push(texture);\r\n        }\r\n\r\n        if (data.version === 2) {\r\n            if (!data.shN.codebook) {\r\n                throw new Error(\"Missing codebook in SOG version 2 shN data.\");\r\n            }\r\n\r\n            for (let i = 0; i < splatCount; i++) {\r\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\r\n                const u = (n % 64) * coeffs;\r\n                const v = Math.floor(n / 64);\r\n\r\n                for (let k = 0; k < coeffs; k++) {\r\n                    for (let j = 0; j < 3; j++) {\r\n                        const shIndexWrite = k * 3 + j;\r\n                        const textureIndex = Math.floor(shIndexWrite / 16);\r\n                        const shArray = sh[textureIndex];\r\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n\r\n                        const shValue = data.shN.codebook[shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4]] * 127.5 + 127.5;\r\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            for (let i = 0; i < splatCount; i++) {\r\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\r\n                const u = (n % 64) * coeffs;\r\n                const v = Math.floor(n / 64);\r\n                const shMin = data.shN.mins as number;\r\n                const shMax = data.shN.maxs as number;\r\n\r\n                for (let j = 0; j < 3; j++) {\r\n                    for (let k = 0; k < coeffs / 3; k++) {\r\n                        const shIndexWrite = k * 3 + j;\r\n                        const textureIndex = Math.floor(shIndexWrite / 16);\r\n                        const shArray = sh[textureIndex];\r\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n\r\n                        const shValue = Scalar.Lerp(shMin, shMax, shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4] / 255) * 127.5 + 127.5;\r\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return await new Promise((resolve) => {\r\n            resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, sh: sh });\r\n        });\r\n    }\r\n\r\n    return await new Promise((resolve) => {\r\n        resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false });\r\n    });\r\n}\r\n\r\n/**\r\n * Parse SOG data from either a SOGRootData object (with webp files loaded from rootUrl) or from a Map of filenames to Uint8Array file data (including meta.json)\r\n * @param dataOrFiles Either the SOGRootData or a Map of filenames to Uint8Array file data (including meta.json)\r\n * @param rootUrl Base URL to load webp files from (if dataOrFiles is SOGRootData)\r\n * @param scene The Babylon.js scene\r\n * @returns Parsed data\r\n */\r\nexport async function ParseSogMeta(dataOrFiles: SOGRootData | Map<string, Uint8Array>, rootUrl: string, scene: Scene): Promise<IParsedSplat> {\r\n    let data: SOGRootData;\r\n    let files: Map<string, Uint8Array> | undefined;\r\n\r\n    if (dataOrFiles instanceof Map) {\r\n        files = dataOrFiles;\r\n\r\n        const metaFile = files.get(\"meta.json\");\r\n        if (!metaFile) {\r\n            throw new Error(\"meta.json not found in files Map\");\r\n        }\r\n\r\n        data = JSON.parse(new TextDecoder().decode(metaFile)) as SOGRootData;\r\n    } else {\r\n        data = dataOrFiles;\r\n    }\r\n\r\n    // Collect all file names\r\n    const urls = [...data.means.files, ...data.scales.files, ...data.quats.files, ...data.sh0.files];\r\n    if (data.shN) {\r\n        urls.push(...data.shN.files);\r\n    }\r\n\r\n    // Load webp images in parallel\r\n    const imageDataArrays: IWebPImage[] = await Promise.all(\r\n        urls.map(async (fileName) => {\r\n            if (files && files.has(fileName)) {\r\n                // load from in-memory Uint8Array\r\n                const fileData = files.get(fileName)!;\r\n                return await LoadWebpImageData(fileData, fileName, scene.getEngine());\r\n            } else {\r\n                // fallback: load from URL\r\n                return await LoadWebpImageData(rootUrl, fileName, scene.getEngine());\r\n            }\r\n        })\r\n    );\r\n\r\n    return await ParseSogDatas(data, imageDataArrays, scene);\r\n}\r\n","/* eslint-disable @typescript-eslint/promise-function-async*/\r\n/* eslint-disable @typescript-eslint/naming-convention */\r\nimport type { ISceneLoaderPluginAsync, ISceneLoaderPluginFactory, ISceneLoaderAsyncResult, ISceneLoaderProgressEvent, SceneLoaderPluginOptions } from \"core/Loading/sceneLoader\";\r\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\r\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\r\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\r\nimport { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { Vector3 } from \"core/Maths/math.vector\";\r\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\r\nimport { Color4 } from \"core/Maths/math.color\";\r\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\r\nimport type { SPLATLoadingOptions } from \"./splatLoadingOptions\";\r\nimport type { GaussianSplattingMaterial } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\r\nimport { ParseSpz } from \"./spz\";\r\nimport { Mode } from \"./splatDefs\";\r\nimport type { IParsedSplat } from \"./splatDefs\";\r\nimport { ParseSogMeta } from \"./sog\";\r\nimport type { SOGRootData } from \"./sog\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { ArcRotateCamera } from \"core/Cameras/arcRotateCamera\";\r\n\r\ndeclare module \"core/Loading/sceneLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface SceneLoaderPluginOptions {\r\n        /**\r\n         * Defines options for the splat loader.\r\n         */\r\n        [SPLATFileLoaderMetadata.name]: Partial<SPLATLoadingOptions>;\r\n    }\r\n}\r\n\r\n// FFlate access\r\ndeclare const fflate: any;\r\n\r\n/**\r\n * @experimental\r\n * SPLAT file type loader.\r\n * This is a babylon scene loader plugin.\r\n */\r\nexport class SPLATFileLoader implements ISceneLoaderPluginAsync, ISceneLoaderPluginFactory {\r\n    /**\r\n     * Defines the name of the plugin.\r\n     */\r\n    public readonly name = SPLATFileLoaderMetadata.name;\r\n\r\n    private _assetContainer: Nullable<AssetContainer> = null;\r\n\r\n    private readonly _loadingOptions: Readonly<SPLATLoadingOptions>;\r\n    /**\r\n     * Defines the extensions the splat loader is able to load.\r\n     * force data to come in as an ArrayBuffer\r\n     */\r\n    public readonly extensions = SPLATFileLoaderMetadata.extensions;\r\n\r\n    /**\r\n     * Creates loader for gaussian splatting files\r\n     * @param loadingOptions options for loading and parsing splat and PLY files.\r\n     */\r\n    constructor(loadingOptions: Partial<Readonly<SPLATLoadingOptions>> = SPLATFileLoader._DefaultLoadingOptions) {\r\n        this._loadingOptions = loadingOptions;\r\n    }\r\n\r\n    private static readonly _DefaultLoadingOptions = {\r\n        keepInRam: false,\r\n        flipY: false,\r\n    } as const satisfies SPLATLoadingOptions;\r\n\r\n    /** @internal */\r\n    createPlugin(options: SceneLoaderPluginOptions): ISceneLoaderPluginAsync {\r\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\r\n    }\r\n\r\n    /**\r\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\r\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\r\n     * @param scene the scene the meshes should be added to\r\n     * @param data the gaussian splatting data to load\r\n     * @param rootUrl root url to load from\r\n     * @param _onProgress callback called while file is loading\r\n     * @param _fileName Defines the name of the file to load\r\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\r\n     */\r\n    public async importMeshAsync(\r\n        meshesNames: any,\r\n        scene: Scene,\r\n        data: any,\r\n        rootUrl: string,\r\n        _onProgress?: (event: ISceneLoaderProgressEvent) => void,\r\n        _fileName?: string\r\n    ): Promise<ISceneLoaderAsyncResult> {\r\n        // eslint-disable-next-line github/no-then\r\n        return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\r\n            return {\r\n                meshes: meshes,\r\n                particleSystems: [],\r\n                skeletons: [],\r\n                animationGroups: [],\r\n                transformNodes: [],\r\n                geometries: [],\r\n                lights: [],\r\n                spriteManagers: [],\r\n            };\r\n        });\r\n    }\r\n\r\n    private static _BuildPointCloud(pointcloud: PointsCloudSystem, data: ArrayBuffer): boolean {\r\n        if (!data.byteLength) {\r\n            return false;\r\n        }\r\n        const uBuffer = new Uint8Array(data);\r\n        const fBuffer = new Float32Array(data);\r\n\r\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const pointcloudfunc = function (particle: any, i: number) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            particle.position = new Vector3(x, y, z);\r\n\r\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n            particle.color = new Color4(r, g, b, 1);\r\n        };\r\n\r\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\r\n        return true;\r\n    }\r\n\r\n    private static _BuildMesh(scene: Scene, parsedPLY: IParsedSplat): Mesh {\r\n        const mesh = new Mesh(\"PLYMesh\", scene);\r\n\r\n        const uBuffer = new Uint8Array(parsedPLY.data);\r\n        const fBuffer = new Float32Array(parsedPLY.data);\r\n\r\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\r\n        const vertexCount = uBuffer.length / rowLength;\r\n\r\n        const positions = [];\r\n\r\n        const vertexData = new VertexData();\r\n        for (let i = 0; i < vertexCount; i++) {\r\n            const x = fBuffer[8 * i + 0];\r\n            const y = fBuffer[8 * i + 1];\r\n            const z = fBuffer[8 * i + 2];\r\n            positions.push(x, y, z);\r\n        }\r\n\r\n        if (parsedPLY.hasVertexColors) {\r\n            const colors = new Float32Array(vertexCount * 4);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\r\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\r\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\r\n                colors[i * 4 + 0] = r;\r\n                colors[i * 4 + 1] = g;\r\n                colors[i * 4 + 2] = b;\r\n                colors[i * 4 + 3] = 1;\r\n            }\r\n            vertexData.colors = colors;\r\n        }\r\n\r\n        vertexData.positions = positions;\r\n        vertexData.indices = parsedPLY.faces!;\r\n\r\n        vertexData.applyToMesh(mesh);\r\n        return mesh;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax, @typescript-eslint/naming-convention\r\n    private async _unzipWithFFlateAsync(data: Uint8Array): Promise<Map<string, Uint8Array>> {\r\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\r\n        // @ts-ignore\r\n        let fflate = this._loadingOptions.fflate as typeof import(\"fflate\");\r\n        // ensure fflate is loaded\r\n        if (!fflate) {\r\n            if (typeof (window as any).fflate === \"undefined\") {\r\n                await Tools.LoadScriptAsync(this._loadingOptions.deflateURL ?? \"https://unpkg.com/fflate/umd/index.js\");\r\n            }\r\n            fflate = (window as any).fflate as typeof fflate;\r\n        }\r\n\r\n        const { unzipSync } = fflate;\r\n\r\n        const unzipped = unzipSync(data) as Record<string, Uint8Array>; // { [filename: string]: Uint8Array }\r\n\r\n        const files = new Map<string, Uint8Array>();\r\n        for (const [name, content] of Object.entries(unzipped)) {\r\n            files.set(name, content);\r\n        }\r\n        return files;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    private _parseAsync(meshesNames: any, scene: Scene, data: any, rootUrl: string): Promise<Array<AbstractMesh>> {\r\n        const babylonMeshesArray: Array<Mesh> = []; //The mesh for babylon\r\n\r\n        const makeGSFromParsedSOG = (parsedSOG: IParsedSplat) => {\r\n            scene._blockEntityCollection = !!this._assetContainer;\r\n            const gaussianSplatting = this._loadingOptions.gaussianSplattingMesh ?? new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n            gaussianSplatting._parentContainer = this._assetContainer;\r\n            babylonMeshesArray.push(gaussianSplatting);\r\n            gaussianSplatting.updateData(parsedSOG.data, parsedSOG.sh, { flipY: false });\r\n            gaussianSplatting.scaling.y *= -1;\r\n            gaussianSplatting.computeWorldMatrix(true);\r\n            scene._blockEntityCollection = false;\r\n        };\r\n\r\n        // check if data is json string\r\n        if (typeof data === \"string\") {\r\n            const dataSOG = JSON.parse(data) as SOGRootData;\r\n            if (dataSOG && dataSOG.means && dataSOG.scales && dataSOG.quats && dataSOG.sh0) {\r\n                return new Promise((resolve) => {\r\n                    ParseSogMeta(dataSOG, rootUrl, scene)\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        .then((parsedSOG) => {\r\n                            makeGSFromParsedSOG(parsedSOG);\r\n                            resolve(babylonMeshesArray);\r\n                        })\r\n                        // eslint-disable-next-line github/no-then\r\n                        .catch(() => {\r\n                            throw new Error(\"Failed to parse SOG data.\");\r\n                        });\r\n                });\r\n            }\r\n        }\r\n\r\n        const u8 = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\r\n        // ZIP signature check for SOG\r\n        if (u8[0] === 0x50 && u8[1] === 0x4b) {\r\n            return new Promise((resolve) => {\r\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                this._unzipWithFFlateAsync(u8).then((files) => {\r\n                    ParseSogMeta(files, rootUrl, scene)\r\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                        .then((parsedSOG) => {\r\n                            makeGSFromParsedSOG(parsedSOG);\r\n                            resolve(babylonMeshesArray);\r\n                        }) // eslint-disable-next-line github/no-then\r\n                        .catch(() => {\r\n                            throw new Error(\"Failed to parse SOG zip data.\");\r\n                        });\r\n                });\r\n            });\r\n        }\r\n\r\n        const readableStream = new ReadableStream({\r\n            start(controller) {\r\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\r\n                controller.close();\r\n            },\r\n        });\r\n\r\n        // Use GZip DecompressionStream\r\n        const decompressionStream = new DecompressionStream(\"gzip\");\r\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\r\n\r\n        return new Promise((resolve) => {\r\n            new Response(decompressedStream)\r\n                .arrayBuffer()\r\n                // eslint-disable-next-line github/no-then\r\n                .then((buffer) => {\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    ParseSpz(buffer, scene, this._loadingOptions).then((parsedSPZ) => {\r\n                        scene._blockEntityCollection = !!this._assetContainer;\r\n                        const gaussianSplatting =\r\n                            this._loadingOptions.gaussianSplattingMesh ?? new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                        if (parsedSPZ.trainedWithAntialiasing) {\r\n                            const gsMaterial = gaussianSplatting.material as GaussianSplattingMaterial;\r\n                            gsMaterial.kernelSize = 0.1;\r\n                            gsMaterial.compensation = true;\r\n                        }\r\n                        gaussianSplatting._parentContainer = this._assetContainer;\r\n                        babylonMeshesArray.push(gaussianSplatting);\r\n                        gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh, { flipY: false });\r\n                        if (!this._loadingOptions.flipY) {\r\n                            gaussianSplatting.scaling.y *= -1.0;\r\n                            gaussianSplatting.computeWorldMatrix(true);\r\n                        }\r\n                        scene._blockEntityCollection = false;\r\n                        this.applyAutoCameraLimits(parsedSPZ, scene);\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch(() => {\r\n                    // Catch any decompression errors\r\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n                    SPLATFileLoader._ConvertPLYToSplat(data as ArrayBuffer).then(async (parsedPLY) => {\r\n                        scene._blockEntityCollection = !!this._assetContainer;\r\n                        switch (parsedPLY.mode) {\r\n                            case Mode.Splat:\r\n                                {\r\n                                    const gaussianSplatting =\r\n                                        this._loadingOptions.gaussianSplattingMesh ?? new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\r\n                                    gaussianSplatting._parentContainer = this._assetContainer;\r\n                                    babylonMeshesArray.push(gaussianSplatting);\r\n                                    gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh, { flipY: false });\r\n                                    gaussianSplatting.scaling.y *= -1.0;\r\n\r\n                                    if (parsedPLY.chirality === \"RightHanded\") {\r\n                                        gaussianSplatting.scaling.y *= -1.0;\r\n                                    }\r\n\r\n                                    switch (parsedPLY.upAxis) {\r\n                                        case \"X\":\r\n                                            gaussianSplatting.rotation = new Vector3(0, 0, Math.PI / 2);\r\n                                            break;\r\n                                        case \"Y\":\r\n                                            gaussianSplatting.rotation = new Vector3(0, 0, Math.PI);\r\n                                            break;\r\n                                        case \"Z\":\r\n                                            gaussianSplatting.rotation = new Vector3(-Math.PI / 2, Math.PI, 0);\r\n                                            break;\r\n                                    }\r\n                                    gaussianSplatting.computeWorldMatrix(true);\r\n                                }\r\n                                break;\r\n                            case Mode.PointCloud:\r\n                                {\r\n                                    const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\r\n                                    if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\r\n                                        // eslint-disable-next-line github/no-then\r\n                                        await pointcloud.buildMeshAsync().then((mesh) => {\r\n                                            babylonMeshesArray.push(mesh);\r\n                                        });\r\n                                    } else {\r\n                                        pointcloud.dispose();\r\n                                    }\r\n                                }\r\n                                break;\r\n                            case Mode.Mesh:\r\n                                {\r\n                                    if (parsedPLY.faces) {\r\n                                        babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\r\n                                    } else {\r\n                                        throw new Error(\"PLY mesh doesn't contain face informations.\");\r\n                                    }\r\n                                }\r\n                                break;\r\n                            default:\r\n                                throw new Error(\"Unsupported Splat mode\");\r\n                        }\r\n                        scene._blockEntityCollection = false;\r\n                        this.applyAutoCameraLimits(parsedPLY, scene);\r\n                        resolve(babylonMeshesArray);\r\n                    });\r\n                });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Applies camera limits based on parsed meta data\r\n     * @param meta parsed splat meta data\r\n     * @param scene\r\n     */\r\n    private applyAutoCameraLimits(meta: IParsedSplat, scene: Scene): void {\r\n        if (this._loadingOptions.disableAutoCameraLimits) {\r\n            return;\r\n        }\r\n        if ((meta.safeOrbitCameraRadiusMin !== undefined || meta.safeOrbitCameraElevationMinMax !== undefined) && scene.activeCamera?.getClassName() === \"ArcRotateCamera\") {\r\n            const arcCam = scene.activeCamera as ArcRotateCamera;\r\n            if (meta.safeOrbitCameraElevationMinMax) {\r\n                arcCam.lowerBetaLimit = Math.PI * 0.5 - meta.safeOrbitCameraElevationMinMax[1];\r\n                arcCam.upperBetaLimit = Math.PI * 0.5 - meta.safeOrbitCameraElevationMinMax[0];\r\n            }\r\n\r\n            if (meta.safeOrbitCameraRadiusMin) {\r\n                arcCam.lowerRadiusLimit = meta.safeOrbitCameraRadiusMin;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load into an asset container.\r\n     * @param scene The scene to load into\r\n     * @param data The data to import\r\n     * @param rootUrl The root url for scene and resources\r\n     * @returns The loaded asset container\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadAssetContainerAsync(scene: Scene, data: string, rootUrl: string): Promise<AssetContainer> {\r\n        const container = new AssetContainer(scene);\r\n        this._assetContainer = container;\r\n\r\n        return (\r\n            this.importMeshAsync(null, scene, data, rootUrl)\r\n                // eslint-disable-next-line github/no-then\r\n                .then((result) => {\r\n                    for (const mesh of result.meshes) {\r\n                        container.meshes.push(mesh);\r\n                    }\r\n                    // mesh material will be null before 1st rendered frame.\r\n                    this._assetContainer = null;\r\n                    return container;\r\n                })\r\n                // eslint-disable-next-line github/no-then\r\n                .catch((ex) => {\r\n                    this._assetContainer = null;\r\n                    throw ex;\r\n                })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Imports all objects from the loaded OBJ data and adds them to the scene\r\n     * @param scene the scene the objects should be added to\r\n     * @param data the OBJ data to load\r\n     * @param rootUrl root url to load from\r\n     * @returns a promise which completes when objects have been loaded to the scene\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\r\n    public loadAsync(scene: Scene, data: string, rootUrl: string): Promise<void> {\r\n        //Get the 3D model\r\n        // eslint-disable-next-line github/no-then\r\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\r\n            // return void\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\r\n     * Converts a .ply data array buffer to splat\r\n     * if data array buffer is not ply, returns the original buffer\r\n     * @param data the .ply data to load\r\n     * @returns the loaded splat buffer\r\n     */\r\n    private static _ConvertPLYToSplat(data: ArrayBuffer): Promise<IParsedSplat> {\r\n        const ubuf = new Uint8Array(data);\r\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\r\n        const headerEnd = \"end_header\\n\";\r\n        const headerEndIndex = header.indexOf(headerEnd);\r\n        if (headerEndIndex < 0 || !header) {\r\n            // standard splat\r\n            return new Promise((resolve) => {\r\n                resolve({ mode: Mode.Splat, data: data, rawSplat: true });\r\n            });\r\n        }\r\n\r\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)![1]);\r\n        const faceElement = /element face (\\d+)\\n/.exec(header);\r\n        let faceCount = 0;\r\n        if (faceElement) {\r\n            faceCount = parseInt(faceElement[1]);\r\n        }\r\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\r\n        let chunkCount = 0;\r\n        if (chunkElement) {\r\n            chunkCount = parseInt(chunkElement[1]);\r\n        }\r\n\r\n        let rowVertexOffset = 0;\r\n        let rowChunkOffset = 0;\r\n        const offsets: Record<string, number> = {\r\n            double: 8,\r\n            int: 4,\r\n            uint: 4,\r\n            float: 4,\r\n            short: 2,\r\n            ushort: 2,\r\n            uchar: 1,\r\n            list: 0,\r\n        };\r\n\r\n        type PlyProperty = {\r\n            name: string;\r\n            type: string;\r\n            offset: number;\r\n        };\r\n\r\n        const ElementMode: Record<string, number> = {\r\n            Vertex: 0,\r\n            Chunk: 1,\r\n            SH: 2,\r\n            Float_Tuple: 3,\r\n            Float: 4,\r\n            Uchar: 5,\r\n        };\r\n\r\n        let chunkMode = ElementMode.Chunk;\r\n        const vertexProperties: PlyProperty[] = [];\r\n        const chunkProperties: PlyProperty[] = [];\r\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\r\n        const metaData: Partial<IParsedSplat> = {};\r\n        for (const prop of filtered) {\r\n            if (prop.startsWith(\"property \")) {\r\n                const [, type, name] = prop.split(\" \");\r\n\r\n                if (chunkMode == ElementMode.Chunk) {\r\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\r\n                    rowChunkOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.Vertex) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                    rowVertexOffset += offsets[type];\r\n                } else if (chunkMode == ElementMode.SH) {\r\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\r\n                } else if (chunkMode == ElementMode.Float_Tuple) {\r\n                    const view = new DataView(data, rowChunkOffset, offsets.float * 2);\r\n                    metaData.safeOrbitCameraElevationMinMax = [view.getFloat32(0, true), view.getFloat32(4, true)];\r\n                } else if (chunkMode == ElementMode.Float) {\r\n                    const view = new DataView(data, rowChunkOffset, offsets.float);\r\n                    metaData.safeOrbitCameraRadiusMin = view.getFloat32(0, true);\r\n                } else if (chunkMode == ElementMode.Uchar) {\r\n                    const view = new DataView(data, rowChunkOffset, offsets.uchar);\r\n                    if (name == \"up_axis\") {\r\n                        metaData.upAxis = view.getUint8(0) == 0 ? \"X\" : view.getUint8(0) == 1 ? \"Y\" : \"Z\";\r\n                    } else if (name == \"chirality\") {\r\n                        metaData.chirality = view.getUint8(0) == 0 ? \"LeftHanded\" : \"RightHanded\";\r\n                    }\r\n                }\r\n\r\n                if (!offsets[type]) {\r\n                    Logger.Warn(`Unsupported property type: ${type}.`);\r\n                }\r\n            } else if (prop.startsWith(\"element \")) {\r\n                const [, type] = prop.split(\" \");\r\n                if (type == \"chunk\") {\r\n                    chunkMode = ElementMode.Chunk;\r\n                } else if (type == \"vertex\") {\r\n                    chunkMode = ElementMode.Vertex;\r\n                } else if (type == \"sh\") {\r\n                    chunkMode = ElementMode.SH;\r\n                } else if (type == \"safe_orbit_camera_elevation_min_max_radians\") {\r\n                    chunkMode = ElementMode.Float_Tuple;\r\n                } else if (type == \"safe_orbit_camera_radius_min\") {\r\n                    chunkMode = ElementMode.Float;\r\n                } else if (type == \"up_axis\" || type == \"chirality\") {\r\n                    chunkMode = ElementMode.Uchar;\r\n                }\r\n            }\r\n        }\r\n\r\n        const rowVertexLength = rowVertexOffset;\r\n        const rowChunkLength = rowChunkOffset;\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return (GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data) as any).then(async (splatsData: any) => {\r\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\r\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\r\n            // faces\r\n            const faces: number[] = [];\r\n            if (faceCount) {\r\n                for (let i = 0; i < faceCount; i++) {\r\n                    const faceVertexCount = dataView.getUint8(offset);\r\n                    if (faceVertexCount != 3) {\r\n                        continue; // only support triangles\r\n                    }\r\n                    offset += 1;\r\n\r\n                    for (let j = 0; j < faceVertexCount; j++) {\r\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\r\n                        faces.push(vertexIndex);\r\n                    }\r\n                    offset += 12;\r\n                }\r\n            }\r\n\r\n            // early exit for chunked/quantized ply\r\n            if (chunkCount) {\r\n                return await new Promise((resolve) => {\r\n                    resolve({ mode: Mode.Splat, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false, compressed: true, rawSplat: false });\r\n                });\r\n            }\r\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\r\n            // if faces are found, then it's a standard mesh\r\n            let propertyCount = 0;\r\n            let propertyColorCount = 0;\r\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\r\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\r\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\r\n                const property = vertexProperties[propertyIndex];\r\n                if (splatProperties.includes(property.name)) {\r\n                    propertyCount++;\r\n                }\r\n                if (splatColorProperties.includes(property.name)) {\r\n                    propertyColorCount++;\r\n                }\r\n            }\r\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\r\n            const currentMode = faceCount ? Mode.Mesh : hasMandatoryProperties ? Mode.Splat : Mode.PointCloud;\r\n            // parsed ready ready to be used as a splat\r\n            return await new Promise((resolve) => {\r\n                resolve({\r\n                    ...metaData,\r\n                    mode: currentMode,\r\n                    data: splatsData.buffer,\r\n                    sh: splatsData.sh,\r\n                    faces: faces,\r\n                    hasVertexColors: !!propertyColorCount,\r\n                    compressed: false,\r\n                    rawSplat: false,\r\n                });\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n// Add this loader into the register plugin\r\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\r\n","/* eslint-disable @typescript-eslint/promise-function-async */\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { SPLATLoadingOptions } from \"./splatLoadingOptions\";\r\nimport { Mode } from \"./splatDefs\";\r\nimport type { IParsedSplat } from \"./splatDefs\";\r\n\r\n/**\r\n * Parses SPZ data and returns a promise resolving to an IParsedPLY object.\r\n * @param data The ArrayBuffer containing SPZ data.\r\n * @param scene The Babylon.js scene.\r\n * @param loadingOptions Options for loading Gaussian Splatting files.\r\n * @returns A promise resolving to the parsed SPZ data.\r\n */\r\nexport function ParseSpz(data: ArrayBuffer, scene: Scene, loadingOptions: SPLATLoadingOptions): Promise<IParsedSplat> {\r\n    const ubuf = new Uint8Array(data);\r\n    const ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]\r\n    // debug infos\r\n    const splatCount = ubufu32[2];\r\n\r\n    const shDegree = ubuf[12];\r\n    const fractionalBits = ubuf[13];\r\n    const flags = ubuf[14];\r\n    const reserved = ubuf[15];\r\n    const version = ubufu32[1];\r\n\r\n    // check magic and version\r\n    if (reserved || ubufu32[0] != 0x5053474e || (version != 2 && version != 3)) {\r\n        // reserved must be 0\r\n        return new Promise((resolve) => {\r\n            resolve({ mode: Mode.Reject, data: buffer, hasVertexColors: false });\r\n        });\r\n    }\r\n\r\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\r\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\r\n\r\n    const positionScale = 1.0 / (1 << fractionalBits);\r\n\r\n    const int32View = new Int32Array(1);\r\n    const uint8View = new Uint8Array(int32View.buffer);\r\n    const read24bComponent = function (u8: Uint8Array, offset: number) {\r\n        uint8View[0] = u8[offset + 0];\r\n        uint8View[1] = u8[offset + 1];\r\n        uint8View[2] = u8[offset + 2];\r\n        uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\r\n        return int32View[0] * positionScale;\r\n    };\r\n\r\n    let byteOffset = 16;\r\n\r\n    const position = new Float32Array(buffer);\r\n    const scale = new Float32Array(buffer);\r\n    const rgba = new Uint8ClampedArray(buffer);\r\n    const rot = new Uint8ClampedArray(buffer);\r\n\r\n    // positions\r\n    for (let i = 0; i < splatCount; i++) {\r\n        position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\r\n        position[i * 8 + 1] = read24bComponent(ubuf, byteOffset + 3);\r\n        position[i * 8 + 2] = read24bComponent(ubuf, byteOffset + 6);\r\n        byteOffset += 9;\r\n    }\r\n\r\n    // colors\r\n    const shC0 = 0.282;\r\n    for (let i = 0; i < splatCount; i++) {\r\n        for (let component = 0; component < 3; component++) {\r\n            const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\r\n            // 0.15 is hard coded value from spz\r\n            // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\r\n            // be useful to represent base colors that are out of range if the higher spherical harmonics bands\r\n            // bring them back into range so we multiply by a smaller value.\r\n            const value = (byteValue - 127.5) / (0.15 * 255);\r\n            rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);\r\n        }\r\n\r\n        rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\r\n    }\r\n    byteOffset += splatCount * 4;\r\n\r\n    // scales\r\n    for (let i = 0; i < splatCount; i++) {\r\n        scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\r\n        scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\r\n        scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\r\n        byteOffset += 3;\r\n    }\r\n\r\n    // convert quaternion\r\n    if (version >= 3) {\r\n        /*\r\n            In version 3, rotations are represented as the smallest three components of the normalized rotation quaternion, for optimal rotation accuracy.\r\n            The largest component can be derived from the others and is not stored. Its index is stored on 2 bits\r\n            and each of the smallest three components is encoded as a 10-bit signed integer.\r\n        */\r\n        const sqrt12 = Math.SQRT1_2;\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const r = [ubuf[byteOffset + 0], ubuf[byteOffset + 1], ubuf[byteOffset + 2], ubuf[byteOffset + 3]];\r\n\r\n            const comp = r[0] + (r[1] << 8) + (r[2] << 16) + (r[3] << 24);\r\n\r\n            const cmask = (1 << 9) - 1;\r\n            const rotation = [];\r\n            const iLargest = comp >>> 30;\r\n            let remaining = comp;\r\n            let sumSquares = 0;\r\n\r\n            for (let i = 3; i >= 0; --i) {\r\n                if (i !== iLargest) {\r\n                    const mag = remaining & cmask;\r\n                    const negbit = (remaining >>> 9) & 0x1;\r\n                    remaining = remaining >>> 10;\r\n\r\n                    rotation[i] = sqrt12 * (mag / cmask);\r\n                    if (negbit === 1) {\r\n                        rotation[i] = -rotation[i];\r\n                    }\r\n\r\n                    // accumulate the sum of squares\r\n                    sumSquares += rotation[i] * rotation[i];\r\n                }\r\n            }\r\n\r\n            const square = 1 - sumSquares;\r\n            rotation[iLargest] = Math.sqrt(Math.max(square, 0));\r\n\r\n            const shuffle = [3, 0, 1, 2]; // shuffle to match the order of the quaternion components in the splat file\r\n            for (let j = 0; j < 4; j++) {\r\n                rot[i * 32 + 28 + j] = Math.round(127.5 + rotation[shuffle[j]] * 127.5);\r\n            }\r\n\r\n            byteOffset += 4;\r\n        }\r\n    } else {\r\n        /*\r\n            In version 2, rotations are represented as the `(x, y, z)` components of the normalized rotation quaternion. The\r\n            `w` component can be derived from the others and is not stored. Each component is encoded as an\r\n            8-bit signed integer.\r\n        */\r\n        for (let i = 0; i < splatCount; i++) {\r\n            const x = ubuf[byteOffset + 0];\r\n            const y = ubuf[byteOffset + 1];\r\n            const z = ubuf[byteOffset + 2];\r\n            const nx = x / 127.5 - 1;\r\n            const ny = y / 127.5 - 1;\r\n            const nz = z / 127.5 - 1;\r\n            rot[i * 32 + 28 + 1] = x;\r\n            rot[i * 32 + 28 + 2] = y;\r\n            rot[i * 32 + 28 + 3] = z;\r\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\r\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\r\n\r\n            byteOffset += 3;\r\n        }\r\n    }\r\n\r\n    //SH\r\n    if (shDegree) {\r\n        // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\r\n        // number of vec3 vector needed per splat\r\n        const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\r\n        // number of component values : 3 per vector3 (45)\r\n        const shComponentCount = shVectorCount * 3;\r\n\r\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\r\n        let shIndexRead = byteOffset;\r\n\r\n        // sh is an array of uint8array that will be used to create sh textures\r\n        const sh: Uint8Array[] = [];\r\n\r\n        const engine = scene.getEngine();\r\n        const width = engine.getCaps().maxTextureSize;\r\n        const height = Math.ceil(splatCount / width);\r\n        // create array for the number of textures needed.\r\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\r\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\r\n            sh.push(texture);\r\n        }\r\n\r\n        for (let i = 0; i < splatCount; i++) {\r\n            for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\r\n                const shValue = ubuf[shIndexRead++];\r\n\r\n                const textureIndex = Math.floor(shIndexWrite / 16);\r\n                const shArray = sh[textureIndex];\r\n\r\n                const byteIndexInTexture = shIndexWrite % 16; // [0..15]\r\n                const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\r\n                shArray[byteIndexInTexture + offsetPerSplat] = shValue;\r\n            }\r\n        }\r\n\r\n        return new Promise((resolve) => {\r\n            resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, sh: sh, trainedWithAntialiasing: !!flags });\r\n        });\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n        resolve({ mode: Mode.Splat, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });\r\n    });\r\n}\r\n"],"names":["SH_C0","async","LoadWebpImageData","rootUrlOrData","filename","engine","promise","Promise","resolve","reject","image","createCanvasImage","Error","objectUrl","onload","canvas","createCanvas","width","height","ctx","getContext","drawImage","imageData","getImageData","bits","Uint8Array","data","buffer","error","src","onerror","crossOrigin","blob","Blob","type","URL","createObjectURL","ParseSogMeta","dataOrFiles","rootUrl","scene","files","Map","metaFile","get","JSON","parse","TextDecoder","decode","urls","means","scales","quats","sh0","shN","push","imageDataArrays","all","map","fileName","has","fileData","getEngine","splatCount","count","shape","ArrayBuffer","position","Float32Array","scale","rgba","Uint8ClampedArray","rot","unlog","n","Math","sign","exp","abs","meansl","meansu","Array","isArray","mins","maxs","i","index","j","meansMin","meansMax","q","Lerp","version","codebook","sc","sce","lsc","lsce","colors","component","max","min","round","colorsMin","colorsMax","colort","c","csh","toComp","SQRT2","quatArray","quatsr","quatsg","quatsb","quatsa","a","b","mode","t","d","sqrt","coeffCounts","coeffs","bands","shCentroids","shLabelsData","shCentroidsWidth","shComponentCount","textureCount","ceil","sh","getCaps","maxTextureSize","textureIndex","texture","u","v","floor","k","shIndexWrite","shArray","byteIndexInTexture","offsetPerSplat","shValue","shMin","shMax","hasVertexColors","ParseSogDatas","SPLATFileLoader","constructor","loadingOptions","_DefaultLoadingOptions","name","_assetContainer","extensions","this","_loadingOptions","createPlugin","options","importMeshAsync","meshesNames","_onProgress","_fileName","_parseAsync","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","_BuildPointCloud","pointcloud","byteLength","uBuffer","fBuffer","vertexCount","length","addPoints","particle","x","y","z","r","g","color","_BuildMesh","parsedPLY","mesh","positions","vertexData","indices","faces","applyToMesh","_unzipWithFFlateAsync","fflate","window","LoadScriptAsync","deflateURL","unzipSync","unzipped","content","Object","entries","set","babylonMeshesArray","makeGSFromParsedSOG","parsedSOG","_blockEntityCollection","gaussianSplatting","gaussianSplattingMesh","keepInRam","_parentContainer","updateData","flipY","scaling","computeWorldMatrix","dataSOG","catch","u8","readableStream","ReadableStream","start","controller","enqueue","close","decompressionStream","DecompressionStream","decompressedStream","pipeThrough","Response","arrayBuffer","ubuf","ubufu32","Uint32Array","slice","shDegree","fractionalBits","flags","reserved","positionScale","int32View","Int32Array","uint8View","read24bComponent","offset","byteOffset","value","Clamp","sqrt12","SQRT1_2","comp","cmask","rotation","iLargest","remaining","sumSquares","mag","negbit","square","shuffle","nx","ny","nz","shIndexRead","trainedWithAntialiasing","ParseSpz","parsedSPZ","gsMaterial","material","kernelSize","compensation","applyAutoCameraLimits","_ConvertPLYToSplat","chirality","upAxis","PI","buildMeshAsync","dispose","meta","disableAutoCameraLimits","undefined","safeOrbitCameraRadiusMin","safeOrbitCameraElevationMinMax","activeCamera","getClassName","arcCam","lowerBetaLimit","upperBetaLimit","lowerRadiusLimit","loadAssetContainerAsync","container","result","ex","loadAsync","header","headerEndIndex","indexOf","rawSplat","parseInt","exec","faceElement","faceCount","chunkElement","chunkCount","rowVertexOffset","rowChunkOffset","offsets","double","int","uint","float","short","ushort","uchar","list","chunkMode","vertexProperties","chunkProperties","filtered","split","metaData","prop","startsWith","view","DataView","getFloat32","getUint8","Warn","rowVertexLength","rowChunkLength","ConvertPLYWithSHToSplatAsync","splatsData","dataView","headerEnd","faceVertexCount","vertexIndex","getUint32","compressed","propertyCount","propertyColorCount","splatProperties","splatColorProperties","propertyIndex","property","includes","hasMandatoryProperties","currentMode"],"ignoreList":[],"sourceRoot":""}