{"version":3,"file":"135.bundle.js","mappings":"wNAaO,MAAMA,UAAoC,IAW7C,WAAAC,CAAYC,GACRC,MAAMD,GACNE,KAAKC,eAAiBD,KAAKE,kBAAkB,iBAAkB,MAC/DF,KAAKG,YAAcH,KAAKE,kBAAkB,cAAe,MAAiB,EAC9E,CAEgB,oBAAAE,CAAqBC,GACjC,MAAMC,EAAuBN,KAAKC,eAAeM,SAASF,GACpDF,EAAcH,KAAKG,YAAYI,SAASF,KAAa,EAErDG,EAAwBH,EAAQI,0BAClC,wBACA,IAMJD,EAAsBE,KAAK,CAAEC,SAAUL,EAAqBK,SAAUR,gBAEtEE,EAAQO,0BAA0B,wBAAyBJ,EAC/D,CACgB,mBAAAK,CAAoBR,GAEhC,MAAMC,EAAuBN,KAAKC,eAAeM,SAASF,GACpDG,EAAwBH,EAAQI,0BAClC,wBACA,IAKJ,IAAK,IAAIK,EAAI,EAAGA,EAAIN,EAAsBO,OAAQD,IAC9C,GAAIN,EAAsBM,GAAGH,WAAaL,EAAqBK,SAAU,CACrEH,EAAsBQ,OAAOF,EAAG,GAEhCT,EAAQO,0BAA0B,wBAAyBJ,GAC3D,KACJ,CAER,CAEO,QAAAS,CAASZ,GACZ,MAAMC,EAAuBN,KAAKC,eAAeM,SAASF,GACpDa,EAAWlB,KAAKG,YAAYI,SAASF,KAAa,EAExD,OAAKC,EAIDa,MAAMD,GACClB,KAAKoB,aAAaf,EAAS,uBAElCa,EAAW,EACXlB,KAAKqB,mBAAmBhB,GAExBL,KAAKsB,eAAehB,EAAsBD,QAG9CL,KAAKuB,IAAIC,gBAAgBnB,KAZrB,IAAOoB,KAAK,wCACLzB,KAAKoB,aAAaf,EAAS,wCAY1C,CAEgB,cAAAqB,CAAerB,GAC3B,MAAMC,EAAuBN,KAAKC,eAAeM,SAASF,GAEpDG,EAAwBH,EAAQI,0BAA0B,wBAAyB,IACzF,IAAK,IAAIK,EAAI,EAAGA,EAAIN,EAAsBO,OAAQD,IAE9C,GAAIN,EAAsBM,GAAGH,WAAaL,EAAqBK,UAEvDL,EAAqBqB,mBAAqBnB,EAAsBM,GAAGX,YAAa,CAEhFH,KAAKsB,eAAehB,EAAsBD,GAE1CG,EAAsBQ,OAAOF,EAAG,GAEhCT,EAAQO,0BAA0B,wBAAyBJ,GAC3DR,KAAK4B,KAAKJ,gBAAgBnB,GAC1BA,EAAQwB,oBAAoB7B,MAC5B,KACJ,CAGZ,CAKgB,YAAA8B,GACZ,MAAO,6BACX,CAEQ,cAAAR,CAAerB,EAAgCI,GACnD,MAAM0B,EAAmB1B,EAAQI,0BAA0B,kCAAmC,IACxFuB,EAAQD,EAAiBE,QAAQhC,EAAeU,WACvC,IAAXqB,IACA/B,EAAeiC,OACfH,EAAiBf,OAAOgB,EAAO,GAE/B3B,EAAQO,0BAA0B,kCAAmCmB,GAK7E,GAEJ,QAAc,8BAAmCnC,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Execution/Animation/flowGraphStopAnimationBlock.ts?"],"sourcesContent":["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { RichTypeAny, RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport type { AnimationGroup } from \"core/Animations/animationGroup\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { FlowGraphAsyncExecutionBlock } from \"core/FlowGraph/flowGraphAsyncExecutionBlock\";\r\n/**\r\n * @experimental\r\n * Block that stops a running animation\r\n */\r\nexport class FlowGraphStopAnimationBlock extends FlowGraphAsyncExecutionBlock {\r\n    /**\r\n     * Input connection: The animation to stop.\r\n     */\r\n    public readonly animationGroup: FlowGraphDataConnection<AnimationGroup>;\r\n\r\n    /**\r\n     * Input connection - if defined (positive integer) the animation will stop at this frame.\r\n     */\r\n    public readonly stopAtFrame: FlowGraphDataConnection<number>;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.animationGroup = this.registerDataInput(\"animationGroup\", RichTypeAny);\r\n        this.stopAtFrame = this.registerDataInput(\"stopAtFrame\", RichTypeNumber, -1);\r\n    }\r\n\r\n    public override _preparePendingTasks(context: FlowGraphContext): void {\r\n        const animationToStopValue = this.animationGroup.getValue(context);\r\n        const stopAtFrame = this.stopAtFrame.getValue(context) ?? -1;\r\n        // get the context variable\r\n        const pendingStopAnimations = context._getGlobalContextVariable(\r\n            \"pendingStopAnimations\",\r\n            [] as {\r\n                uniqueId: number;\r\n                stopAtFrame: number;\r\n            }[]\r\n        );\r\n        // add the animation to the list\r\n        pendingStopAnimations.push({ uniqueId: animationToStopValue.uniqueId, stopAtFrame });\r\n        // set the global context variable\r\n        context._setGlobalContextVariable(\"pendingStopAnimations\", pendingStopAnimations);\r\n    }\r\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\r\n        // remove the animation from the list\r\n        const animationToStopValue = this.animationGroup.getValue(context);\r\n        const pendingStopAnimations = context._getGlobalContextVariable(\r\n            \"pendingStopAnimations\",\r\n            [] as {\r\n                uniqueId: number;\r\n                stopAtFrame: number;\r\n            }[]\r\n        );\r\n        for (let i = 0; i < pendingStopAnimations.length; i++) {\r\n            if (pendingStopAnimations[i].uniqueId === animationToStopValue.uniqueId) {\r\n                pendingStopAnimations.splice(i, 1);\r\n                // set the global context variable\r\n                context._setGlobalContextVariable(\"pendingStopAnimations\", pendingStopAnimations);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    public _execute(context: FlowGraphContext): void {\r\n        const animationToStopValue = this.animationGroup.getValue(context);\r\n        const stopTime = this.stopAtFrame.getValue(context) ?? -1;\r\n        // check the values\r\n        if (!animationToStopValue) {\r\n            Logger.Warn(\"No animation group provided to stop.\");\r\n            return this._reportError(context, \"No animation group provided to stop.\");\r\n        }\r\n        if (isNaN(stopTime)) {\r\n            return this._reportError(context, \"Invalid stop time.\");\r\n        }\r\n        if (stopTime > 0) {\r\n            this._startPendingTasks(context);\r\n        } else {\r\n            this._stopAnimation(animationToStopValue, context);\r\n        }\r\n        // note that out will not be triggered in case of an error\r\n        this.out._activateSignal(context);\r\n    }\r\n\r\n    public override _executeOnTick(context: FlowGraphContext): void {\r\n        const animationToStopValue = this.animationGroup.getValue(context);\r\n        // check each frame if any animation should be stopped\r\n        const pendingStopAnimations = context._getGlobalContextVariable(\"pendingStopAnimations\", [] as { uniqueId: number; stopAtFrame: number }[]);\r\n        for (let i = 0; i < pendingStopAnimations.length; i++) {\r\n            // compare the uniqueId to the animation to stop\r\n            if (pendingStopAnimations[i].uniqueId === animationToStopValue.uniqueId) {\r\n                // check if the current frame is AFTER the stopAtFrame\r\n                if (animationToStopValue.getCurrentFrame() >= pendingStopAnimations[i].stopAtFrame) {\r\n                    // stop the animation\r\n                    this._stopAnimation(animationToStopValue, context);\r\n                    // remove the animation from the list\r\n                    pendingStopAnimations.splice(i, 1);\r\n                    // set the global context variable\r\n                    context._setGlobalContextVariable(\"pendingStopAnimations\", pendingStopAnimations);\r\n                    this.done._activateSignal(context);\r\n                    context._removePendingBlock(this);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.StopAnimation;\r\n    }\r\n\r\n    private _stopAnimation(animationGroup: AnimationGroup, context: FlowGraphContext): void {\r\n        const currentlyRunning = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\r\n        const index = currentlyRunning.indexOf(animationGroup.uniqueId);\r\n        if (index !== -1) {\r\n            animationGroup.stop();\r\n            currentlyRunning.splice(index, 1);\r\n            // update the global context variable\r\n            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunning);\r\n        } else {\r\n            // Logger.Warn(\"Trying to stop an animation that is not running.\");\r\n            // no-op for now. Probably no need to log anything here.\r\n        }\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.StopAnimation, FlowGraphStopAnimationBlock);\r\n"],"names":["FlowGraphStopAnimationBlock","constructor","config","super","this","animationGroup","registerDataInput","stopAtFrame","_preparePendingTasks","context","animationToStopValue","getValue","pendingStopAnimations","_getGlobalContextVariable","push","uniqueId","_setGlobalContextVariable","_cancelPendingTasks","i","length","splice","_execute","stopTime","isNaN","_reportError","_startPendingTasks","_stopAnimation","out","_activateSignal","Warn","_executeOnTick","getCurrentFrame","done","_removePendingBlock","getClassName","currentlyRunning","index","indexOf","stop"],"ignoreList":[],"sourceRoot":""}