"use strict";(self.webpackChunk_dev_inspector_v2=self.webpackChunk_dev_inspector_v2||[]).push([[1437],{41437:(t,e,a)=>{a.d(e,{SPLATFileLoader:()=>g});var n=a(55179),s=a(87274),r=a(83276),i=a(51067),o=a(74421),l=a(83031),c=a(31273),h=a(97591),f=a(43291),d=a(59029),p=a(33442);const m=.28209479177387814;async function u(t,e,a){const n=new Promise(((n,s)=>{const r=a.createCanvasImage();if(!r)throw new Error("Failed to create ImageBitmap");let i;if(r.onload=()=>{try{const t=a.createCanvas(r.width,r.height);if(!t)throw new Error("Failed to create canvas");const e=t.getContext("2d");if(!e)throw new Error("Failed to get 2D context");e.drawImage(r,0,0);const s=e.getImageData(0,0,t.width,t.height);n({bits:new Uint8Array(s.data.buffer),width:s.width})}catch(t){s(`Error loading image ${r.src} with exception: ${t}`)}},r.onerror=t=>{s(`Error loading image ${r.src} with exception: ${t}`)},r.crossOrigin="anonymous","string"==typeof t){if(!e)throw new Error("filename is required when using a URL");r.src=t+e}else{const e=new Blob([t],{type:"image/webp"});i=URL.createObjectURL(e),r.src=i}}));return await n}async function w(t,e,a){let n,s;if(t instanceof Map){s=t;const e=s.get("meta.json");if(!e)throw new Error("meta.json not found in files Map");n=JSON.parse((new TextDecoder).decode(e))}else n=t;const r=[...n.means.files,...n.scales.files,...n.quats.files,...n.sh0.files];n.shN&&r.push(...n.shN.files);const i=await Promise.all(r.map((async t=>{if(s&&s.has(t)){const e=s.get(t);return await u(e,t,a.getEngine())}return await u(e,t,a.getEngine())})));return await async function(t,e,a){const n=t.count?t.count:t.means.shape[0],s=new ArrayBuffer(32*n),r=new Float32Array(s),i=new Float32Array(s),o=new Uint8ClampedArray(s),l=new Uint8ClampedArray(s),c=t=>Math.sign(t)*(Math.exp(Math.abs(t))-1),h=e[0].bits,f=e[1].bits;if(!Array.isArray(t.means.mins)||!Array.isArray(t.means.maxs))throw new Error("Missing arrays in SOG data.");for(let e=0;e<n;e++){const a=4*e;for(let n=0;n<3;n++){const s=t.means.mins[n],i=t.means.maxs[n],o=f[a+n]<<8|h[a+n],l=p.X.Lerp(s,i,o/65535);r[8*e+n]=c(l)}}const d=e[2].bits;if(2===t.version){if(!t.scales.codebook)throw new Error("Missing codebook in SOG version 2 scales data.");for(let e=0;e<n;e++){const a=4*e;for(let n=0;n<3;n++){const s=t.scales.codebook[d[a+n]],r=Math.exp(s);i[8*e+3+n]=r}}}else{if(!Array.isArray(t.scales.mins)||!Array.isArray(t.scales.maxs))throw new Error("Missing arrays in SOG scales data.");for(let e=0;e<n;e++){const a=4*e;for(let n=0;n<3;n++){const s=d[a+n],r=p.X.Lerp(t.scales.mins[n],t.scales.maxs[n],s/255),o=Math.exp(r);i[8*e+3+n]=o}}}const u=e[4].bits;if(2===t.version){if(!t.sh0.codebook)throw new Error("Missing codebook in SOG version 2 sh0 data.");for(let e=0;e<n;e++){const a=4*e;for(let n=0;n<3;n++){const s=.5+t.sh0.codebook[u[a+n]]*m;o[32*e+24+n]=Math.max(0,Math.min(255,Math.round(255*s)))}o[32*e+24+3]=u[a+3]}}else{if(!Array.isArray(t.sh0.mins)||!Array.isArray(t.sh0.maxs))throw new Error("Missing arrays in SOG sh0 data.");for(let e=0;e<n;e++){const a=4*e;for(let n=0;n<4;n++){const s=t.sh0.mins[n],r=t.sh0.maxs[n],i=u[a+n],l=p.X.Lerp(s,r,i/255);let c;c=n<3?.5+l*m:1/(1+Math.exp(-l)),o[32*e+24+n]=Math.max(0,Math.min(255,Math.round(255*c)))}}}const w=t=>2*(t/255-.5)/Math.SQRT2,y=e[3].bits;for(let t=0;t<n;t++){const e=y[4*t+0],a=y[4*t+1],n=y[4*t+2],s=y[4*t+3],r=w(e),i=w(a),o=w(n),c=s-252,h=r*r+i*i+o*o,f=Math.sqrt(Math.max(0,1-h));let d;switch(c){case 0:d=[f,r,i,o];break;case 1:d=[r,f,i,o];break;case 2:d=[r,i,f,o];break;case 3:d=[r,i,o,f];break;default:throw new Error("Invalid quaternion mode")}l[32*t+28+0]=127.5*d[0]+127.5,l[32*t+28+1]=127.5*d[1]+127.5,l[32*t+28+2]=127.5*d[2]+127.5,l[32*t+28+3]=127.5*d[3]+127.5}if(t.shN){const r=[0,3,8,15],i=t.shN.bands?r[t.shN.bands]:t.shN.shape[1]/3,o=e[5].bits,l=e[6].bits,c=e[5].width,h=3*i,f=Math.ceil(h/16),d=[],m=a.getEngine().getCaps().maxTextureSize,u=Math.ceil(n/m);for(let t=0;t<f;t++){const t=new Uint8Array(u*m*4*4);d.push(t)}if(2===t.version){if(!t.shN.codebook)throw new Error("Missing codebook in SOG version 2 shN data.");for(let e=0;e<n;e++){const a=l[4*e+0]+(l[4*e+1]<<8),n=a%64*i,s=Math.floor(a/64);for(let a=0;a<i;a++)for(let r=0;r<3;r++){const i=3*a+r,l=Math.floor(i/16),h=d[l],f=i%16,p=16*e,m=127.5*t.shN.codebook[o[4*(n+a)+r+s*c*4]]+127.5;h[f+p]=Math.max(0,Math.min(255,m))}}}else for(let e=0;e<n;e++){const a=l[4*e+0]+(l[4*e+1]<<8),n=a%64*i,s=Math.floor(a/64),r=t.shN.mins,h=t.shN.maxs;for(let t=0;t<3;t++)for(let a=0;a<i/3;a++){const i=3*a+t,l=Math.floor(i/16),f=d[l],m=i%16,u=16*e,w=127.5*p.X.Lerp(r,h,o[4*(n+a)+t+s*c*4]/255)+127.5;f[m+u]=Math.max(0,Math.min(255,w))}}return await new Promise((t=>{t({mode:0,data:s,hasVertexColors:!1,sh:d})}))}return await new Promise((t=>{t({mode:0,data:s,hasVertexColors:!1})}))}(n,i,a)}var y=a(21148);class g{constructor(t=g._DefaultLoadingOptions){this.name=s.B.name,this._assetContainer=null,this.extensions=s.B.extensions,this._loadingOptions=t}createPlugin(t){return new g(t[s.B.name])}async importMeshAsync(t,e,a,n,s,r){return await this._parseAsync(t,e,a,n).then((t=>({meshes:t,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}static _BuildPointCloud(t,e){if(!e.byteLength)return!1;const a=new Uint8Array(e),n=new Float32Array(e),s=a.length/32;return t.addPoints(s,(function(t,e){const s=n[8*e+0],r=n[8*e+1],i=n[8*e+2];t.position=new c.Pq(s,r,i);const o=a[32*e+24+0]/255,l=a[32*e+24+1]/255,h=a[32*e+24+2]/255;t.color=new f.ov(o,l,h,1)})),!0}static _BuildMesh(t,e){const a=new o.e("PLYMesh",t),n=new Uint8Array(e.data),s=new Float32Array(e.data),r=n.length/32,i=[],l=new d.P;for(let t=0;t<r;t++){const e=s[8*t+0],a=s[8*t+1],n=s[8*t+2];i.push(e,a,n)}if(e.hasVertexColors){const t=new Float32Array(4*r);for(let e=0;e<r;e++){const a=n[32*e+24+0]/255,s=n[32*e+24+1]/255,r=n[32*e+24+2]/255;t[4*e+0]=a,t[4*e+1]=s,t[4*e+2]=r,t[4*e+3]=1}l.colors=t}return l.positions=i,l.indices=e.faces,l.applyToMesh(a),a}async _unzipWithFFlateAsync(t){let e=this._loadingOptions.fflate;e||(void 0===window.fflate&&await y.S0.LoadScriptAsync(this._loadingOptions.deflateURL??"https://unpkg.com/fflate/umd/index.js"),e=window.fflate);const{unzipSync:a}=e,n=a(t),s=new Map;for(const[t,e]of Object.entries(n))s.set(t,e);return s}_parseAsync(t,e,a,n){const s=[],i=t=>{e._blockEntityCollection=!!this._assetContainer;const a=this._loadingOptions.gaussianSplattingMesh??new r.t("GaussianSplatting",null,e,this._loadingOptions.keepInRam);a._parentContainer=this._assetContainer,s.push(a),a.updateData(t.data,t.sh,{flipY:!1}),a.scaling.y*=-1,a.computeWorldMatrix(!0),e._blockEntityCollection=!1};if("string"==typeof a){const t=JSON.parse(a);if(t&&t.means&&t.scales&&t.quats&&t.sh0)return new Promise((a=>{w(t,n,e).then((t=>{i(t),a(s)})).catch((()=>{throw new Error("Failed to parse SOG data.")}))}))}const o=a instanceof ArrayBuffer?new Uint8Array(a):a;if(80===o[0]&&75===o[1])return new Promise((t=>{this._unzipWithFFlateAsync(o).then((a=>{w(a,n,e).then((e=>{i(e),t(s)})).catch((()=>{throw new Error("Failed to parse SOG zip data.")}))}))}));const l=new ReadableStream({start(t){t.enqueue(new Uint8Array(a)),t.close()}}),f=new DecompressionStream("gzip"),d=l.pipeThrough(f);return new Promise((t=>{new Response(d).arrayBuffer().then((a=>{(function(t,e){const a=new Uint8Array(t),n=new Uint32Array(t.slice(0,12)),s=n[2],r=a[12],i=a[13],o=a[14],l=a[15],c=n[1];if(l||1347635022!=n[0]||2!=c&&3!=c)return new Promise((t=>{t({mode:3,data:h,hasVertexColors:!1})}));const h=new ArrayBuffer(32*s),f=1/(1<<i),d=new Int32Array(1),m=new Uint8Array(d.buffer),u=function(t,e){return m[0]=t[e+0],m[1]=t[e+1],m[2]=t[e+2],m[3]=128&t[e+2]?255:0,d[0]*f};let w=16;const y=new Float32Array(h),g=new Float32Array(h),M=new Uint8ClampedArray(h),_=new Uint8ClampedArray(h);for(let t=0;t<s;t++)y[8*t+0]=u(a,w+0),y[8*t+1]=u(a,w+3),y[8*t+2]=u(a,w+6),w+=9;for(let t=0;t<s;t++){for(let e=0;e<3;e++){const n=(a[w+s+3*t+e]-127.5)/38.25;M[32*t+24+e]=p.X.Clamp(255*(.5+.282*n),0,255)}M[32*t+24+3]=a[w+t]}w+=4*s;for(let t=0;t<s;t++)g[8*t+3+0]=Math.exp(a[w+0]/16-10),g[8*t+3+1]=Math.exp(a[w+1]/16-10),g[8*t+3+2]=Math.exp(a[w+2]/16-10),w+=3;if(c>=3){const t=Math.SQRT1_2;for(let e=0;e<s;e++){const n=[a[w+0],a[w+1],a[w+2],a[w+3]],s=n[0]+(n[1]<<8)+(n[2]<<16)+(n[3]<<24),r=511,i=[],o=s>>>30;let l=s,c=0;for(let e=3;e>=0;--e)if(e!==o){const a=l&r,n=l>>>9&1;l>>>=10,i[e]=t*(a/r),1===n&&(i[e]=-i[e]),c+=i[e]*i[e]}const h=1-c;i[o]=Math.sqrt(Math.max(h,0));const f=[3,0,1,2];for(let t=0;t<4;t++)_[32*e+28+t]=Math.round(127.5+127.5*i[f[t]]);w+=4}}else for(let t=0;t<s;t++){const e=a[w+0],n=a[w+1],s=a[w+2],r=e/127.5-1,i=n/127.5-1,o=s/127.5-1;_[32*t+28+1]=e,_[32*t+28+2]=n,_[32*t+28+3]=s;const l=1-(r*r+i*i+o*o);_[32*t+28+0]=127.5+127.5*Math.sqrt(l<0?0:l),w+=3}if(r){const t=3*((r+1)*(r+1)-1),n=Math.ceil(t/16);let i=w;const l=[],c=e.getEngine().getCaps().maxTextureSize,f=Math.ceil(s/c);for(let t=0;t<n;t++){const t=new Uint8Array(f*c*4*4);l.push(t)}for(let e=0;e<s;e++)for(let n=0;n<t;n++){const t=a[i++],s=Math.floor(n/16);l[s][n%16+16*e]=t}return new Promise((t=>{t({mode:0,data:h,hasVertexColors:!1,sh:l,trainedWithAntialiasing:!!o})}))}return new Promise((t=>{t({mode:0,data:h,hasVertexColors:!1,trainedWithAntialiasing:!!o})}))})(a,e,this._loadingOptions).then((a=>{e._blockEntityCollection=!!this._assetContainer;const n=this._loadingOptions.gaussianSplattingMesh??new r.t("GaussianSplatting",null,e,this._loadingOptions.keepInRam);if(a.trainedWithAntialiasing){const t=n.material;t.kernelSize=.1,t.compensation=!0}n._parentContainer=this._assetContainer,s.push(n),n.updateData(a.data,a.sh,{flipY:!1}),this._loadingOptions.flipY||(n.scaling.y*=-1,n.computeWorldMatrix(!0)),e._blockEntityCollection=!1,this.applyAutoCameraLimits(a,e),t(s)}))})).catch((()=>{g._ConvertPLYToSplat(a).then((async a=>{switch(e._blockEntityCollection=!!this._assetContainer,a.mode){case 0:{const t=this._loadingOptions.gaussianSplattingMesh??new r.t("GaussianSplatting",null,e,this._loadingOptions.keepInRam);switch(t._parentContainer=this._assetContainer,s.push(t),t.updateData(a.data,a.sh,{flipY:!1}),t.scaling.y*=-1,"RightHanded"===a.chirality&&(t.scaling.y*=-1),a.upAxis){case"X":t.rotation=new c.Pq(0,0,Math.PI/2);break;case"Y":t.rotation=new c.Pq(0,0,Math.PI);break;case"Z":t.rotation=new c.Pq(-Math.PI/2,Math.PI,0)}t.computeWorldMatrix(!0)}break;case 1:{const t=new h.y("PointCloud",1,e);g._BuildPointCloud(t,a.data)?await t.buildMeshAsync().then((t=>{s.push(t)})):t.dispose()}break;case 2:if(!a.faces)throw new Error("PLY mesh doesn't contain face informations.");s.push(g._BuildMesh(e,a));break;default:throw new Error("Unsupported Splat mode")}e._blockEntityCollection=!1,this.applyAutoCameraLimits(a,e),t(s)}))}))}))}applyAutoCameraLimits(t,e){if(!this._loadingOptions.disableAutoCameraLimits&&(void 0!==t.safeOrbitCameraRadiusMin||void 0!==t.safeOrbitCameraElevationMinMax)&&"ArcRotateCamera"===e.activeCamera?.getClassName()){const a=e.activeCamera;t.safeOrbitCameraElevationMinMax&&(a.lowerBetaLimit=.5*Math.PI-t.safeOrbitCameraElevationMinMax[1],a.upperBetaLimit=.5*Math.PI-t.safeOrbitCameraElevationMinMax[0]),t.safeOrbitCameraRadiusMin&&(a.lowerRadiusLimit=t.safeOrbitCameraRadiusMin)}}loadAssetContainerAsync(t,e,a){const n=new i.WZ(t);return this._assetContainer=n,this.importMeshAsync(null,t,e,a).then((t=>{for(const e of t.meshes)n.meshes.push(e);return this._assetContainer=null,n})).catch((t=>{throw this._assetContainer=null,t}))}loadAsync(t,e,a){return this.importMeshAsync(null,t,e,a).then((()=>{}))}static _ConvertPLYToSplat(t){const e=new Uint8Array(t),a=(new TextDecoder).decode(e.slice(0,10240)),n=a.indexOf("end_header\n");if(n<0||!a)return new Promise((e=>{e({mode:0,data:t,rawSplat:!0})}));const s=parseInt(/element vertex (\d+)\n/.exec(a)[1]),i=/element face (\d+)\n/.exec(a);let o=0;i&&(o=parseInt(i[1]));const c=/element chunk (\d+)\n/.exec(a);let h=0;c&&(h=parseInt(c[1]));let f=0,d=0;const p={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let m=1;const u=[],w=[],y=a.slice(0,n).split("\n"),g={};for(const e of y)if(e.startsWith("property ")){const[,a,n]=e.split(" ");if(1==m)w.push({name:n,type:a,offset:d}),d+=p[a];else if(0==m)u.push({name:n,type:a,offset:f}),f+=p[a];else if(2==m)u.push({name:n,type:a,offset:f});else if(3==m){const e=new DataView(t,d,2*p.float);g.safeOrbitCameraElevationMinMax=[e.getFloat32(0,!0),e.getFloat32(4,!0)]}else if(4==m){const e=new DataView(t,d,p.float);g.safeOrbitCameraRadiusMin=e.getFloat32(0,!0)}else if(5==m){const e=new DataView(t,d,p.uchar);"up_axis"==n?g.upAxis=0==e.getUint8(0)?"X":1==e.getUint8(0)?"Y":"Z":"chirality"==n&&(g.chirality=0==e.getUint8(0)?"LeftHanded":"RightHanded")}p[a]||l.V.Warn(`Unsupported property type: ${a}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");"chunk"==t?m=1:"vertex"==t?m=0:"sh"==t?m=2:"safe_orbit_camera_elevation_min_max_radians"==t?m=3:"safe_orbit_camera_radius_min"==t?m=4:"up_axis"!=t&&"chirality"!=t||(m=5)}const M=f,_=d;return r.t.ConvertPLYWithSHToSplatAsync(t).then((async e=>{const a=new DataView(t,n+11);let r=_*h+M*s;const i=[];if(o)for(let t=0;t<o;t++){const t=a.getUint8(r);if(3==t){r+=1;for(let e=0;e<t;e++){const t=a.getUint32(r+4*(2-e),!0);i.push(t)}r+=12}}if(h)return await new Promise((t=>{t({mode:0,data:e.buffer,sh:e.sh,faces:i,hasVertexColors:!1,compressed:!0,rawSplat:!1})}));let l=0,c=0;const f=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],d=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let t=0;t<u.length;t++){const e=u[t];f.includes(e.name)&&l++,d.includes(e.name)&&c++}const p=l==f.length&&3==c,m=o?2:p?0:1;return await new Promise((t=>{t({...g,mode:m,data:e.buffer,sh:e.sh,faces:i,hasVertexColors:!!c,compressed:!1,rawSplat:!1})}))}))}}g._DefaultLoadingOptions={keepInRam:!1,flipY:!1},(0,n.qS)(new g)}}]);
//# sourceMappingURL=1437.bundle.js.map