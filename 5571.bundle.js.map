{"version":3,"file":"5571.bundle.js","mappings":"4MA+BO,MAAMA,UAA+E,IAsBxF,WAAAC,CAIoBC,GAEhBC,MAAMD,GAFU,KAAAA,OAAAA,EAGhBE,KAAKC,OAASD,KAAKE,kBAAkB,SAAU,KAAaJ,EAAOK,QACnEH,KAAKI,MAAQJ,KAAKE,kBAAkB,QAAS,MAC7CF,KAAKK,aAAeL,KAAKE,kBAAkB,eAAgB,KAAaJ,EAAOO,cAC/EL,KAAKM,kBAAoBN,KAAKE,kBAAkB,oBAAqB,KACzE,CACgB,QAAAK,CAASC,EAA2BC,GAChD,IACI,MAAMN,EAASH,KAAKC,OAAOS,SAASF,GAC9BJ,EAAQJ,KAAKI,MAAMM,SAASF,GAC5BH,EAAeL,KAAKK,aAAaK,SAASF,GAEhDR,KAAKW,uBAAuBH,EAASL,EAAQE,GAE7C,MAAMO,EAAcZ,KAAKM,kBAAkBI,SAASF,GAChDI,EACAA,EAAYT,EAAQE,EAAcD,EAAOI,GAEzCR,KAAKa,kBAAkBV,EAAQE,EAAcD,EAErD,CAAE,MAAOU,GACLd,KAAKe,aAAaP,EAASM,EAC/B,CACAd,KAAKgB,IAAIC,gBAAgBT,EAC7B,CAEQ,sBAAAG,CAAuBH,EAA2BL,EAAaE,GACnE,MAAMa,EAAkCV,EAAQW,0BAA0B,kCAAmC,IAC7G,IAAK,MAAMC,KAAYF,EAAiC,CACpD,MAAMG,EAAiBb,EAAQc,cAAcC,gBAAgBC,MAAMH,GAAmBA,EAAeD,WAAaA,IAClH,GAAIC,EACA,IAAK,MAAMI,KAAsBJ,EAAeI,mBAC5C,GAAIA,EAAmBtB,SAAWA,GAAUsB,EAAmBC,UAAUC,iBAAmBtB,EAAc,CACtGgB,EAAeO,MAAK,GACpBP,EAAeQ,UAEf,MAAMC,EAAQZ,EAAgCa,QAAQX,IACvC,IAAXU,IACAZ,EAAgCc,OAAOF,EAAO,GAC9CtB,EAAQyB,0BAA0B,kCAAmCf,GAE7E,CAGZ,CACJ,CAEQ,iBAAAL,CAAkBV,EAAsBE,EAAsBD,GAClE,MAAM8B,EAAO7B,EAAa8B,MAAM,KAChC,IAAIC,EAAMjC,EACV,IAAK,IAAIkC,EAAI,EAAGA,EAAIH,EAAKI,OAAS,EAAGD,IAAK,CACtC,MAAME,EAAOL,EAAKG,QACAG,IAAdJ,EAAIG,KACJH,EAAIG,GAAQ,CAAC,GAEjBH,EAAMA,EAAIG,EACd,CACAH,EAAIF,EAAKA,EAAKI,OAAS,IAAMlC,CACjC,CAEgB,YAAAqC,GACZ,MAAO,2BACX,GAGJ,QAAc,4BAAiC7C,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Execution/flowGraphSetPropertyBlock.ts?"],"sourcesContent":["import type { AssetType, FlowGraphAssetType } from \"core/FlowGraph/flowGraphAssetsContext\";\nimport type { FlowGraphContext } from \"core/FlowGraph/flowGraphContext\";\nimport type { FlowGraphDataConnection } from \"core/FlowGraph/flowGraphDataConnection\";\nimport { FlowGraphExecutionBlockWithOutSignal } from \"core/FlowGraph/flowGraphExecutionBlockWithOutSignal\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport type { FlowGraphSignalConnection } from \"core/FlowGraph/flowGraphSignalConnection\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\n\nexport interface IFlowGraphSetPropertyBlockConfiguration<O extends FlowGraphAssetType> {\n    /**\n     * The name of the property that will be set\n     */\n    propertyName?: string;\n\n    /**\n     * The target asset from which the property will be retrieved\n     */\n    target?: AssetType<O>;\n}\n\n/**\n * This block will set a property on a given target asset.\n * The property name can include dots (\".\"), which will be interpreted as a path to the property.\n * The target asset is an input and can be changed at any time.\n * The value of the property is an input and can be changed at any time.\n *\n * For example, with an input of a mesh asset, the property name \"position.x\" will set the x component of the position of the mesh.\n *\n * Note that it is recommended to input the object on which you are working on (i.e. a material) than providing a mesh and then getting the material from it.\n */\nexport class FlowGraphSetPropertyBlock<P extends any, O extends FlowGraphAssetType> extends FlowGraphExecutionBlockWithOutSignal {\n    /**\n     * Input connection: The value to set on the property.\n     */\n    public readonly value: FlowGraphDataConnection<P>;\n\n    /**\n     * Input connection: The target asset from which the property will be retrieved\n     */\n    public readonly object: FlowGraphDataConnection<AssetType<O>>;\n\n    /**\n     * Input connection: The name of the property that will be set\n     */\n    public readonly propertyName: FlowGraphDataConnection<string>;\n\n    /**\n     * Input connection: A function that can be used to set the value of the property.\n     * If set it will be used instead of the default set function.\n     */\n    public readonly customSetFunction: FlowGraphDataConnection<(target: AssetType<O>, propertyName: string, value: P, context: FlowGraphContext) => void>;\n\n    constructor(\n        /**\n         * the configuration of the block\n         */\n        public override config: IFlowGraphSetPropertyBlockConfiguration<O>\n    ) {\n        super(config);\n        this.object = this.registerDataInput(\"object\", RichTypeAny, config.target);\n        this.value = this.registerDataInput(\"value\", RichTypeAny);\n        this.propertyName = this.registerDataInput(\"propertyName\", RichTypeAny, config.propertyName);\n        this.customSetFunction = this.registerDataInput(\"customSetFunction\", RichTypeAny);\n    }\n    public override _execute(context: FlowGraphContext, _callingSignal: FlowGraphSignalConnection): void {\n        try {\n            const target = this.object.getValue(context);\n            const value = this.value.getValue(context);\n            const propertyName = this.propertyName.getValue(context);\n\n            this._stopRunningAnimations(context, target, propertyName);\n\n            const setFunction = this.customSetFunction.getValue(context);\n            if (setFunction) {\n                setFunction(target, propertyName, value, context);\n            } else {\n                this._setPropertyValue(target, propertyName, value);\n            }\n        } catch (e) {\n            this._reportError(context, e);\n        }\n        this.out._activateSignal(context);\n    }\n\n    private _stopRunningAnimations(context: FlowGraphContext, target: any, propertyName: string) {\n        const currentlyRunningAnimationGroups = context._getGlobalContextVariable(\"currentlyRunningAnimationGroups\", []) as number[];\n        for (const uniqueId of currentlyRunningAnimationGroups) {\n            const animationGroup = context.assetsContext.animationGroups.find((animationGroup) => animationGroup.uniqueId === uniqueId);\n            if (animationGroup) {\n                for (const targetedAnimations of animationGroup.targetedAnimations) {\n                    if (targetedAnimations.target === target && targetedAnimations.animation.targetProperty === propertyName) {\n                        animationGroup.stop(true);\n                        animationGroup.dispose();\n\n                        const index = currentlyRunningAnimationGroups.indexOf(uniqueId);\n                        if (index !== -1) {\n                            currentlyRunningAnimationGroups.splice(index, 1);\n                            context._setGlobalContextVariable(\"currentlyRunningAnimationGroups\", currentlyRunningAnimationGroups);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private _setPropertyValue(target: AssetType<O>, propertyName: string, value: P): void {\n        const path = propertyName.split(\".\");\n        let obj = target as any;\n        for (let i = 0; i < path.length - 1; i++) {\n            const prop = path[i];\n            if (obj[prop] === undefined) {\n                obj[prop] = {};\n            }\n            obj = obj[prop];\n        }\n        obj[path[path.length - 1]] = value;\n    }\n\n    public override getClassName(): string {\n        return FlowGraphBlockNames.SetProperty;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.SetProperty, FlowGraphSetPropertyBlock);\n"],"names":["FlowGraphSetPropertyBlock","constructor","config","super","this","object","registerDataInput","target","value","propertyName","customSetFunction","_execute","context","_callingSignal","getValue","_stopRunningAnimations","setFunction","_setPropertyValue","e","_reportError","out","_activateSignal","currentlyRunningAnimationGroups","_getGlobalContextVariable","uniqueId","animationGroup","assetsContext","animationGroups","find","targetedAnimations","animation","targetProperty","stop","dispose","index","indexOf","splice","_setGlobalContextVariable","path","split","obj","i","length","prop","undefined","getClassName"],"ignoreList":[],"sourceRoot":""}