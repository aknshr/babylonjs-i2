{"version":3,"file":"2062.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../loaders/src/glTF/2.0/Extensions/KHR_materials_transmission.ts?"],"sourcesContent":["import type { Nullable } from \"core/types\";\r\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { IMaterial, ITextureInfo } from \"../glTFLoaderInterfaces\";\r\nimport type { IGLTFLoaderExtension } from \"../glTFLoaderExtension\";\r\nimport { GLTFLoader } from \"../glTFLoader\";\r\nimport type { IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RenderTargetTexture } from \"core/Materials/Textures/renderTargetTexture\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Color4 } from \"core/Maths/math.color\";\r\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\r\n\r\ninterface ITransmissionHelperHolder {\r\n    /**\r\n     * @internal\r\n     */\r\n    _transmissionHelper: TransmissionHelper | undefined;\r\n}\r\n\r\ninterface ITransmissionHelperOptions {\r\n    /**\r\n     * The size of the render buffers (default: 1024)\r\n     */\r\n    renderSize: number;\r\n\r\n    /**\r\n     * The number of samples to use when generating the render target texture for opaque meshes (default: 4)\r\n     */\r\n    samples: number;\r\n\r\n    /**\r\n     * Scale to apply when selecting the LOD level to sample the refraction texture (default: 1)\r\n     */\r\n    lodGenerationScale: number;\r\n\r\n    /**\r\n     * Offset to apply when selecting the LOD level to sample the refraction texture (default: -4)\r\n     */\r\n    lodGenerationOffset: number;\r\n\r\n    /**\r\n     * Type of the refraction render target texture (default: TEXTURETYPE_HALF_FLOAT)\r\n     */\r\n    renderTargetTextureType: number;\r\n\r\n    /**\r\n     * Defines if the mipmaps for the refraction render target texture must be generated (default: true)\r\n     */\r\n    generateMipmaps: boolean;\r\n\r\n    /**\r\n     * Clear color of the opaque texture. If not provided, use the scene clear color (which will be converted to linear space).\r\n     * If provided, should be in linear space\r\n     */\r\n    clearColor?: Color4;\r\n}\r\n\r\n/**\r\n * A class to handle setting up the rendering of opaque objects to be shown through transmissive objects.\r\n */\r\nclass TransmissionHelper {\r\n    /**\r\n     * Creates the default options for the helper.\r\n     * @returns the default options\r\n     */\r\n    private static _GetDefaultOptions(): ITransmissionHelperOptions {\r\n        return {\r\n            renderSize: 1024,\r\n            samples: 4,\r\n            lodGenerationScale: 1,\r\n            lodGenerationOffset: -4,\r\n            renderTargetTextureType: Constants.TEXTURETYPE_HALF_FLOAT,\r\n            generateMipmaps: true,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Stores the creation options.\r\n     */\r\n    private readonly _scene: Scene & ITransmissionHelperHolder;\r\n\r\n    private _options: ITransmissionHelperOptions;\r\n\r\n    private _opaqueRenderTarget: Nullable<RenderTargetTexture> = null;\r\n    private _opaqueMeshesCache: AbstractMesh[] = [];\r\n    private _transparentMeshesCache: AbstractMesh[] = [];\r\n    private _materialObservers: { [id: string]: Nullable<Observer<AbstractMesh>> } = {};\r\n\r\n    /**\r\n     * This observable will be notified with any error during the creation of the environment,\r\n     * mainly texture creation errors.\r\n     */\r\n    public onErrorObservable: Observable<{ message?: string; exception?: any }>;\r\n\r\n    /**\r\n     * constructor\r\n     * @param options Defines the options we want to customize the helper\r\n     * @param scene The scene to add the material to\r\n     */\r\n    constructor(options: Partial<ITransmissionHelperOptions>, scene: Scene) {\r\n        this._options = {\r\n            ...TransmissionHelper._GetDefaultOptions(),\r\n            ...options,\r\n        };\r\n        this._scene = scene as any;\r\n        this._scene._transmissionHelper = this;\r\n\r\n        this.onErrorObservable = new Observable();\r\n        this._scene.onDisposeObservable.addOnce(() => {\r\n            this.dispose();\r\n        });\r\n\r\n        this._parseScene();\r\n        this._setupRenderTargets();\r\n    }\r\n\r\n    /**\r\n     * Updates the background according to the new options\r\n     * @param options\r\n     */\r\n    public updateOptions(options: Partial<ITransmissionHelperOptions>) {\r\n        // First check if any options are actually being changed. If not, exit.\r\n        const newValues = Object.keys(options).filter((key: string) => (this._options as any)[key] !== (options as any)[key]);\r\n        if (!newValues.length) {\r\n            return;\r\n        }\r\n\r\n        const newOptions = {\r\n            ...this._options,\r\n            ...options,\r\n        };\r\n\r\n        const oldOptions = this._options;\r\n        this._options = newOptions;\r\n\r\n        // If size changes, recreate everything\r\n        if (\r\n            newOptions.renderSize !== oldOptions.renderSize ||\r\n            newOptions.renderTargetTextureType !== oldOptions.renderTargetTextureType ||\r\n            newOptions.generateMipmaps !== oldOptions.generateMipmaps ||\r\n            !this._opaqueRenderTarget\r\n        ) {\r\n            this._setupRenderTargets();\r\n        } else {\r\n            this._opaqueRenderTarget.samples = newOptions.samples;\r\n            this._opaqueRenderTarget.lodGenerationScale = newOptions.lodGenerationScale;\r\n            this._opaqueRenderTarget.lodGenerationOffset = newOptions.lodGenerationOffset;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns the opaque render target texture or null if not available.\r\n     */\r\n    public getOpaqueTarget(): Nullable<Texture> {\r\n        return this._opaqueRenderTarget;\r\n    }\r\n\r\n    private _shouldRenderAsTransmission(material: Nullable<Material>): boolean {\r\n        return (material as any)?.subSurface?.isRefractionEnabled ? true : false;\r\n    }\r\n\r\n    private _addMesh(mesh: AbstractMesh): void {\r\n        this._materialObservers[mesh.uniqueId] = mesh.onMaterialChangedObservable.add(this._onMeshMaterialChanged.bind(this));\r\n\r\n        // we need to defer the processing because _addMesh may be called as part as an instance mesh creation, in which case some\r\n        // internal properties are not setup yet, like _sourceMesh (needed when doing mesh.material below)\r\n        Tools.SetImmediate(() => {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n                if (this._transparentMeshesCache.indexOf(mesh) === -1) {\r\n                    this._transparentMeshesCache.push(mesh);\r\n                }\r\n            } else {\r\n                if (this._opaqueMeshesCache.indexOf(mesh) === -1) {\r\n                    this._opaqueMeshesCache.push(mesh);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _removeMesh(mesh: AbstractMesh): void {\r\n        mesh.onMaterialChangedObservable.remove(this._materialObservers[mesh.uniqueId]);\r\n        delete this._materialObservers[mesh.uniqueId];\r\n        let idx = this._transparentMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._transparentMeshesCache.splice(idx, 1);\r\n        }\r\n        idx = this._opaqueMeshesCache.indexOf(mesh);\r\n        if (idx !== -1) {\r\n            this._opaqueMeshesCache.splice(idx, 1);\r\n        }\r\n    }\r\n\r\n    private _parseScene(): void {\r\n        this._scene.meshes.forEach(this._addMesh.bind(this));\r\n        // Listen for when a mesh is added to the scene and add it to our cache lists.\r\n        this._scene.onNewMeshAddedObservable.add(this._addMesh.bind(this));\r\n        // Listen for when a mesh is removed from to the scene and remove it from our cache lists.\r\n        this._scene.onMeshRemovedObservable.add(this._removeMesh.bind(this));\r\n    }\r\n\r\n    // When one of the meshes in the scene has its material changed, make sure that it's in the correct cache list.\r\n    private _onMeshMaterialChanged(mesh: AbstractMesh) {\r\n        const transparentIdx = this._transparentMeshesCache.indexOf(mesh);\r\n        const opaqueIdx = this._opaqueMeshesCache.indexOf(mesh);\r\n\r\n        // If the material is transparent, make sure that it's added to the transparent list and removed from the opaque list\r\n        const useTransmission = this._shouldRenderAsTransmission(mesh.material);\r\n        if (useTransmission) {\r\n            if (mesh.material) {\r\n                const subSurface = (mesh.material as PBRMaterial).subSurface;\r\n                if (subSurface) {\r\n                    subSurface.refractionTexture = this._opaqueRenderTarget;\r\n                }\r\n            }\r\n            if (opaqueIdx !== -1) {\r\n                this._opaqueMeshesCache.splice(opaqueIdx, 1);\r\n                this._transparentMeshesCache.push(mesh);\r\n            } else if (transparentIdx === -1) {\r\n                this._transparentMeshesCache.push(mesh);\r\n            }\r\n            // If the material is opaque, make sure that it's added to the opaque list and removed from the transparent list\r\n        } else {\r\n            if (transparentIdx !== -1) {\r\n                this._transparentMeshesCache.splice(transparentIdx, 1);\r\n                this._opaqueMeshesCache.push(mesh);\r\n            } else if (opaqueIdx === -1) {\r\n                this._opaqueMeshesCache.push(mesh);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Check if the opaque render target has not been disposed and can still be used.\r\n     * @returns\r\n     */\r\n    public _isRenderTargetValid() {\r\n        return this._opaqueRenderTarget?.getInternalTexture() !== null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Setup the render targets according to the specified options.\r\n     */\r\n    public _setupRenderTargets(): void {\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n        }\r\n        this._opaqueRenderTarget = new RenderTargetTexture(\r\n            \"opaqueSceneTexture\",\r\n            this._options.renderSize,\r\n            this._scene,\r\n            this._options.generateMipmaps,\r\n            undefined,\r\n            this._options.renderTargetTextureType\r\n        );\r\n        this._opaqueRenderTarget.ignoreCameraViewport = true;\r\n        this._opaqueRenderTarget.renderList = this._opaqueMeshesCache;\r\n        this._opaqueRenderTarget.clearColor = this._options.clearColor?.clone() ?? this._scene.clearColor.clone();\r\n        this._opaqueRenderTarget.gammaSpace = false;\r\n        this._opaqueRenderTarget.lodGenerationScale = this._options.lodGenerationScale;\r\n        this._opaqueRenderTarget.lodGenerationOffset = this._options.lodGenerationOffset;\r\n        this._opaqueRenderTarget.samples = this._options.samples;\r\n        this._opaqueRenderTarget.renderSprites = true;\r\n        this._opaqueRenderTarget.renderParticles = true;\r\n        this._opaqueRenderTarget.disableImageProcessing = true;\r\n\r\n        let saveSceneEnvIntensity: number;\r\n        this._opaqueRenderTarget.onBeforeBindObservable.add((opaqueRenderTarget) => {\r\n            saveSceneEnvIntensity = this._scene.environmentIntensity;\r\n            this._scene.environmentIntensity = 1.0;\r\n            if (!this._options.clearColor) {\r\n                this._scene.clearColor.toLinearSpaceToRef(opaqueRenderTarget.clearColor, this._scene.getEngine().useExactSrgbConversions);\r\n            } else {\r\n                opaqueRenderTarget.clearColor.copyFrom(this._options.clearColor);\r\n            }\r\n        });\r\n        this._opaqueRenderTarget.onAfterUnbindObservable.add(() => {\r\n            this._scene.environmentIntensity = saveSceneEnvIntensity;\r\n        });\r\n\r\n        for (const mesh of this._transparentMeshesCache) {\r\n            if (this._shouldRenderAsTransmission(mesh.material)) {\r\n                (mesh.material as PBRMaterial).refractionTexture = this._opaqueRenderTarget;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Dispose all the elements created by the Helper.\r\n     */\r\n    public dispose(): void {\r\n        this._scene._transmissionHelper = undefined;\r\n        if (this._opaqueRenderTarget) {\r\n            this._opaqueRenderTarget.dispose();\r\n            this._opaqueRenderTarget = null;\r\n        }\r\n        this._transparentMeshesCache = [];\r\n        this._opaqueMeshesCache = [];\r\n    }\r\n}\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\ndeclare module \"../../glTFFileLoader\" {\r\n    // eslint-disable-next-line jsdoc/require-jsdoc, @typescript-eslint/naming-convention\r\n    export interface GLTFLoaderExtensionOptions {\r\n        /**\r\n         * Defines options for the KHR_materials_transmission extension.\r\n         */\r\n        // NOTE: Don't use NAME here as it will break the UMD type declarations.\r\n        [\"KHR_materials_transmission\"]: {};\r\n    }\r\n}\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFLoaderExtension {\r\n    /**\r\n     * The name of this extension.\r\n     */\r\n    public readonly name = NAME;\r\n\r\n    /**\r\n     * Defines whether this extension is enabled.\r\n     */\r\n    public enabled: boolean;\r\n\r\n    /**\r\n     * Defines a number that determines the order the extensions are applied.\r\n     */\r\n    public order = 175;\r\n\r\n    private _loader: GLTFLoader;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(loader: GLTFLoader) {\r\n        this._loader = loader;\r\n        this.enabled = this._loader.isExtensionUsed(NAME);\r\n        if (this.enabled) {\r\n            loader.parent.transparencyAsCoverage = true;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._loader as any) = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public loadMaterialPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material): Nullable<Promise<void>> {\r\n        return GLTFLoader.LoadExtensionAsync<IKHRMaterialsTransmission>(context, material, this.name, async (extensionContext, extension) => {\r\n            const promises = new Array<Promise<any>>();\r\n            promises.push(this._loader.loadMaterialPropertiesAsync(context, material, babylonMaterial));\r\n            promises.push(this._loadTransparentPropertiesAsync(extensionContext, material, babylonMaterial, extension));\r\n            // eslint-disable-next-line github/no-then\r\n            return await Promise.all(promises).then(() => {});\r\n        });\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _loadTransparentPropertiesAsync(context: string, material: IMaterial, babylonMaterial: Material, extension: IKHRMaterialsTransmission): Promise<void> {\r\n        const adapter = this._loader._getOrCreateMaterialAdapter(babylonMaterial);\r\n        const transmissionWeight = extension.transmissionFactor !== undefined ? extension.transmissionFactor : 0.0;\r\n\r\n        if (transmissionWeight === 0) {\r\n            return Promise.resolve();\r\n        }\r\n\r\n        // Set transmission properties immediately via adapter\r\n        adapter.configureTransmission();\r\n        adapter.transmissionWeight = transmissionWeight;\r\n\r\n        // Handle transmission helper setup (only needed for PBR materials)\r\n        if (transmissionWeight > 0 && !this._loader.parent.dontUseTransmissionHelper) {\r\n            const scene = babylonMaterial.getScene() as unknown as ITransmissionHelperHolder;\r\n            if (!scene._transmissionHelper) {\r\n                new TransmissionHelper({}, babylonMaterial.getScene());\r\n            } else if (!scene._transmissionHelper?._isRenderTargetValid()) {\r\n                // If the render target is not valid, recreate it.\r\n                scene._transmissionHelper?._setupRenderTargets();\r\n            }\r\n        }\r\n\r\n        // Load texture if present\r\n        let texturePromise: Promise<Nullable<BaseTexture>> = Promise.resolve(null);\r\n        if (extension.transmissionTexture) {\r\n            (extension.transmissionTexture as ITextureInfo).nonColorData = true;\r\n            texturePromise = this._loader.loadTextureInfoAsync(`${context}/transmissionTexture`, extension.transmissionTexture, (texture: BaseTexture) => {\r\n                texture.name = `${babylonMaterial.name} (Transmission)`;\r\n                adapter.transmissionWeightTexture = texture;\r\n            });\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return texturePromise.then(() => {});\r\n    }\r\n}\r\n\r\nunregisterGLTFExtension(NAME);\r\nregisterGLTFExtension(NAME, true, (loader) => new KHR_materials_transmission(loader));\r\n"],"names":["TransmissionHelper","_GetDefaultOptions","renderSize","samples","lodGenerationScale","lodGenerationOffset","renderTargetTextureType","TEXTURETYPE_HALF_FLOAT","generateMipmaps","constructor","options","scene","_opaqueRenderTarget","_opaqueMeshesCache","_transparentMeshesCache","_materialObservers","this","_options","_scene","_transmissionHelper","onErrorObservable","onDisposeObservable","addOnce","dispose","_parseScene","_setupRenderTargets","updateOptions","Object","keys","filter","key","length","newOptions","oldOptions","getOpaqueTarget","_shouldRenderAsTransmission","material","subSurface","isRefractionEnabled","_addMesh","mesh","uniqueId","onMaterialChangedObservable","add","_onMeshMaterialChanged","bind","SetImmediate","refractionTexture","indexOf","push","_removeMesh","remove","idx","splice","meshes","forEach","onNewMeshAddedObservable","onMeshRemovedObservable","transparentIdx","opaqueIdx","_isRenderTargetValid","getInternalTexture","saveSceneEnvIntensity","undefined","ignoreCameraViewport","renderList","clearColor","clone","gammaSpace","renderSprites","renderParticles","disableImageProcessing","onBeforeBindObservable","opaqueRenderTarget","environmentIntensity","copyFrom","toLinearSpaceToRef","getEngine","useExactSrgbConversions","onAfterUnbindObservable","NAME","KHR_materials_transmission","loader","name","order","_loader","enabled","isExtensionUsed","parent","transparencyAsCoverage","loadMaterialPropertiesAsync","context","babylonMaterial","LoadExtensionAsync","async","extensionContext","extension","promises","Array","_loadTransparentPropertiesAsync","Promise","all","then","adapter","_getOrCreateMaterialAdapter","transmissionWeight","transmissionFactor","resolve","configureTransmission","dontUseTransmissionHelper","getScene","texturePromise","transmissionTexture","nonColorData","loadTextureInfoAsync","texture","transmissionWeightTexture"],"ignoreList":[],"sourceRoot":""}