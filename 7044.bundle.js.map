{"version":3,"file":"7044.bundle.js","mappings":"sKAoBO,MAAeA,UAAqB,IACvC,YAAsBC,EAAcC,GAChCC,MAAMF,EAAMC,EAChB,E,eCdG,MAAME,UAAyBJ,EAOlC,YAAmBC,EAAcC,GAC7BC,MAAMF,EAAMC,GAEZG,KAAKC,UAAY,IAAIF,EAAiBG,UAAUF,KACpD,CAGO,gBAAMG,CAAWC,GAGpB,SAFMJ,KAAKC,UAAUI,UAAUD,GAE3BJ,KAAKH,OAAOS,UACPN,KAAKO,SAASP,KAAKH,OAAOS,SAC3B,MAAM,IAAIE,MAAM,kBAIxBR,KAAKH,OAAOY,YAAYT,KAC5B,CAGgB,OAAAU,GACZZ,MAAMY,UAENV,KAAKH,OAAOc,eAAeX,KAC/B,CAGA,WAAWY,GACP,OAAOZ,KAAKC,UAAUW,OAC1B,CAGA,YAAWC,GACP,OAAOb,KAAKC,UAAUY,QAC1B,CAEmB,QAAAN,CAASO,GAGxB,QAFkBhB,MAAMS,SAASO,KAM7BA,EAAKF,SACLZ,KAAKa,UAAUE,QAAQD,EAAKF,UAGzB,EACX,CAEmB,WAAAI,CAAYF,GAG3B,QAFqBhB,MAAMkB,YAAYF,KAMnCA,EAAKF,SACLZ,KAAKa,UAAUI,WAAWH,EAAKF,UAG5B,EACX,CAGO,YAAAM,GACH,MAAO,kBACX,EAEe,EAAAhB,UAAY,cAAc,IAGrC,oBAAciB,GACV,OAAOnB,KAAKoB,OAAOD,kBAAoB,IAC3C,E,kDC5ED,MAAeE,UAAyB,IAC3C,YAAsBzB,EAAcC,GAChCC,MAAMF,EAAMC,EAAQ,EACxB,E","sources":["webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/mainAudioBus.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/webAudio/webAudioMainBus.ts?","webpack://@dev/inspector-v2/../core/src/AudioV2/abstractAudio/abstractAudioBus.ts?"],"sourcesContent":["import { AbstractAudioBus } from \"./abstractAudioBus\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\nimport type { IAbstractAudioBusOptions } from \"./abstractAudioBus\";\n\n/**\n * Options for creating a main audio bus.\n */\nexport interface IMainAudioBusOptions extends IAbstractAudioBusOptions {}\n\n/**\n * Abstract class representing a main audio bus.\n *\n * Main audio buses are the last bus in the audio graph.\n *\n * Unlike {@link AudioBus} instances, `MainAudioBus` instances have no spatial audio and stereo output capabilities,\n * and they cannot be connected downstream to another audio bus. They only connect downstream to the audio engine's\n * main output.\n *\n * Main audio buses are created by the {@link CreateMainAudioBusAsync} function.\n */\nexport abstract class MainAudioBus extends AbstractAudioBus {\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine);\n    }\n}\n","import type { Nullable } from \"../../types\";\nimport type { AbstractAudioNode } from \"../abstractAudio/abstractAudioNode\";\nimport type { IMainAudioBusOptions } from \"../abstractAudio/mainAudioBus\";\nimport { MainAudioBus } from \"../abstractAudio/mainAudioBus\";\nimport { _WebAudioBaseSubGraph } from \"./subNodes/webAudioBaseSubGraph\";\nimport type { _WebAudioEngine } from \"./webAudioEngine\";\nimport type { IWebAudioInNode, IWebAudioSuperNode } from \"./webAudioNode\";\n\n/** @internal */\nexport class _WebAudioMainBus extends MainAudioBus implements IWebAudioSuperNode {\n    protected _subGraph: _WebAudioBaseSubGraph;\n\n    /** @internal */\n    public override readonly engine: _WebAudioEngine;\n\n    /** @internal */\n    public constructor(name: string, engine: _WebAudioEngine) {\n        super(name, engine);\n\n        this._subGraph = new _WebAudioMainBus._SubGraph(this);\n    }\n\n    /** @internal */\n    public async _initAsync(options: Partial<IMainAudioBusOptions>): Promise<void> {\n        await this._subGraph.initAsync(options);\n\n        if (this.engine.mainOut) {\n            if (!this._connect(this.engine.mainOut)) {\n                throw new Error(\"Connect failed\");\n            }\n        }\n\n        this.engine._addMainBus(this);\n    }\n\n    /** @internal */\n    public override dispose(): void {\n        super.dispose();\n\n        this.engine._removeMainBus(this);\n    }\n\n    /** @internal */\n    public get _inNode() {\n        return this._subGraph._inNode;\n    }\n\n    /** @internal */\n    public get _outNode() {\n        return this._subGraph._outNode;\n    }\n\n    protected override _connect(node: IWebAudioInNode): boolean {\n        const connected = super._connect(node);\n\n        if (!connected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n\n        return true;\n    }\n\n    protected override _disconnect(node: IWebAudioInNode): boolean {\n        const disconnected = super._disconnect(node);\n\n        if (!disconnected) {\n            return false;\n        }\n\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n\n        return true;\n    }\n\n    /** @internal */\n    public getClassName(): string {\n        return \"_WebAudioMainBus\";\n    }\n\n    private static _SubGraph = class extends _WebAudioBaseSubGraph {\n        protected override _owner: _WebAudioMainBus;\n\n        protected get _downstreamNodes(): Nullable<Set<AbstractAudioNode>> {\n            return this._owner._downstreamNodes ?? null;\n        }\n    };\n}\n","import { AudioNodeType } from \"./abstractAudioNode\";\nimport type { IAbstractAudioOutNodeOptions } from \"./abstractAudioOutNode\";\nimport { AbstractAudioOutNode } from \"./abstractAudioOutNode\";\nimport type { AudioEngineV2 } from \"./audioEngineV2\";\n\n/** @internal */\nexport interface IAbstractAudioBusOptions extends IAbstractAudioOutNodeOptions {}\n\n/**\n * Abstract class representing an audio bus with volume control.\n *\n * An audio bus is a node in the audio graph that can have multiple inputs and outputs. It is typically used to group\n * sounds together and apply effects to them.\n */\nexport abstract class AbstractAudioBus extends AbstractAudioOutNode {\n    protected constructor(name: string, engine: AudioEngineV2) {\n        super(name, engine, AudioNodeType.HAS_INPUTS_AND_OUTPUTS);\n    }\n}\n"],"names":["MainAudioBus","name","engine","super","_WebAudioMainBus","this","_subGraph","_SubGraph","_initAsync","options","initAsync","mainOut","_connect","Error","_addMainBus","dispose","_removeMainBus","_inNode","_outNode","node","connect","_disconnect","disconnect","getClassName","_downstreamNodes","_owner","AbstractAudioBus"],"ignoreList":[],"sourceRoot":""}