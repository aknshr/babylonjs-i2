{"version":3,"file":"5198.bundle.js","mappings":"0RAeA,IAAIA,EAAmC,GACvC,MAAMC,EAAoB,CAACC,EAAoBC,KACvCD,EAASE,iBAIbD,EAAwBE,WAAWC,KAAKJ,EAASK,wBAE3CP,EAAsBE,EAASM,KAAM,IAGzCC,EAAgB,CAACC,EAAYC,KAC/B,MAAMC,EAA2B,CAAC,EAG5BV,EAAWQ,EAAKG,UAatB,OAZIX,IACKQ,EAAKI,WAAWC,gBAAgBb,EAASM,KAE1CP,EAAkBC,EAAUS,EAAmBK,aAKnDN,EAAKO,WACLP,EAAKO,UAAUL,GAGZA,GAGLM,EAAqB,CAACC,EAAYP,KACpC,GAAKO,EAAcC,QAAS,CACxB,MAAMV,EAAOS,EAEb,GAAIT,EAAKW,iBAAmB,IAAUC,uBAAyBZ,EAAKW,iBAAmB,IAAUE,oBAAqB,CAClH,MAAMC,EAAqBC,IACvBb,EAAoBc,UAAYd,EAAoBc,WAAa,GAC7DhB,EAAKe,WAAab,EAAoBc,UAAUC,MAAMC,GAAkBA,EAAIpB,KAAkBE,EAAKe,SAAUjB,MAC7GI,EAAoBc,UAAUpB,KAAKmB,EAASR,cAKpD,GAAIP,EAAKe,WAAaf,EAAKe,SAASrB,eAChC,GAAIM,EAAKe,oBAAoB,KAEzB,GADAb,EAAoBiB,eAAiBjB,EAAoBiB,gBAAkB,IACtEjB,EAAoBiB,eAAeF,MAAMC,GAAkBA,EAAIpB,KAAkBE,EAAKe,SAAUjB,KAAK,CACtGI,EAAoBiB,eAAevB,KAAKI,EAAKe,SAASR,aACtD,IAAK,MAAMa,KAAepB,EAAKe,SAASM,aAChCD,GACAN,EAAkBM,EAG9B,OAEAN,EAAkBd,EAAKe,eAEnBf,EAAKe,UACbD,EAAkBd,EAAKI,WAAWkB,iBAItC,MAAM9B,EAAWQ,EAAKG,UAClBX,IACKU,EAAoBI,aACrBJ,EAAoBI,WAAa,CAAC,EAElCJ,EAAoBI,WAAWiB,MAAQ,GACvCrB,EAAoBI,WAAWkB,QAAU,GACzCtB,EAAoBI,WAAWmB,UAAY,GAC3CvB,EAAoBI,WAAWoB,QAAU,GACzCxB,EAAoBI,WAAWqB,QAAU,GACzCzB,EAAoBI,WAAWsB,OAAS,GACxC1B,EAAoBI,WAAWuB,WAAa,GAC5C3B,EAAoBI,WAAWX,WAAa,IAGhDJ,EAAkBC,EAAUU,EAAoBI,aAGhDN,EAAK8B,WAAa9B,EAAK8B,SAASpC,iBAChCQ,EAAoB6B,UAAY7B,EAAoB6B,WAAa,GACjE7B,EAAoB6B,UAAUnC,KAAKI,EAAK8B,SAASvB,cAIrDL,EAAoB8B,OAAS9B,EAAoB8B,QAAU,GAC3D9B,EAAoB8B,OAAOpC,KAAKG,EAAcC,EAAME,GACxD,CACJ,MAAO,GAA4B,kBAAxBO,EAAKwB,eAAoC,CAChD,MAAMC,EAAgBzB,EACtBP,EAAoBiC,eAAevC,KAAKsC,EAAc3B,YAC1D,MAAO,IAA+C,IAA3CE,EAAKwB,eAAeG,QAAQ,UAAkB,CACrD,MAAMC,EAAS5B,EACfP,EAAoBoC,QAAQ1C,KAAKyC,EAAO9B,YAC5C,MAAO,IAA8C,IAA1CE,EAAKwB,eAAeG,QAAQ,SAAiB,CACpD,MAAMG,EAAQ9B,EACdP,EAAoBsC,OAAO5C,KAAK2C,EAAMhC,YAC1C,GAMG,MAAMkC,EAIF,iBAAOC,GACVpD,EAAuB,EAC3B,CASO,gBAAOqD,CAAUC,GACpB,OAAOH,EAAgBI,WAAWD,EACtC,CAEQ,iBAAOC,CAAWD,EAAcE,GAAyB,GAC7D,MAAM5C,EAA2B,CAAC,EAmClC,GAjCI4C,IAA2BF,EAAMG,YAAYC,UAAUC,wBAA0B,IAAQC,uBACzF,IAAOC,KAAK,sIAGhBV,EAAgBC,aAGhBxC,EAAoBkD,yBAA2BR,EAAMQ,yBACrDlD,EAAoBmD,UAAYT,EAAMS,UACtCnD,EAAoBoD,WAAaV,EAAMU,WAAWC,UAClDrD,EAAoBsD,aAAeZ,EAAMY,aAAaD,UACtDrD,EAAoBuD,QAAUb,EAAMa,QAAQF,UAC5CrD,EAAoBwD,kBAAoBd,EAAMc,kBAC9CxD,EAAoByD,qBAAuBf,EAAMe,0BAG3BC,IAAlBhB,EAAMiB,SAA2C,OAAlBjB,EAAMiB,UACrC3D,EAAoB2D,QAAUjB,EAAMiB,cAEjBD,IAAnBhB,EAAMkB,UAA6C,OAAnBlB,EAAMkB,WACtC5D,EAAoB4D,SAAWlB,EAAMkB,SAASP,gBAE3BK,IAAnBhB,EAAMmB,UAA6C,OAAnBnB,EAAMmB,WACtC7D,EAAoB6D,SAAWnB,EAAMmB,eAEpBH,IAAjBhB,EAAMoB,QAAyC,OAAjBpB,EAAMoB,SACpC9D,EAAoB8D,OAASpB,EAAMoB,aAEdJ,IAArBhB,EAAMqB,YAAiD,OAArBrB,EAAMqB,aACxC/D,EAAoB+D,WAAarB,EAAMqB,YAIvCrB,EAAMsB,kBAAoBtB,EAAMsB,mBAAoB,CACpD,MAAMC,EAAevB,EAAMwB,mBAEvBD,IACAjE,EAAoBmE,gBAAiB,EACrCnE,EAAoBoE,eAAiBH,EAAaV,QAAQF,UAC1DrD,EAAoBqE,cAAgBJ,EAAaK,uBAEzD,CAGI5B,EAAM6B,WACNvE,EAAoBuE,SAAW7B,EAAM6B,UAIzCvE,EAAoBwE,oBAAsB,GAC1C,IAAK,MAAMC,KAAgB/B,EAAMZ,OAAQ,CACrC,MAAM4C,EAAiBD,EAAcE,mBAEjCD,GACA1E,EAAoBwE,oBAAoB9E,KAAKgF,EAAQrE,YAE7D,CAIA,IAAIuE,EACAvC,EAiDAxB,EAhDJ,IAHAb,EAAoBsC,OAAS,GAGxBsC,EAAQ,EAAGA,EAAQlC,EAAMJ,OAAOuC,OAAQD,IACzCvC,EAAQK,EAAMJ,OAAOsC,GAEhBvC,EAAM7C,gBACPQ,EAAoBsC,OAAO5C,KAAK2C,EAAMhC,aAM9C,IADAL,EAAoBoC,QAAU,GACzBwC,EAAQ,EAAGA,EAAQlC,EAAMN,QAAQyC,OAAQD,IAAS,CACnD,MAAMzC,EAASO,EAAMN,QAAQwC,GAExBzC,EAAO3C,gBACRQ,EAAoBoC,QAAQ1C,KAAKyC,EAAO9B,YAEhD,CAUA,GARIqC,EAAMoC,eACN9E,EAAoB+E,eAAiBrC,EAAMoC,aAAalF,IAI5D,IAAoBoF,2BAA2BtC,EAAO1C,GAGlD0C,EAAMuC,iBAAmBvC,EAAMuC,gBAAgBJ,OAAS,EAAG,CAC3D7E,EAAoBiF,gBAAkB,GACtC,IAAK,IAAIC,EAAsB,EAAGA,EAAsBxC,EAAMuC,gBAAgBJ,OAAQK,IAAuB,CACzG,MAAMC,EAAiBzC,EAAMuC,gBAAgBC,GAE7ClF,EAAoBiF,gBAAgBvF,KAAKyF,EAAe9E,YAC5D,CACJ,CAGA,GAAIqC,EAAM0C,kBAAoB1C,EAAM0C,iBAAiBP,OAAS,EAG1D,IAFA7E,EAAoBoF,iBAAmB,GAElCR,EAAQ,EAAGA,EAAQlC,EAAM0C,iBAAiBP,OAAQD,IAAS,CAC5D,MAAMS,EAAkB3C,EAAM0C,iBAAiBR,GAC/C5E,EAAoBoF,iBAAiB1F,KAAK2F,EAAgBhF,YAC9D,CAOJ,IAHAL,EAAoBc,UAAY,GAChCd,EAAoBiB,eAAiB,GAEhC2D,EAAQ,EAAGA,EAAQlC,EAAM5B,UAAU+D,OAAQD,IAC5C/D,EAAW6B,EAAM5B,UAAU8D,GACtB/D,EAASrB,gBACVQ,EAAoBc,UAAUpB,KAAKmB,EAASR,aAMpD,IADAL,EAAoBiB,eAAiB,GAChC2D,EAAQ,EAAGA,EAAQlC,EAAMzB,eAAe4D,OAAQD,IAAS,CAC1D,MAAMU,EAAgB5C,EAAMzB,eAAe2D,GAC3C5E,EAAoBiB,eAAevB,KAAK4F,EAAcjF,YAC1D,CAoBA,IAjBIqC,EAAM6C,qBACD7C,EAAM6C,mBAAmCC,OAC1CxF,EAAoBuF,mBAAqB7C,EAAM6C,mBAAmBlF,aAElEL,EAAoBuF,mBAAqB7C,EAAM6C,mBAAmBE,KAClEzF,EAAoB0F,4BAA+BhD,EAAM6C,mBAAmCI,YAKpG3F,EAAoB4F,qBAAuBlD,EAAMkD,qBAGjD5F,EAAoB6F,aAAenD,EAAMmD,aAGzC7F,EAAoB6B,UAAY,GAC3B+C,EAAQ,EAAGA,EAAQlC,EAAMb,UAAUgD,OAAQD,IAAS,CACrD,MAAMhD,EAAWc,EAAMb,UAAU+C,GAC5BhD,EAASpC,gBACVQ,EAAoB6B,UAAUnC,KAAKkC,EAASvB,YAEpD,CAIA,IADAL,EAAoBiC,eAAiB,GAChC2C,EAAQ,EAAGA,EAAQlC,EAAMT,eAAe4C,OAAQD,IAC5ClC,EAAMT,eAAe2C,GAAOpF,gBAC7BQ,EAAoBiC,eAAevC,KAAKgD,EAAMT,eAAe2C,GAAOvE,aAK5EL,EAAoBI,WAAa,CAAC,EAElCJ,EAAoBI,WAAWiB,MAAQ,GACvCrB,EAAoBI,WAAWkB,QAAU,GACzCtB,EAAoBI,WAAWmB,UAAY,GAC3CvB,EAAoBI,WAAWoB,QAAU,GACzCxB,EAAoBI,WAAWqB,QAAU,GACzCzB,EAAoBI,WAAWsB,OAAS,GACxC1B,EAAoBI,WAAWuB,WAAa,GAC5C3B,EAAoBI,WAAWX,WAAa,GAE5CL,EAAuB,GACvB,MAAMgB,EAAasC,EAAMoD,gBACzB,IAAKlB,EAAQ,EAAGA,EAAQxE,EAAWyE,OAAQD,IAAS,CAChD,MAAMtF,EAAWc,EAAWwE,GAExBtF,EAASyG,WACT1G,EAAkBC,EAAUU,EAAoBI,WAExD,CAIA,IADAJ,EAAoB8B,OAAS,GACxB8C,EAAQ,EAAGA,EAAQlC,EAAMZ,OAAO+C,OAAQD,IAAS,CAClD,MAAMH,EAAe/B,EAAMZ,OAAO8C,GAElC,GAAIH,aAAwB,IAAM,CAC9B,MAAM3E,EAAO2E,EACR3E,EAAKN,gBACFM,EAAKW,iBAAmB,IAAUC,uBAAyBZ,EAAKW,iBAAmB,IAAUE,qBAC7FX,EAAoB8B,OAAOpC,KAAKG,EAAcC,EAAME,GAGhE,CACJ,CAIA,IADAA,EAAoBgG,gBAAkB,GACjCpB,EAAQ,EAAGA,EAAQlC,EAAMsD,gBAAgBnB,OAAQD,IAAS,CAC3D,MAAMqB,EAAiBvD,EAAMsD,gBAAgBpB,GACxCqB,EAAezG,gBAChBQ,EAAoBgG,gBAAgBtG,KAAKuG,EAAe5F,WAAU,GAE1E,CAIA,IADAL,EAAoBkG,cAAgB,GAC/BtB,EAAQ,EAAGA,EAAQlC,EAAMwD,cAAcrB,OAAQD,IAAS,CACzD,MAAMuB,EAAczD,EAAMwD,cAActB,GACnCuB,EAAY3G,gBACbQ,EAAoBkG,cAAcxG,KAAKyG,EAAY9F,YAE3D,CAGIqC,EAAM0D,gBACNpG,EAAoBqG,QAAU3D,EAAM0D,cAAc/F,UAAU,UAIhE,IAAK,MAAMiG,KAAa5D,EAAM6D,wBAC1BD,EAAUjG,UAAUL,GAIxB,GAAI0C,EAAM8D,eAEN,IADAxG,EAAoBwG,eAAiB,GAChC5B,EAAQ,EAAGA,EAAQlC,EAAM8D,eAAe3B,OAAQD,IAAS,CAC1D,MAAM6B,EAAgB/D,EAAM8D,eAAe5B,GACtC6B,EAAcjH,gBACfQ,EAAoBwG,eAAe9G,KAAK+G,EAAcpG,WAAU,GAExE,CAGJ,OAAOL,CACX,CAOO,2BAAa0G,CAAehE,GAC/B,MAAM1C,EAAsBuC,EAAgBI,WAAWD,GAAO,GAExDiE,EAAgC,GAKtC,OAHAC,KAAKC,iBAAiB7G,EAAqB2G,SAErCG,QAAQC,IAAIJ,GACX3G,CACX,CAEQ,uBAAO6G,CAAiBG,EAAUL,GACtC,GAAIM,MAAMC,QAAQF,GACd,IAAK,IAAIG,EAAI,EAAGA,EAAIH,EAAInC,SAAUsC,EAAG,CACjC,MAAMC,EAAIJ,EAAIG,GACVC,aAAaN,QAEbH,EAASjH,KAAK0H,EAAEC,MAAMC,GAAcN,EAAIG,GAAKG,MACtCF,aAAaG,QAAUN,MAAMC,QAAQE,KAC5CR,KAAKC,iBAAiBO,EAAGT,EAEjC,MACG,GAAIK,aAAeO,OACtB,IAAK,MAAM9B,KAAQuB,EACf,GAAIO,OAAOC,UAAUC,eAAeC,KAAKV,EAAKvB,GAAO,CACjD,MAAM2B,EAAIJ,EAAIvB,GACV2B,aAAaN,QAEbH,EAASjH,KAAK0H,EAAEC,MAAMC,GAAcN,EAAIvB,GAAQ6B,MACzCF,aAAaG,QAAUN,MAAMC,QAAQE,KAC5CR,KAAKC,iBAAiBO,EAAGT,EAEjC,CAGZ,CASO,oBAAO9G,CAAc8H,EAAuCC,GAAuB,EAAOC,GAAwB,GACrH,MAAM7H,EAA2B,CACjCA,OAA6B,GAC7BA,eAAqC,GACrCA,QAA8B,GAC9BA,OAA6B,IAM7B,GAJAuC,EAAgBC,aAEhBmF,EAAcA,aAAuBV,MAAQU,EAAc,CAACA,GAExDC,GAAeC,EAEf,IAAK,IAAIV,EAAI,EAAGA,EAAIQ,EAAY9C,SAAUsC,EAAG,CACzC,GAAIU,EAAc,CACd,MAAMC,EAAcH,EAAYR,GAAGY,iBACnC,IAAK,MAAMxH,KAAQuH,EACXH,EAAYzF,QAAQ3B,GAAQ,IAAMA,EAAKf,gBACvCmI,EAAYjI,KAAKa,EAG7B,CAEIqH,GAAeD,EAAYR,GAAGa,QAAUL,EAAYzF,QAAQyF,EAAYR,GAAGa,QAAU,IAAML,EAAYR,GAAGa,OAAOxI,gBACjHmI,EAAYjI,KAAKiI,EAAYR,GAAGa,OAExC,CAGJ,IAAK,MAAMlI,KAAQ6H,EACfrH,EAAmBR,EAAME,GAG7B,OAAOA,CACX,E,4HCrbJ,MAAMiI,EAAsB,CACxB,CAAEC,MAAO,MAAOC,MAAO,EAAGC,UAAW,aACrC,CAAEF,MAAO,OAAQC,MAAO,EAAGC,UAAW,eAS7BC,EAA0D,EAAG3F,YACtE,MAAO4F,EAAsBC,IAA2B,IAAAC,UAA+C,CACnGC,eAAgB,EAChBC,aAAc,GACdC,YAAY,IAGVC,GAAgB,IAAAC,cAAYC,UAC9B,MAAMC,EAAWC,KAAKC,UAAU1G,EAAgBE,UAAUC,IACpDwG,EAAO,IAAIC,KAAK,CAACJ,GAAW,CAAEK,KAAM,iBAC1C,KAAMC,SAASH,EAAM,mBACtB,CAACxG,IAEE4G,GAAmB,IAAAT,cAAYC,UACjC,GAAKpG,EAAM6C,mBAIX,IACI,MAAMgE,QAAe,KAAwBC,sBAAsB9G,EAAM6C,mBAAmC,CACxG6C,UAAWH,EAAoBK,EAAqBG,gBAAgBL,UACpEM,aAAcJ,EAAqBI,aACnCe,0BAA2BnB,EAAqBK,aAE9CO,EAAO,IAAIC,KAAK,CAACI,GAAS,CAAEH,KAAM,iBACxC,KAAMC,SAASH,EAAM,kBACzB,CAAE,MAAOQ,GACL,IAAOC,MAAMD,GACbE,MAAMF,EACV,IACD,CAAChH,EAAO4F,IAEX,OACI,iCACI,SAAC,IAAU,CAACJ,MAAM,oBAAoB2B,KAAM,OAAsBC,QAASlB,KACzElG,EAAMG,YAAYkH,oBAAsBrH,EAAM6C,oBAAsB7C,EAAM6C,mBAAmByE,cAAgBtH,EAAMoC,eACjH,iCACI,SAAC,IAAU,CAACoD,MAAM,wBAAwB2B,KAAM,OAAsBC,QAASR,IAC9E5G,EAAM6C,mBAAmB0E,oBACtB,SAAC,IAAkB,CAEf/B,MAAM,kBACNgC,YAAY,iCACZ/B,MAAOG,EAAqBK,WAC5BwB,SAAWhC,IACPI,GAAyB6B,IAAS,IAAMA,EAAMzB,WAAYR,QAL1D,eASZ,SAAC,KAA0B,CACvBD,MAAM,aACNmC,QAASpC,EACTE,MAAOG,EAAqBG,eAC5B0B,SAAWG,IACP/B,GAAyB6B,IAAS,IAAMA,EAAM3B,eAAgB6B,UAGtE,SAAC,IAAQ,CAACC,QAASjC,EAAqBG,eAAiB,EAAC,UACtD,SAAC,IAAwB,CACrBP,MAAM,UACNC,MAAOG,EAAqBI,aAC5ByB,SAAWhC,GAAUI,GAAyB6B,IAAS,IAAMA,EAAM1B,aAAcP,MACjFqC,IAAK,EACLC,IAAK,aAiBpBC,GAAkB,QAAkB5B,UAE7C,MAAM,YAAE6B,SAAsB,wCAE9B,OAAQC,IACJ,MAAOC,EAAiBC,IAAsB,IAAAtC,WAAS,IAChDuC,EAAmBC,IAAwB,IAAAxC,UAA4C,CAC1FyC,qBAAqB,EACrBC,gBAAgB,EAChBC,eAAe,EACfC,cAAc,EACdC,kBAAkB,IAGhBC,GAAa,IAAAzC,cAAYC,UAC3BgC,GAAmB,GAoCnB,WACsBH,EAAYY,SAASX,EAAMlI,MAAO,QAAS,CACzD8I,sBAAuBT,EAAkBM,iBAAmB,aAAU3H,EACtE+H,iBAAmBlL,GArCN,CAACA,IAClB,IAAKwK,EAAkBE,sBACd1K,EAAKmL,YACN,OAAO,EAIf,IAAKX,EAAkBG,gBACf3K,aAAgB,KACZA,EAAKM,SAAU,CACf,MACM8K,EADWpL,EAAKM,SACa8K,kBACnC,GAAIA,GAAqBA,EAAkBC,kBAAoB,IAAQC,YACnE,OAAO,CAEf,CAIR,SAAKd,EAAkBI,eACf5K,aAAgB,MAKnBwK,EAAkBK,cACf7K,aAAgB,MAWQuL,CAAavL,MAEzCwL,eACR,CAAE,MAAOC,GACL,IAAOrC,MAAM,yBAAyBqC,IAC1C,C,QACIlB,GAAmB,EACvB,IACD,CAACC,EAAmBH,EAAMlI,QAE7B,OACI,iCACI,SAAC,IAAkB,CAEfwF,MAAM,wBACNgC,YAAY,0DACZ/B,MAAO4C,EAAkBE,oBACzBd,SAAW8B,GAAqBjB,EAAqB,IAAKD,EAAmBE,oBAAqBgB,KAJ9F,4BAMR,SAAC,IAAkB,CAEf/D,MAAM,kBACNgC,YAAY,+CACZ/B,MAAO4C,EAAkBG,eACzBf,SAAW8B,GAAqBjB,EAAqB,IAAKD,EAAmBG,eAAgBe,KAJzF,uBAMR,SAAC,IAAkB,CAEf/D,MAAM,iBACNgC,YAAY,0CACZ/B,MAAO4C,EAAkBI,cACzBhB,SAAW8B,GAAqBjB,EAAqB,IAAKD,EAAmBI,cAAec,KAJxF,sBAMR,SAAC,IAAkB,CAEf/D,MAAM,gBACNgC,YAAY,yCACZ/B,MAAO4C,EAAkBK,aACzBjB,SAAW8B,GAAqBjB,EAAqB,IAAKD,EAAmBK,aAAca,KAJvF,qBAMR,SAAC,IAAkB,CAEf/D,MAAM,oBACNgC,YAAY,kDACZ/B,MAAO4C,EAAkBM,iBACzBlB,SAAW8B,GAAqBjB,EAAqB,IAAKD,EAAmBM,iBAAkBY,KAJ3F,yBAMR,SAAC,IAAU,CAAC/D,MAAM,gBAAgB2B,KAAM,OAAsBC,QAASwB,EAAYY,SAAUrB,WCnNhGsB,EAAkE,CAC3EC,aAAc,eACdC,SAAU,CAAC,KACXC,QAAUC,IACN,MAAMC,EAAsC,GAoB5C,OAjBAA,EAAqB9M,KACjB6M,EAAaE,kBAAkB,CAC3BC,IAAK,cACLC,QAAS,cACTrG,UAAW,EAAGsG,cAAc,SAAClC,EAAe,CAAChI,MAAOkK,OAK5DJ,EAAqB9M,KACjB6M,EAAaE,kBAAkB,CAC3BC,IAAK,iBACLC,QAAS,iBACTrG,UAAW,EAAGsG,cAAc,SAACvE,EAAkB,CAAC3F,MAAOkK,OAIxD,CACHC,QAAS,KACLL,EAAqBM,SAASC,GAAiBA,EAAaF,gBAM5E,GACIG,mBAAoB,CAACb,G","sources":["webpack://@dev/inspector-v2/../core/src/Misc/sceneSerializer.ts?","webpack://@dev/inspector-v2/./src/components/tools/exportTools.tsx?","webpack://@dev/inspector-v2/./src/services/panes/tools/exportService.tsx?"],"sourcesContent":["import type { Geometry } from \"../Meshes/geometry\";\r\nimport { Mesh } from \"../Meshes/mesh\";\r\nimport { Constants } from \"../Engines/constants\";\r\nimport { MultiMaterial } from \"../Materials/multiMaterial\";\r\nimport type { Material } from \"../Materials/material\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Light } from \"../Lights/light\";\r\nimport { SerializationHelper } from \"./decorators.serialization\";\r\nimport { Texture } from \"../Materials/Textures/texture\";\r\nimport type { CubeTexture } from \"../Materials/Textures/cubeTexture\";\r\nimport type { Node } from \"../node\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport type { Camera } from \"../Cameras/camera\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nlet SerializedGeometries: Geometry[] = [];\r\nconst SerializeGeometry = (geometry: Geometry, serializationGeometries: any): any => {\r\n    if (geometry.doNotSerialize) {\r\n        return;\r\n    }\r\n\r\n    serializationGeometries.vertexData.push(geometry.serializeVerticeData());\r\n\r\n    (<any>SerializedGeometries)[geometry.id] = true;\r\n};\r\n\r\nconst SerializeMesh = (mesh: Mesh, serializationScene: any): any => {\r\n    const serializationObject: any = {};\r\n\r\n    // Geometry\r\n    const geometry = mesh._geometry;\r\n    if (geometry) {\r\n        if (!mesh.getScene().getGeometryById(geometry.id)) {\r\n            // Geometry was in the memory but not added to the scene, nevertheless it's better to serialize to be able to reload the mesh with its geometry\r\n            SerializeGeometry(geometry, serializationScene.geometries);\r\n        }\r\n    }\r\n\r\n    // Custom\r\n    if (mesh.serialize) {\r\n        mesh.serialize(serializationObject);\r\n    }\r\n\r\n    return serializationObject;\r\n};\r\n\r\nconst FinalizeSingleNode = (node: Node, serializationObject: any) => {\r\n    if ((node as Mesh)._isMesh) {\r\n        const mesh = node as Mesh;\r\n        //only works if the mesh is already loaded\r\n        if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n            const serializeMaterial = (material: Material) => {\r\n                serializationObject.materials = serializationObject.materials || [];\r\n                if (mesh.material && !serializationObject.materials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                    serializationObject.materials.push(material.serialize());\r\n                }\r\n            };\r\n\r\n            //serialize material\r\n            if (mesh.material && !mesh.material.doNotSerialize) {\r\n                if (mesh.material instanceof MultiMaterial) {\r\n                    serializationObject.multiMaterials = serializationObject.multiMaterials || [];\r\n                    if (!serializationObject.multiMaterials.some((mat: Material) => mat.id === (<Material>mesh.material).id)) {\r\n                        serializationObject.multiMaterials.push(mesh.material.serialize());\r\n                        for (const submaterial of mesh.material.subMaterials) {\r\n                            if (submaterial) {\r\n                                serializeMaterial(submaterial);\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    serializeMaterial(mesh.material);\r\n                }\r\n            } else if (!mesh.material) {\r\n                serializeMaterial(mesh.getScene().defaultMaterial);\r\n            }\r\n\r\n            //serialize geometry\r\n            const geometry = mesh._geometry;\r\n            if (geometry) {\r\n                if (!serializationObject.geometries) {\r\n                    serializationObject.geometries = {};\r\n\r\n                    serializationObject.geometries.boxes = [];\r\n                    serializationObject.geometries.spheres = [];\r\n                    serializationObject.geometries.cylinders = [];\r\n                    serializationObject.geometries.toruses = [];\r\n                    serializationObject.geometries.grounds = [];\r\n                    serializationObject.geometries.planes = [];\r\n                    serializationObject.geometries.torusKnots = [];\r\n                    serializationObject.geometries.vertexData = [];\r\n                }\r\n\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n            // Skeletons\r\n            if (mesh.skeleton && !mesh.skeleton.doNotSerialize) {\r\n                serializationObject.skeletons = serializationObject.skeletons || [];\r\n                serializationObject.skeletons.push(mesh.skeleton.serialize());\r\n            }\r\n\r\n            //serialize the actual mesh\r\n            serializationObject.meshes = serializationObject.meshes || [];\r\n            serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n        }\r\n    } else if (node.getClassName() === \"TransformNode\") {\r\n        const transformNode = node as TransformNode;\r\n        serializationObject.transformNodes.push(transformNode.serialize());\r\n    } else if (node.getClassName().indexOf(\"Camera\") !== -1) {\r\n        const camera = node as Camera;\r\n        serializationObject.cameras.push(camera.serialize());\r\n    } else if (node.getClassName().indexOf(\"Light\") !== -1) {\r\n        const light = node as Light;\r\n        serializationObject.lights.push(light.serialize());\r\n    }\r\n};\r\n\r\n/**\r\n * Class used to serialize a scene into a string\r\n */\r\nexport class SceneSerializer {\r\n    /**\r\n     * Clear cache used by a previous serialization\r\n     */\r\n    public static ClearCache(): void {\r\n        SerializedGeometries = [];\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * Note that if the current engine does not support synchronous texture reading (like WebGPU), you should use SerializeAsync instead\r\n     * as else you may not retrieve the proper base64 encoded texture data (when using the Texture.ForceSerializeBuffers flag)\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static Serialize(scene: Scene): any {\r\n        return SceneSerializer._Serialize(scene);\r\n    }\r\n\r\n    private static _Serialize(scene: Scene, checkSyncReadSupported = true): any {\r\n        const serializationObject: any = {};\r\n\r\n        if (checkSyncReadSupported && !scene.getEngine()._features.supportSyncTextureRead && Texture.ForceSerializeBuffers) {\r\n            Logger.Warn(\"The serialization object may not contain the proper base64 encoded texture data! You should use the SerializeAsync method instead.\");\r\n        }\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        // Scene\r\n        serializationObject.useDelayedTextureLoading = scene.useDelayedTextureLoading;\r\n        serializationObject.autoClear = scene.autoClear;\r\n        serializationObject.clearColor = scene.clearColor.asArray();\r\n        serializationObject.ambientColor = scene.ambientColor.asArray();\r\n        serializationObject.gravity = scene.gravity.asArray();\r\n        serializationObject.collisionsEnabled = scene.collisionsEnabled;\r\n        serializationObject.useRightHandedSystem = scene.useRightHandedSystem;\r\n\r\n        // Fog\r\n        if (scene.fogMode !== undefined && scene.fogMode !== null) {\r\n            serializationObject.fogMode = scene.fogMode;\r\n        }\r\n        if (scene.fogColor !== undefined && scene.fogColor !== null) {\r\n            serializationObject.fogColor = scene.fogColor.asArray();\r\n        }\r\n        if (scene.fogStart !== undefined && scene.fogStart !== null) {\r\n            serializationObject.fogStart = scene.fogStart;\r\n        }\r\n        if (scene.fogEnd !== undefined && scene.fogEnd !== null) {\r\n            serializationObject.fogEnd = scene.fogEnd;\r\n        }\r\n        if (scene.fogDensity !== undefined && scene.fogDensity !== null) {\r\n            serializationObject.fogDensity = scene.fogDensity;\r\n        }\r\n\r\n        //Physics\r\n        if (scene.isPhysicsEnabled && scene.isPhysicsEnabled()) {\r\n            const physicEngine = scene.getPhysicsEngine();\r\n\r\n            if (physicEngine) {\r\n                serializationObject.physicsEnabled = true;\r\n                serializationObject.physicsGravity = physicEngine.gravity.asArray();\r\n                serializationObject.physicsEngine = physicEngine.getPhysicsPluginName();\r\n            }\r\n        }\r\n\r\n        // Metadata\r\n        if (scene.metadata) {\r\n            serializationObject.metadata = scene.metadata;\r\n        }\r\n\r\n        // Morph targets\r\n        serializationObject.morphTargetManagers = [];\r\n        for (const abstractMesh of scene.meshes) {\r\n            const manager = (<Mesh>abstractMesh).morphTargetManager;\r\n\r\n            if (manager) {\r\n                serializationObject.morphTargetManagers.push(manager.serialize());\r\n            }\r\n        }\r\n\r\n        // Lights\r\n        serializationObject.lights = [];\r\n        let index: number;\r\n        let light: Light;\r\n        for (index = 0; index < scene.lights.length; index++) {\r\n            light = scene.lights[index];\r\n\r\n            if (!light.doNotSerialize) {\r\n                serializationObject.lights.push(light.serialize());\r\n            }\r\n        }\r\n\r\n        // Cameras\r\n        serializationObject.cameras = [];\r\n        for (index = 0; index < scene.cameras.length; index++) {\r\n            const camera = scene.cameras[index];\r\n\r\n            if (!camera.doNotSerialize) {\r\n                serializationObject.cameras.push(camera.serialize());\r\n            }\r\n        }\r\n\r\n        if (scene.activeCamera) {\r\n            serializationObject.activeCameraID = scene.activeCamera.id;\r\n        }\r\n\r\n        // Animations\r\n        SerializationHelper.AppendSerializedAnimations(scene, serializationObject);\r\n\r\n        // Animation Groups\r\n        if (scene.animationGroups && scene.animationGroups.length > 0) {\r\n            serializationObject.animationGroups = [];\r\n            for (let animationGroupIndex = 0; animationGroupIndex < scene.animationGroups.length; animationGroupIndex++) {\r\n                const animationGroup = scene.animationGroups[animationGroupIndex];\r\n\r\n                serializationObject.animationGroups.push(animationGroup.serialize());\r\n            }\r\n        }\r\n\r\n        // Reflection probes\r\n        if (scene.reflectionProbes && scene.reflectionProbes.length > 0) {\r\n            serializationObject.reflectionProbes = [];\r\n\r\n            for (index = 0; index < scene.reflectionProbes.length; index++) {\r\n                const reflectionProbe = scene.reflectionProbes[index];\r\n                serializationObject.reflectionProbes.push(reflectionProbe.serialize());\r\n            }\r\n        }\r\n\r\n        // Materials\r\n        serializationObject.materials = [];\r\n        serializationObject.multiMaterials = [];\r\n        let material: Material;\r\n        for (index = 0; index < scene.materials.length; index++) {\r\n            material = scene.materials[index];\r\n            if (!material.doNotSerialize) {\r\n                serializationObject.materials.push(material.serialize());\r\n            }\r\n        }\r\n\r\n        // MultiMaterials\r\n        serializationObject.multiMaterials = [];\r\n        for (index = 0; index < scene.multiMaterials.length; index++) {\r\n            const multiMaterial = scene.multiMaterials[index];\r\n            serializationObject.multiMaterials.push(multiMaterial.serialize());\r\n        }\r\n\r\n        // Environment texture\r\n        if (scene.environmentTexture) {\r\n            if ((scene.environmentTexture as CubeTexture)._files) {\r\n                serializationObject.environmentTexture = scene.environmentTexture.serialize();\r\n            } else {\r\n                serializationObject.environmentTexture = scene.environmentTexture.name;\r\n                serializationObject.environmentTextureRotationY = (scene.environmentTexture as CubeTexture).rotationY;\r\n            }\r\n        }\r\n\r\n        // Environment Intensity\r\n        serializationObject.environmentIntensity = scene.environmentIntensity;\r\n\r\n        // IBL Intensity\r\n        serializationObject.iblIntensity = scene.iblIntensity;\r\n\r\n        // Skeletons\r\n        serializationObject.skeletons = [];\r\n        for (index = 0; index < scene.skeletons.length; index++) {\r\n            const skeleton = scene.skeletons[index];\r\n            if (!skeleton.doNotSerialize) {\r\n                serializationObject.skeletons.push(skeleton.serialize());\r\n            }\r\n        }\r\n\r\n        // Transform nodes\r\n        serializationObject.transformNodes = [];\r\n        for (index = 0; index < scene.transformNodes.length; index++) {\r\n            if (!scene.transformNodes[index].doNotSerialize) {\r\n                serializationObject.transformNodes.push(scene.transformNodes[index].serialize());\r\n            }\r\n        }\r\n\r\n        // Geometries\r\n        serializationObject.geometries = {};\r\n\r\n        serializationObject.geometries.boxes = [];\r\n        serializationObject.geometries.spheres = [];\r\n        serializationObject.geometries.cylinders = [];\r\n        serializationObject.geometries.toruses = [];\r\n        serializationObject.geometries.grounds = [];\r\n        serializationObject.geometries.planes = [];\r\n        serializationObject.geometries.torusKnots = [];\r\n        serializationObject.geometries.vertexData = [];\r\n\r\n        SerializedGeometries = [];\r\n        const geometries = scene.getGeometries();\r\n        for (index = 0; index < geometries.length; index++) {\r\n            const geometry = geometries[index];\r\n\r\n            if (geometry.isReady()) {\r\n                SerializeGeometry(geometry, serializationObject.geometries);\r\n            }\r\n        }\r\n\r\n        // Meshes\r\n        serializationObject.meshes = [];\r\n        for (index = 0; index < scene.meshes.length; index++) {\r\n            const abstractMesh = scene.meshes[index];\r\n\r\n            if (abstractMesh instanceof Mesh) {\r\n                const mesh = abstractMesh;\r\n                if (!mesh.doNotSerialize) {\r\n                    if (mesh.delayLoadState === Constants.DELAYLOADSTATE_LOADED || mesh.delayLoadState === Constants.DELAYLOADSTATE_NONE) {\r\n                        serializationObject.meshes.push(SerializeMesh(mesh, serializationObject));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Particles Systems\r\n        serializationObject.particleSystems = [];\r\n        for (index = 0; index < scene.particleSystems.length; index++) {\r\n            const particleSystem = scene.particleSystems[index];\r\n            if (!particleSystem.doNotSerialize) {\r\n                serializationObject.particleSystems.push(particleSystem.serialize(false));\r\n            }\r\n        }\r\n\r\n        // Post processes\r\n        serializationObject.postProcesses = [];\r\n        for (index = 0; index < scene.postProcesses.length; index++) {\r\n            const postProcess = scene.postProcesses[index];\r\n            if (!postProcess.doNotSerialize) {\r\n                serializationObject.postProcesses.push(postProcess.serialize());\r\n            }\r\n        }\r\n\r\n        // Action Manager\r\n        if (scene.actionManager) {\r\n            serializationObject.actions = scene.actionManager.serialize(\"scene\");\r\n        }\r\n\r\n        // Components\r\n        for (const component of scene._serializableComponents) {\r\n            component.serialize(serializationObject);\r\n        }\r\n\r\n        // Sprites\r\n        if (scene.spriteManagers) {\r\n            serializationObject.spriteManagers = [];\r\n            for (index = 0; index < scene.spriteManagers.length; index++) {\r\n                const spriteManager = scene.spriteManagers[index];\r\n                if (!spriteManager.doNotSerialize) {\r\n                    serializationObject.spriteManagers.push(spriteManager.serialize(true));\r\n                }\r\n            }\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Serialize a scene into a JSON compatible object\r\n     * @param scene defines the scene to serialize\r\n     * @returns a JSON promise compatible object\r\n     */\r\n    public static async SerializeAsync(scene: Scene): Promise<any> {\r\n        const serializationObject = SceneSerializer._Serialize(scene, false);\r\n\r\n        const promises: Array<Promise<any>> = [];\r\n\r\n        this._CollectPromises(serializationObject, promises);\r\n\r\n        await Promise.all(promises);\r\n        return serializationObject;\r\n    }\r\n\r\n    private static _CollectPromises(obj: any, promises: Array<Promise<any>>): void {\r\n        if (Array.isArray(obj)) {\r\n            for (let i = 0; i < obj.length; ++i) {\r\n                const o = obj[i];\r\n                if (o instanceof Promise) {\r\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, github/no-then\r\n                    promises.push(o.then((res: any) => (obj[i] = res)));\r\n                } else if (o instanceof Object || Array.isArray(o)) {\r\n                    this._CollectPromises(o, promises);\r\n                }\r\n            }\r\n        } else if (obj instanceof Object) {\r\n            for (const name in obj) {\r\n                if (Object.prototype.hasOwnProperty.call(obj, name)) {\r\n                    const o = obj[name];\r\n                    if (o instanceof Promise) {\r\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, github/no-then\r\n                        promises.push(o.then((res: any) => (obj[name] = res)));\r\n                    } else if (o instanceof Object || Array.isArray(o)) {\r\n                        this._CollectPromises(o, promises);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Serialize a mesh into a JSON compatible object\r\n     * @param toSerialize defines the mesh to serialize\r\n     * @param withParents defines if parents must be serialized as well\r\n     * @param withChildren defines if children must be serialized as well\r\n     * @returns a JSON compatible object\r\n     */\r\n    public static SerializeMesh(toSerialize: any /* Mesh || Mesh[] */, withParents: boolean = false, withChildren: boolean = false): any {\r\n        const serializationObject: any = {};\r\n        serializationObject.meshes = [];\r\n        serializationObject.transformNodes = [];\r\n        serializationObject.cameras = [];\r\n        serializationObject.lights = [];\r\n\r\n        SceneSerializer.ClearCache();\r\n\r\n        toSerialize = toSerialize instanceof Array ? toSerialize : [toSerialize];\r\n\r\n        if (withParents || withChildren) {\r\n            //deliberate for loop! not for each, appended should be processed as well.\r\n            for (let i = 0; i < toSerialize.length; ++i) {\r\n                if (withChildren) {\r\n                    const descendants = toSerialize[i].getDescendants();\r\n                    for (const node of descendants) {\r\n                        if (toSerialize.indexOf(node) < 0 && !node.doNotSerialize) {\r\n                            toSerialize.push(node);\r\n                        }\r\n                    }\r\n                }\r\n                //make sure the array doesn't contain the object already\r\n                if (withParents && toSerialize[i].parent && toSerialize.indexOf(toSerialize[i].parent) < 0 && !toSerialize[i].parent.doNotSerialize) {\r\n                    toSerialize.push(toSerialize[i].parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const mesh of toSerialize) {\r\n            FinalizeSingleNode(mesh, serializationObject);\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n}\r\n","import { NumberDropdownPropertyLine } from \"shared-ui-components/fluent/hoc/propertyLines/dropdownPropertyLine\";\r\nimport { SceneSerializer } from \"core/Misc/sceneSerializer\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { EnvironmentTextureTools } from \"core/Misc/environmentTextureTools\";\r\nimport type { CubeTexture } from \"core/Materials/Textures/cubeTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { useCallback, useState } from \"react\";\r\nimport type { FunctionComponent } from \"react\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { ButtonLine } from \"shared-ui-components/fluent/hoc/buttonLine\";\r\nimport { SyncedSliderPropertyLine } from \"shared-ui-components/fluent/hoc/propertyLines/syncedSliderPropertyLine\";\r\nimport type { Node } from \"core/node\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport type { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { BackgroundMaterial } from \"core/Materials/Background/backgroundMaterial\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport { SwitchPropertyLine } from \"shared-ui-components/fluent/hoc/propertyLines/switchPropertyLine\";\r\n\r\nimport { MakeLazyComponent } from \"shared-ui-components/fluent/primitives/lazyComponent\";\r\nimport { Collapse } from \"shared-ui-components/fluent/primitives/collapse\";\r\nimport { ArrowDownloadRegular } from \"@fluentui/react-icons\";\r\n\r\nconst EnvExportImageTypes = [\r\n    { label: \"PNG\", value: 0, imageType: \"image/png\" },\r\n    { label: \"WebP\", value: 1, imageType: \"image/webp\" },\r\n] as const;\r\n\r\ninterface IBabylonExportOptionsState {\r\n    imageTypeIndex: number;\r\n    imageQuality: number;\r\n    iblDiffuse: boolean;\r\n}\r\n\r\nexport const ExportBabylonTools: FunctionComponent<{ scene: Scene }> = ({ scene }) => {\r\n    const [babylonExportOptions, setBabylonExportOptions] = useState<Readonly<IBabylonExportOptionsState>>({\r\n        imageTypeIndex: 0,\r\n        imageQuality: 0.8,\r\n        iblDiffuse: false,\r\n    });\r\n\r\n    const exportBabylon = useCallback(async () => {\r\n        const strScene = JSON.stringify(SceneSerializer.Serialize(scene));\r\n        const blob = new Blob([strScene], { type: \"octet/stream\" });\r\n        Tools.Download(blob, \"scene.babylon\");\r\n    }, [scene]);\r\n\r\n    const createEnvTexture = useCallback(async () => {\r\n        if (!scene.environmentTexture) {\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const buffer = await EnvironmentTextureTools.CreateEnvTextureAsync(scene.environmentTexture as CubeTexture, {\r\n                imageType: EnvExportImageTypes[babylonExportOptions.imageTypeIndex].imageType,\r\n                imageQuality: babylonExportOptions.imageQuality,\r\n                disableIrradianceTexture: !babylonExportOptions.iblDiffuse,\r\n            });\r\n            const blob = new Blob([buffer], { type: \"octet/stream\" });\r\n            Tools.Download(blob, \"environment.env\");\r\n        } catch (error: any) {\r\n            Logger.Error(error);\r\n            alert(error);\r\n        }\r\n    }, [scene, babylonExportOptions]);\r\n\r\n    return (\r\n        <>\r\n            <ButtonLine label=\"Export to Babylon\" icon={ArrowDownloadRegular} onClick={exportBabylon} />\r\n            {!scene.getEngine().premultipliedAlpha && scene.environmentTexture && scene.environmentTexture._prefiltered && scene.activeCamera && (\r\n                <>\r\n                    <ButtonLine label=\"Generate .env texture\" icon={ArrowDownloadRegular} onClick={createEnvTexture} />\r\n                    {scene.environmentTexture.irradianceTexture && (\r\n                        <SwitchPropertyLine\r\n                            key=\"iblDiffuse\"\r\n                            label=\"Diffuse Texture\"\r\n                            description=\"Export diffuse texture for IBL\"\r\n                            value={babylonExportOptions.iblDiffuse}\r\n                            onChange={(value: boolean) => {\r\n                                setBabylonExportOptions((prev) => ({ ...prev, iblDiffuse: value }));\r\n                            }}\r\n                        />\r\n                    )}\r\n                    <NumberDropdownPropertyLine\r\n                        label=\"Image type\"\r\n                        options={EnvExportImageTypes}\r\n                        value={babylonExportOptions.imageTypeIndex}\r\n                        onChange={(val) => {\r\n                            setBabylonExportOptions((prev) => ({ ...prev, imageTypeIndex: val as number }));\r\n                        }}\r\n                    />\r\n                    <Collapse visible={babylonExportOptions.imageTypeIndex > 0}>\r\n                        <SyncedSliderPropertyLine\r\n                            label=\"Quality\"\r\n                            value={babylonExportOptions.imageQuality}\r\n                            onChange={(value) => setBabylonExportOptions((prev) => ({ ...prev, imageQuality: value }))}\r\n                            min={0}\r\n                            max={1}\r\n                        />\r\n                    </Collapse>\r\n                </>\r\n            )}\r\n        </>\r\n    );\r\n};\r\n\r\ninterface IGltfExportOptionsState {\r\n    exportDisabledNodes: boolean;\r\n    exportSkyboxes: boolean;\r\n    exportCameras: boolean;\r\n    exportLights: boolean;\r\n    dracoCompression: boolean;\r\n}\r\n\r\nexport const ExportGltfTools = MakeLazyComponent(async () => {\r\n    // Defer importing anything from the serializers package until this component is actually mounted.\r\n    const { GLTF2Export } = await import(\"serializers/glTF/2.0/glTFSerializer\");\r\n\r\n    return (props: { scene: Scene }) => {\r\n        const [isExportingGltf, setIsExportingGltf] = useState(false);\r\n        const [gltfExportOptions, setGltfExportOptions] = useState<Readonly<IGltfExportOptionsState>>({\r\n            exportDisabledNodes: false,\r\n            exportSkyboxes: false,\r\n            exportCameras: false,\r\n            exportLights: false,\r\n            dracoCompression: false,\r\n        });\r\n\r\n        const exportGLTF = useCallback(async () => {\r\n            setIsExportingGltf(true);\r\n\r\n            const shouldExport = (node: Node): boolean => {\r\n                if (!gltfExportOptions.exportDisabledNodes) {\r\n                    if (!node.isEnabled()) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (!gltfExportOptions.exportSkyboxes) {\r\n                    if (node instanceof Mesh) {\r\n                        if (node.material) {\r\n                            const material = node.material as PBRMaterial | StandardMaterial | BackgroundMaterial;\r\n                            const reflectionTexture = material.reflectionTexture;\r\n                            if (reflectionTexture && reflectionTexture.coordinatesMode === Texture.SKYBOX_MODE) {\r\n                                return false;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!gltfExportOptions.exportCameras) {\r\n                    if (node instanceof Camera) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                if (!gltfExportOptions.exportLights) {\r\n                    if (node instanceof Light) {\r\n                        return false;\r\n                    }\r\n                }\r\n\r\n                return true;\r\n            };\r\n\r\n            try {\r\n                const glb = await GLTF2Export.GLBAsync(props.scene, \"scene\", {\r\n                    meshCompressionMethod: gltfExportOptions.dracoCompression ? \"Draco\" : undefined,\r\n                    shouldExportNode: (node) => shouldExport(node),\r\n                });\r\n                glb.downloadFiles();\r\n            } catch (reason) {\r\n                Logger.Error(`Failed to export GLB: ${reason}`);\r\n            } finally {\r\n                setIsExportingGltf(false);\r\n            }\r\n        }, [gltfExportOptions, props.scene]);\r\n\r\n        return (\r\n            <>\r\n                <SwitchPropertyLine\r\n                    key=\"GLTFExportDisabledNodes\"\r\n                    label=\"Export Disabled Nodes\"\r\n                    description=\"Whether to export nodes that are disabled in the scene.\"\r\n                    value={gltfExportOptions.exportDisabledNodes}\r\n                    onChange={(checked: boolean) => setGltfExportOptions({ ...gltfExportOptions, exportDisabledNodes: checked })}\r\n                />\r\n                <SwitchPropertyLine\r\n                    key=\"GLTFExportSkyboxes\"\r\n                    label=\"Export Skyboxes\"\r\n                    description=\"Whether to export skybox nodes in the scene.\"\r\n                    value={gltfExportOptions.exportSkyboxes}\r\n                    onChange={(checked: boolean) => setGltfExportOptions({ ...gltfExportOptions, exportSkyboxes: checked })}\r\n                />\r\n                <SwitchPropertyLine\r\n                    key=\"GLTFExportCameras\"\r\n                    label=\"Export Cameras\"\r\n                    description=\"Whether to export cameras in the scene.\"\r\n                    value={gltfExportOptions.exportCameras}\r\n                    onChange={(checked: boolean) => setGltfExportOptions({ ...gltfExportOptions, exportCameras: checked })}\r\n                />\r\n                <SwitchPropertyLine\r\n                    key=\"GLTFExportLights\"\r\n                    label=\"Export Lights\"\r\n                    description=\"Whether to export lights in the scene.\"\r\n                    value={gltfExportOptions.exportLights}\r\n                    onChange={(checked: boolean) => setGltfExportOptions({ ...gltfExportOptions, exportLights: checked })}\r\n                />\r\n                <SwitchPropertyLine\r\n                    key=\"GLTFDracoCompression\"\r\n                    label=\"Draco Compression\"\r\n                    description=\"Whether to apply Draco compression to geometry.\"\r\n                    value={gltfExportOptions.dracoCompression}\r\n                    onChange={(checked: boolean) => setGltfExportOptions({ ...gltfExportOptions, dracoCompression: checked })}\r\n                />\r\n                <ButtonLine label=\"Export to GLB\" icon={ArrowDownloadRegular} onClick={exportGLTF} disabled={isExportingGltf} />\r\n            </>\r\n        );\r\n    };\r\n});\r\n","import type { ServiceDefinition } from \"../../../modularity/serviceDefinition\";\r\nimport { ToolsServiceIdentity } from \"../toolsService\";\r\nimport type { IToolsService } from \"../toolsService\";\r\nimport type { IDisposable } from \"core/scene\";\r\nimport { ExportBabylonTools, ExportGltfTools } from \"../../../components/tools/exportTools\";\r\n\r\nexport const ExportServiceDefinition: ServiceDefinition<[], [IToolsService]> = {\r\n    friendlyName: \"Export Tools\",\r\n    consumes: [ToolsServiceIdentity],\r\n    factory: (toolsService) => {\r\n        const contentRegistrations: IDisposable[] = [];\r\n\r\n        // glTF export content\r\n        contentRegistrations.push(\r\n            toolsService.addSectionContent({\r\n                key: \"glTF Export\",\r\n                section: \"glTF Export\",\r\n                component: ({ context }) => <ExportGltfTools scene={context} />,\r\n            })\r\n        );\r\n\r\n        // Babylon export content\r\n        contentRegistrations.push(\r\n            toolsService.addSectionContent({\r\n                key: \"Babylon Export\",\r\n                section: \"Babylon Export\",\r\n                component: ({ context }) => <ExportBabylonTools scene={context} />,\r\n            })\r\n        );\r\n\r\n        return {\r\n            dispose: () => {\r\n                contentRegistrations.forEach((registration) => registration.dispose());\r\n            },\r\n        };\r\n    },\r\n};\r\n\r\nexport default {\r\n    serviceDefinitions: [ExportServiceDefinition],\r\n} as const;\r\n"],"names":["SerializedGeometries","SerializeGeometry","geometry","serializationGeometries","doNotSerialize","vertexData","push","serializeVerticeData","id","SerializeMesh","mesh","serializationScene","serializationObject","_geometry","getScene","getGeometryById","geometries","serialize","FinalizeSingleNode","node","_isMesh","delayLoadState","DELAYLOADSTATE_LOADED","DELAYLOADSTATE_NONE","serializeMaterial","material","materials","some","mat","multiMaterials","submaterial","subMaterials","defaultMaterial","boxes","spheres","cylinders","toruses","grounds","planes","torusKnots","skeleton","skeletons","meshes","getClassName","transformNode","transformNodes","indexOf","camera","cameras","light","lights","SceneSerializer","ClearCache","Serialize","scene","_Serialize","checkSyncReadSupported","getEngine","_features","supportSyncTextureRead","ForceSerializeBuffers","Warn","useDelayedTextureLoading","autoClear","clearColor","asArray","ambientColor","gravity","collisionsEnabled","useRightHandedSystem","undefined","fogMode","fogColor","fogStart","fogEnd","fogDensity","isPhysicsEnabled","physicEngine","getPhysicsEngine","physicsEnabled","physicsGravity","physicsEngine","getPhysicsPluginName","metadata","morphTargetManagers","abstractMesh","manager","morphTargetManager","index","length","activeCamera","activeCameraID","AppendSerializedAnimations","animationGroups","animationGroupIndex","animationGroup","reflectionProbes","reflectionProbe","multiMaterial","environmentTexture","_files","name","environmentTextureRotationY","rotationY","environmentIntensity","iblIntensity","getGeometries","isReady","particleSystems","particleSystem","postProcesses","postProcess","actionManager","actions","component","_serializableComponents","spriteManagers","spriteManager","SerializeAsync","promises","this","_CollectPromises","Promise","all","obj","Array","isArray","i","o","then","res","Object","prototype","hasOwnProperty","call","toSerialize","withParents","withChildren","descendants","getDescendants","parent","EnvExportImageTypes","label","value","imageType","ExportBabylonTools","babylonExportOptions","setBabylonExportOptions","useState","imageTypeIndex","imageQuality","iblDiffuse","exportBabylon","useCallback","async","strScene","JSON","stringify","blob","Blob","type","Download","createEnvTexture","buffer","CreateEnvTextureAsync","disableIrradianceTexture","error","Error","alert","icon","onClick","premultipliedAlpha","_prefiltered","irradianceTexture","description","onChange","prev","options","val","visible","min","max","ExportGltfTools","GLTF2Export","props","isExportingGltf","setIsExportingGltf","gltfExportOptions","setGltfExportOptions","exportDisabledNodes","exportSkyboxes","exportCameras","exportLights","dracoCompression","exportGLTF","GLBAsync","meshCompressionMethod","shouldExportNode","isEnabled","reflectionTexture","coordinatesMode","SKYBOX_MODE","shouldExport","downloadFiles","reason","checked","disabled","ExportServiceDefinition","friendlyName","consumes","factory","toolsService","contentRegistrations","addSectionContent","key","section","context","dispose","forEach","registration","serviceDefinitions"],"ignoreList":[],"sourceRoot":""}