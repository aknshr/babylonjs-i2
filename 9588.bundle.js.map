{"version":3,"file":"9588.bundle.js","mappings":"6NA+BO,MAAMA,UAAyC,IAGlD,WAAAC,CAIoBC,GAEhBC,MAAMD,GAFU,KAAAA,OAAAA,EANJ,KAAAE,aAAuB,EAUnC,IAAK,MAAMC,KAAOC,KAAKJ,OAAOK,UAC1BD,KAAKE,mBAAmBH,EAAKC,KAAKJ,OAAOK,UAAUF,GAAKI,KAEhE,CAEgB,oBAAAC,CAAqBC,GACjC,MAAMC,EAAaD,EAAQE,cAAcC,YAAYC,yBAAyBT,KAAKJ,OAAOc,SAE1F,GAAIJ,GAAcA,EAAWK,gBAAkBL,EAAWM,UAAUC,OAAS,IAAqBC,iBAE9F,YADAd,KAAKe,aAAaV,EAAS,kEAAkEL,KAAKJ,OAAOc,mBAAmB,IAAqBI,qBAIrJ,MAAME,EAAgBV,EAAWW,KAAKhB,IAClC,MAAMiB,EAAOC,OAAOD,KAAKjB,GACzB,IAAK,MAAMF,KAAOmB,EACdlB,KAAKoB,cAAcrB,IAAMsB,SAASpB,EAAUF,GAAMM,GAEtDL,KAAKsB,SAASjB,MAElBA,EAAQkB,sBAAsBvB,KAAM,iBAAkBgB,EAC1D,CACgB,mBAAAQ,CAAoBnB,GAChC,MAAMC,EAAaD,EAAQE,cAAcC,YAAYC,yBAAyBT,KAAKJ,OAAOc,SAC1F,GAAIJ,EAAY,CACZ,MAAMU,EAAgBX,EAAQoB,sBAAiDzB,KAAM,iBAAkB,MACvGM,EAAWoB,OAAOV,EACtB,MACI,KAAMW,KAAK,kEAAkE3B,KAAKJ,OAAOc,UAEjG,CAEgB,aAAAkB,CAAcC,EAA4BC,GACtD,OAAO,CACX,CAKgB,YAAAC,GACZ,MAAO,kCACX,GAEJ,QAAc,mCAAwCrC,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Event/flowGraphReceiveCustomEventBlock.ts?"],"sourcesContent":["import type { Observer } from \"../../../Misc/observable\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport { FlowGraphEventBlock } from \"../../flowGraphEventBlock\";\r\nimport type { Nullable } from \"../../../types\";\r\nimport { Tools } from \"../../../Misc/tools\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../flowGraphBlockNames\";\r\nimport { FlowGraphCoordinator } from \"core/FlowGraph/flowGraphCoordinator\";\r\n/**\r\n * Parameters used to create a FlowGraphReceiveCustomEventBlock.\r\n */\r\nexport interface IFlowGraphReceiveCustomEventBlockConfiguration extends IFlowGraphBlockConfiguration {\r\n    /**\r\n     * The id of the event to receive.\r\n     * This event id is unique to the environment (not the context).\r\n     */\r\n    eventId: string;\r\n    /**\r\n     * The names of the data outputs for that event. Should be in the same order as the event data in\r\n     * SendCustomEvent\r\n     */\r\n    eventData: { [key: string]: { type: RichType<any> } };\r\n}\r\n\r\n/**\r\n * A block that receives a custom event.\r\n * It saves the event data in the data outputs, based on the provided eventData in the configuration. For example, if the event data is\r\n * `{ x: { type: RichTypeNumber }, y: { type: RichTypeNumber } }`, the block will have two data outputs: x and y.\r\n */\r\nexport class FlowGraphReceiveCustomEventBlock extends FlowGraphEventBlock {\r\n    public override initPriority: number = 1;\r\n\r\n    constructor(\r\n        /**\r\n         * the configuration of the block\r\n         */\r\n        public override config: IFlowGraphReceiveCustomEventBlockConfiguration\r\n    ) {\r\n        super(config);\r\n        // use event data to register data outputs\r\n        for (const key in this.config.eventData) {\r\n            this.registerDataOutput(key, this.config.eventData[key].type);\r\n        }\r\n    }\r\n\r\n    public override _preparePendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        // check if we are not exceeding the max number of events\r\n        if (observable && observable.hasObservers() && observable.observers.length > FlowGraphCoordinator.MaxEventsPerType) {\r\n            this._reportError(context, `FlowGraphReceiveCustomEventBlock: Too many observers for event ${this.config.eventId}. Max is ${FlowGraphCoordinator.MaxEventsPerType}.`);\r\n            return;\r\n        }\r\n\r\n        const eventObserver = observable.add((eventData: { [key: string]: any }) => {\r\n            const keys = Object.keys(eventData);\r\n            for (const key of keys) {\r\n                this.getDataOutput(key)?.setValue(eventData[key], context);\r\n            }\r\n            this._execute(context);\r\n        });\r\n        context._setExecutionVariable(this, \"_eventObserver\", eventObserver);\r\n    }\r\n    public override _cancelPendingTasks(context: FlowGraphContext): void {\r\n        const observable = context.configuration.coordinator.getCustomEventObservable(this.config.eventId);\r\n        if (observable) {\r\n            const eventObserver = context._getExecutionVariable<Nullable<Observer<any[]>>>(this, \"_eventObserver\", null);\r\n            observable.remove(eventObserver);\r\n        } else {\r\n            Tools.Warn(`FlowGraphReceiveCustomEventBlock: Missing observable for event ${this.config.eventId}`);\r\n        }\r\n    }\r\n\r\n    public override _executeEvent(_context: FlowGraphContext, _payload: any): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.ReceiveCustomEvent;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.ReceiveCustomEvent, FlowGraphReceiveCustomEventBlock);\r\n"],"names":["FlowGraphReceiveCustomEventBlock","constructor","config","super","initPriority","key","this","eventData","registerDataOutput","type","_preparePendingTasks","context","observable","configuration","coordinator","getCustomEventObservable","eventId","hasObservers","observers","length","MaxEventsPerType","_reportError","eventObserver","add","keys","Object","getDataOutput","setValue","_execute","_setExecutionVariable","_cancelPendingTasks","_getExecutionVariable","remove","Warn","_executeEvent","_context","_payload","getClassName"],"ignoreList":[],"sourceRoot":""}