{"version":3,"file":"8270.bundle.js","mappings":"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","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Data/flowGraphCachedOperationBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Data/flowGraphUnaryOperationBlock.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Data/Math/flowGraphVectorMathBlocks.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/flowGraphMath.ts?","webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Data/flowGraphBinaryOperationBlock.ts?"],"sourcesContent":["import type { Nullable } from \"../../../types\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { FlowGraphBlock } from \"../../flowGraphBlock\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../flowGraphDataConnection\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport { RichTypeBoolean } from \"../../flowGraphRichTypes\";\r\n\r\nconst CacheName = \"cachedOperationValue\";\r\nconst CacheExecIdName = \"cachedExecutionId\";\r\n\r\n/**\r\n * A block that will cache the result of an operation and deliver it as an output.\r\n */\r\nexport abstract class FlowGraphCachedOperationBlock<OutputT> extends FlowGraphBlock {\r\n    /**\r\n     * The output of the operation\r\n     */\r\n    public readonly value: FlowGraphDataConnection<OutputT>;\r\n\r\n    /**\r\n     * Output connection: Whether the value is valid.\r\n     */\r\n    public readonly isValid: FlowGraphDataConnection<boolean>;\r\n\r\n    constructor(outputRichType: RichType<OutputT>, config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n\r\n        this.value = this.registerDataOutput(\"value\", outputRichType);\r\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Operation to realize\r\n     * @param context the graph context\r\n     */\r\n    public abstract _doOperation(context: FlowGraphContext): OutputT | undefined;\r\n\r\n    public override _updateOutputs(context: FlowGraphContext) {\r\n        const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);\r\n        const cachedValue = context._getExecutionVariable<Nullable<OutputT>>(this, CacheName, null);\r\n        if (cachedValue !== undefined && cachedValue !== null && cachedExecutionId === context.executionId) {\r\n            this.isValid.setValue(true, context);\r\n            this.value.setValue(cachedValue, context);\r\n        } else {\r\n            try {\r\n                const calculatedValue = this._doOperation(context);\r\n                if (calculatedValue === undefined || calculatedValue === null) {\r\n                    this.isValid.setValue(false, context);\r\n                    return;\r\n                }\r\n                context._setExecutionVariable(this, CacheName, calculatedValue);\r\n                context._setExecutionVariable(this, CacheExecIdName, context.executionId);\r\n                this.value.setValue(calculatedValue, context);\r\n                this.isValid.setValue(true, context);\r\n            } catch (e) {\r\n                this.isValid.setValue(false, context);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import type { FlowGraphDataConnection } from \"../../flowGraphDataConnection\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport { FlowGraphCachedOperationBlock } from \"./flowGraphCachedOperationBlock\";\r\n\r\n/**\r\n * @internal\r\n * The base block for all unary operation blocks. Receives an input of type InputT, and outputs a value of type ResultT.\r\n */\r\nexport class FlowGraphUnaryOperationBlock<InputT, ResultT> extends FlowGraphCachedOperationBlock<ResultT> {\r\n    /**\r\n     * the input of this block\r\n     */\r\n    a: FlowGraphDataConnection<InputT>;\r\n\r\n    constructor(\r\n        inputRichType: RichType<InputT>,\r\n        resultRichType: RichType<ResultT>,\r\n        private _operation: (input: InputT) => ResultT,\r\n        private _className: string,\r\n        config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        super(resultRichType, config);\r\n        this.a = this.registerDataInput(\"a\", inputRichType);\r\n    }\r\n\r\n    /**\r\n     * the operation performed by this block\r\n     * @param context the graph context\r\n     * @returns the result of the operation\r\n     */\r\n    public override _doOperation(context: FlowGraphContext): ResultT {\r\n        return this._operation(this.a.getValue(context));\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of this block\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return this._className;\r\n    }\r\n}\r\n","import { FlowGraphBlock, type IFlowGraphBlockConfiguration } from \"core/FlowGraph/flowGraphBlock\";\nimport {\n    RichTypeVector3,\n    FlowGraphTypes,\n    RichTypeNumber,\n    RichTypeAny,\n    RichTypeVector2,\n    RichTypeMatrix,\n    getRichTypeByFlowGraphType,\n    RichTypeQuaternion,\n    RichTypeBoolean,\n} from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\nimport { FlowGraphBinaryOperationBlock } from \"../flowGraphBinaryOperationBlock\";\nimport { FlowGraphUnaryOperationBlock } from \"../flowGraphUnaryOperationBlock\";\nimport { Quaternion, Vector3, Vector4 } from \"core/Maths/math.vector\";\nimport type { Matrix, Vector2 } from \"core/Maths/math.vector\";\nimport type { FlowGraphMatrix2D, FlowGraphMatrix3D } from \"core/FlowGraph/CustomTypes\";\nimport type { FlowGraphMatrix, FlowGraphVector } from \"core/FlowGraph/utils\";\nimport { _GetClassNameOf } from \"core/FlowGraph/utils\";\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\nimport type { FlowGraphContext } from \"../../../flowGraphContext\";\nimport type { Nullable } from \"../../../../types\";\nimport { GetAngleBetweenQuaternions, GetQuaternionFromDirections } from \"core/FlowGraph/flowGraphMath\";\n\nconst AxisCacheName = \"cachedOperationAxis\";\nconst AngleCacheName = \"cachedOperationAngle\";\nconst CacheExecIdName = \"cachedExecutionId\";\n\n/**\n * Vector length block.\n */\nexport class FlowGraphLengthBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeNumber, (a) => this._polymorphicLength(a), FlowGraphBlockNames.Length, config);\n    }\n\n    private _polymorphicLength(a: FlowGraphVector) {\n        const aClassName = _GetClassNameOf(a);\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                return (a as Vector3).length();\n            default:\n                throw new Error(`Cannot compute length of value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Length, FlowGraphLengthBlock);\n\n/**\n * Configuration for normalized vector\n */\nexport interface IFlowGraphNormalizeBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * If true, the block will return NaN if the input vector has a length of 0.\n     * This is the expected behavior for glTF interactivity graphs.\n     */\n    nanOnZeroLength?: boolean;\n}\n\n/**\n * Vector normalize block.\n */\nexport class FlowGraphNormalizeBlock extends FlowGraphUnaryOperationBlock<FlowGraphVector, FlowGraphVector> {\n    constructor(config?: IFlowGraphNormalizeBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, (a) => this._polymorphicNormalize(a), FlowGraphBlockNames.Normalize, config);\n    }\n\n    private _polymorphicNormalize(a: FlowGraphVector) {\n        const aClassName = _GetClassNameOf(a);\n        let normalized: FlowGraphVector;\n        switch (aClassName) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                normalized = a.normalizeToNew();\n                if (this.config?.nanOnZeroLength) {\n                    const length = a.length();\n                    if (length === 0) {\n                        normalized.setAll(NaN);\n                    }\n                }\n                return normalized;\n            default:\n                throw new Error(`Cannot normalize value ${a}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Normalize, FlowGraphNormalizeBlock);\n\n/**\n * Dot product block.\n */\nexport class FlowGraphDotBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphVector, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeAny, RichTypeAny, RichTypeNumber, (a, b) => this._polymorphicDot(a, b), FlowGraphBlockNames.Dot, config);\n    }\n\n    private _polymorphicDot(a: FlowGraphVector, b: FlowGraphVector) {\n        const className = _GetClassNameOf(a);\n        switch (className) {\n            case FlowGraphTypes.Vector2:\n            case FlowGraphTypes.Vector3:\n            case FlowGraphTypes.Vector4:\n            case FlowGraphTypes.Quaternion:\n                // casting is needed because dot requires both to be the same type\n                return (a as Vector3).dot(b as Vector3);\n            default:\n                throw new Error(`Cannot get dot product of ${a} and ${b}`);\n        }\n    }\n}\nRegisterClass(FlowGraphBlockNames.Dot, FlowGraphDotBlock);\n\n/**\n * Cross product block.\n */\nexport class FlowGraphCrossBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeVector3, (a, b) => Vector3.Cross(a, b), FlowGraphBlockNames.Cross, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Cross, FlowGraphCrossBlock);\n\n/**\n * 2D rotation block.\n */\nexport class FlowGraphRotate2DBlock extends FlowGraphBinaryOperationBlock<Vector2, number, Vector2> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector2, RichTypeNumber, RichTypeVector2, (a, b) => a.rotate(b), FlowGraphBlockNames.Rotate2D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate2D, FlowGraphRotate2DBlock);\n\n/**\n * 3D rotation block.\n */\nexport class FlowGraphRotate3DBlock extends FlowGraphBinaryOperationBlock<Vector3, Quaternion, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeQuaternion, RichTypeVector3, (a, b) => a.applyRotationQuaternion(b), FlowGraphBlockNames.Rotate3D, config);\n    }\n}\nRegisterClass(FlowGraphBlockNames.Rotate3D, FlowGraphRotate3DBlock);\n\nfunction TransformVector(a: FlowGraphVector, b: FlowGraphMatrix): FlowGraphVector {\n    const className = _GetClassNameOf(a);\n    switch (className) {\n        case FlowGraphTypes.Vector2:\n            return (b as FlowGraphMatrix2D).transformVector(a as Vector2);\n        case FlowGraphTypes.Vector3:\n            return (b as FlowGraphMatrix3D).transformVector(a as Vector3);\n        case FlowGraphTypes.Vector4:\n            a = a as Vector4;\n            // transform the vector 4 with the matrix here. Vector4.TransformCoordinates transforms a 3D coordinate, not Vector4\n            return new Vector4(\n                a.x * b.m[0] + a.y * b.m[1] + a.z * b.m[2] + a.w * b.m[3],\n                a.x * b.m[4] + a.y * b.m[5] + a.z * b.m[6] + a.w * b.m[7],\n                a.x * b.m[8] + a.y * b.m[9] + a.z * b.m[10] + a.w * b.m[11],\n                a.x * b.m[12] + a.y * b.m[13] + a.z * b.m[14] + a.w * b.m[15]\n            );\n        default:\n            throw new Error(`Cannot transform value ${a}`);\n    }\n}\n\n/**\n * Configuration for the transform block.\n */\nexport interface IFlowGraphTransformBlockConfiguration extends IFlowGraphBlockConfiguration {\n    /**\n     * The vector type\n     */\n    vectorType: FlowGraphTypes;\n}\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformBlock extends FlowGraphBinaryOperationBlock<FlowGraphVector, FlowGraphMatrix, FlowGraphVector> {\n    constructor(config?: IFlowGraphTransformBlockConfiguration) {\n        const vectorType = config?.vectorType || FlowGraphTypes.Vector3;\n        const matrixType =\n            vectorType === FlowGraphTypes.Vector2 ? FlowGraphTypes.Matrix2D : vectorType === FlowGraphTypes.Vector3 ? FlowGraphTypes.Matrix3D : FlowGraphTypes.Matrix;\n        super(\n            getRichTypeByFlowGraphType(vectorType),\n            getRichTypeByFlowGraphType(matrixType),\n            getRichTypeByFlowGraphType(vectorType),\n            TransformVector,\n            FlowGraphBlockNames.TransformVector,\n            config\n        );\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformVector, FlowGraphTransformBlock);\n\n/**\n * Transform a vector3 by a matrix.\n */\nexport class FlowGraphTransformCoordinatesBlock extends FlowGraphBinaryOperationBlock<Vector3, Matrix, Vector3> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeMatrix, RichTypeVector3, (a, b) => Vector3.TransformCoordinates(a, b), FlowGraphBlockNames.TransformCoordinates, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.TransformCoordinates, FlowGraphTransformCoordinatesBlock);\n\n/**\n * Conjugate the quaternion.\n */\nexport class FlowGraphConjugateBlock extends FlowGraphUnaryOperationBlock<Quaternion, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeQuaternion, RichTypeQuaternion, (a) => a.conjugate(), FlowGraphBlockNames.Conjugate, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.Conjugate, FlowGraphConjugateBlock);\n\n/**\n * Get the angle between two quaternions.\n */\nexport class FlowGraphAngleBetweenBlock extends FlowGraphBinaryOperationBlock<Quaternion, Quaternion, number> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeQuaternion, RichTypeQuaternion, RichTypeNumber, (a, b) => GetAngleBetweenQuaternions(a, b), FlowGraphBlockNames.AngleBetween, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.AngleBetween, FlowGraphAngleBetweenBlock);\n\n/**\n * Get the quaternion from an axis and an angle.\n */\nexport class FlowGraphQuaternionFromAxisAngleBlock extends FlowGraphBinaryOperationBlock<Vector3, number, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeNumber, RichTypeQuaternion, (a, b) => Quaternion.RotationAxis(a, b), FlowGraphBlockNames.QuaternionFromAxisAngle, config);\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.QuaternionFromAxisAngle, FlowGraphQuaternionFromAxisAngleBlock);\n\n/**\n * Get the axis and angle from a quaternion.\n */\nexport class FlowGraphAxisAngleFromQuaternionBlock extends FlowGraphBlock {\n    /**\n     * The input of this block.\n     */\n    public readonly a: FlowGraphDataConnection<Quaternion>;\n\n    /**\n     * The output axis of rotation.\n     */\n    public readonly axis: FlowGraphDataConnection<Vector3>;\n\n    /**\n     * The output angle of rotation.\n     */\n    public readonly angle: FlowGraphDataConnection<number>;\n\n    /**\n     * Output connection: Whether the value is valid.\n     */\n    public readonly isValid: FlowGraphDataConnection<boolean>;\n\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(config);\n\n        this.a = this.registerDataInput(\"a\", RichTypeQuaternion);\n\n        this.axis = this.registerDataOutput(\"axis\", RichTypeVector3);\n        this.angle = this.registerDataOutput(\"angle\", RichTypeNumber);\n\n        this.isValid = this.registerDataOutput(\"isValid\", RichTypeBoolean);\n    }\n\n    /** @override */\n    public override _updateOutputs(context: FlowGraphContext) {\n        const cachedExecutionId = context._getExecutionVariable(this, CacheExecIdName, -1);\n        const cachedAxis = context._getExecutionVariable<Nullable<Vector3>>(this, AxisCacheName, null);\n        const cachedAngle = context._getExecutionVariable<Nullable<number>>(this, AngleCacheName, null);\n        if (cachedAxis !== undefined && cachedAxis !== null && cachedAngle !== undefined && cachedAngle !== null && cachedExecutionId === context.executionId) {\n            this.axis.setValue(cachedAxis, context);\n            this.angle.setValue(cachedAngle, context);\n        } else {\n            try {\n                const { axis, angle } = this.a.getValue(context).toAxisAngle();\n                context._setExecutionVariable(this, AxisCacheName, axis);\n                context._setExecutionVariable(this, AngleCacheName, angle);\n                context._setExecutionVariable(this, CacheExecIdName, context.executionId);\n                this.axis.setValue(axis, context);\n                this.angle.setValue(angle, context);\n                this.isValid.setValue(true, context);\n            } catch (e) {\n                this.isValid.setValue(false, context);\n            }\n        }\n    }\n\n    /** @override */\n    public override getClassName(): string {\n        return FlowGraphBlockNames.AxisAngleFromQuaternion;\n    }\n}\n\nRegisterClass(FlowGraphBlockNames.AxisAngleFromQuaternion, FlowGraphAxisAngleFromQuaternionBlock);\n\n/**\n * Get the quaternion from two direction vectors.\n */\nexport class FlowGraphQuaternionFromDirectionsBlock extends FlowGraphBinaryOperationBlock<Vector3, Vector3, Quaternion> {\n    constructor(config?: IFlowGraphBlockConfiguration) {\n        super(RichTypeVector3, RichTypeVector3, RichTypeQuaternion, (a, b) => GetQuaternionFromDirections(a, b), FlowGraphBlockNames.QuaternionFromDirections, config);\n    }\n}\n","import type { IQuaternionLike } from \"../Maths/math.like\";\r\nimport { Clamp } from \"../Maths/math.scalar.functions\";\r\nimport { Quaternion, Vector3 } from \"../Maths/math.vector\";\r\nimport { Vector3Dot, Vector4Dot } from \"../Maths/math.vector.functions\";\r\nimport type { DeepImmutable } from \"../types\";\r\n\r\n// *** NOTE ***\r\n// These functions should ideally go in math.vector.functions.ts, but they require math.vector.ts to\r\n// be imported which is big. To avoid the larger bundle size, they are kept inside flow graph for now.\r\n\r\n/**\r\n * Returns the angle in radians between two quaternions\r\n * @param q1 defines the first quaternion\r\n * @param q2 defines the second quaternion\r\n * @returns the angle in radians between the two quaternions\r\n */\r\nexport function GetAngleBetweenQuaternions(q1: DeepImmutable<IQuaternionLike>, q2: DeepImmutable<IQuaternionLike>): number {\r\n    return Math.acos(Clamp(Vector4Dot(q1, q2), -1, 1)) * 2;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from two direction vectors\r\n * @param a defines the first direction vector\r\n * @param b defines the second direction vector\r\n * @returns the target quaternion\r\n */\r\nexport function GetQuaternionFromDirections<T extends Vector3>(a: DeepImmutable<T>, b: DeepImmutable<T>): Quaternion {\r\n    const result = new Quaternion();\r\n    GetQuaternionFromDirectionsToRef(a, b, result);\r\n    return result;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from two direction vectors\r\n * @param a defines the first direction vector\r\n * @param b defines the second direction vector\r\n * @param result defines the target quaternion\r\n * @returns the target quaternion\r\n */\r\nexport function GetQuaternionFromDirectionsToRef<T extends Vector3, ResultT extends Quaternion>(a: DeepImmutable<T>, b: DeepImmutable<T>, result: ResultT): ResultT {\r\n    const axis = Vector3.Cross(a, b);\r\n    const angle = Math.acos(Clamp(Vector3Dot(a, b), -1, 1));\r\n    Quaternion.RotationAxisToRef(axis, angle, result);\r\n    return result;\r\n}\r\n","import type { FlowGraphDataConnection } from \"../../flowGraphDataConnection\";\r\nimport type { RichType } from \"../../flowGraphRichTypes\";\r\nimport type { FlowGraphContext } from \"../../flowGraphContext\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../flowGraphBlock\";\r\nimport { FlowGraphCachedOperationBlock } from \"./flowGraphCachedOperationBlock\";\r\n/**\r\n * The base block for all binary operation blocks. Receives an input of type\r\n * LeftT, one of type RightT, and outputs a value of type ResultT.\r\n */\r\nexport class FlowGraphBinaryOperationBlock<LeftT, RightT, ResultT> extends FlowGraphCachedOperationBlock<ResultT> {\r\n    /**\r\n     * First input of this block\r\n     */\r\n    a: FlowGraphDataConnection<LeftT>;\r\n    /**\r\n     * Second input of this block\r\n     */\r\n    b: FlowGraphDataConnection<RightT>;\r\n\r\n    constructor(\r\n        leftRichType: RichType<LeftT>,\r\n        rightRichType: RichType<RightT>,\r\n        resultRichType: RichType<ResultT>,\r\n        private _operation: (left: LeftT, right: RightT) => ResultT,\r\n        private _className: string,\r\n        config?: IFlowGraphBlockConfiguration\r\n    ) {\r\n        super(resultRichType, config);\r\n        this.a = this.registerDataInput(\"a\", leftRichType);\r\n        this.b = this.registerDataInput(\"b\", rightRichType);\r\n    }\r\n\r\n    /**\r\n     * the operation performed by this block\r\n     * @param context the graph context\r\n     * @returns the result of the operation\r\n     */\r\n    public override _doOperation(context: FlowGraphContext): ResultT {\r\n        const a = this.a.getValue(context);\r\n        const b = this.b.getValue(context);\r\n        return this._operation(a, b);\r\n    }\r\n\r\n    /**\r\n     * Gets the class name of this block\r\n     * @returns the class name\r\n     */\r\n    public override getClassName(): string {\r\n        return this._className;\r\n    }\r\n}\r\n"],"names":["CacheName","CacheExecIdName","FlowGraphCachedOperationBlock","constructor","outputRichType","config","super","this","value","registerDataOutput","isValid","_updateOutputs","context","cachedExecutionId","_getExecutionVariable","cachedValue","executionId","setValue","calculatedValue","_doOperation","_setExecutionVariable","e","FlowGraphUnaryOperationBlock","inputRichType","resultRichType","_operation","_className","a","registerDataInput","getValue","getClassName","AxisCacheName","AngleCacheName","FlowGraphLengthBlock","_polymorphicLength","length","Error","FlowGraphNormalizeBlock","_polymorphicNormalize","normalized","normalizeToNew","nanOnZeroLength","setAll","NaN","FlowGraphDotBlock","b","_polymorphicDot","dot","FlowGraphCrossBlock","Cross","FlowGraphRotate2DBlock","rotate","FlowGraphRotate3DBlock","applyRotationQuaternion","TransformVector","transformVector","x","m","y","z","w","FlowGraphTransformBlock","vectorType","matrixType","FlowGraphTransformCoordinatesBlock","TransformCoordinates","FlowGraphConjugateBlock","conjugate","FlowGraphAngleBetweenBlock","GetAngleBetweenQuaternions","q1","q2","Math","acos","Clamp","FlowGraphQuaternionFromAxisAngleBlock","RotationAxis","FlowGraphAxisAngleFromQuaternionBlock","axis","angle","cachedAxis","cachedAngle","toAxisAngle","FlowGraphQuaternionFromDirectionsBlock","result","RotationAxisToRef","GetQuaternionFromDirectionsToRef","GetQuaternionFromDirections","FlowGraphBinaryOperationBlock","leftRichType","rightRichType"],"ignoreList":[],"sourceRoot":""}