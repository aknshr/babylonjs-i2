{"version":3,"file":"2038.bundle.js","mappings":"wMAWO,MAAMA,UAA+B,IAcxC,WAAAC,CAAYC,GACRC,MAAMD,GACNE,KAAKC,MAAQD,KAAKE,qBAAqB,SACvCF,KAAKG,SAAWH,KAAKI,kBAAkB,WAAY,MACnDJ,KAAKK,kBAAoBL,KAAKM,mBAAmB,oBAAqB,KAAgBC,IAC1F,CACO,QAAAC,CAASC,EAA2BC,GACvC,GAAIA,IAAkBV,KAAKC,MAIvB,OAHAD,KAAKK,kBAAkBM,SAASJ,IAAKE,GACrCA,EAAQG,sBAAsBZ,KAAM,oBAAqBO,UACzDE,EAAQG,sBAAsBZ,KAAM,YAAa,GAIrD,MAAMa,EAAgBb,KAAKG,SAASW,SAASL,GAC7C,GAAII,GAAiB,GAAKE,MAAMF,KAAmBG,SAASH,GACxD,OAAOb,KAAKiB,aAAaR,EAAS,sCAEtC,MAAMJ,EAAoBI,EAAQS,sBAAsBlB,KAAM,oBAAqBO,KAE7EY,EAAcC,KAAKC,MACzB,GAAIN,MAAMV,GAKN,OAJAL,KAAKK,kBAAkBM,SAAS,EAAGF,GACnCA,EAAQG,sBAAsBZ,KAAM,oBAAqB,GACzDS,EAAQG,sBAAsBZ,KAAM,YAAamB,GAE1CnB,KAAKsB,IAAIC,gBAAgBd,GAC7B,CACH,MAAMe,EAAcL,EAAcV,EAAQS,sBAAsBlB,KAAM,YAAa,GAE7EyB,EAA+B,IAAhBZ,EACrB,GAAIY,GAAgBD,EAIhB,OAHAxB,KAAKK,kBAAkBM,SAAS,EAAGF,GACnCA,EAAQG,sBAAsBZ,KAAM,oBAAqB,GACzDS,EAAQG,sBAAsBZ,KAAM,YAAamB,GAC1CnB,KAAKsB,IAAIC,gBAAgBd,GAC7B,CACH,MAAMiB,EAAgBD,EAAeD,EAErCxB,KAAKK,kBAAkBM,SAASe,EAAgB,IAAMjB,GACtDA,EAAQG,sBAAsBZ,KAAM,oBAAqB0B,EAC7D,CACJ,CACJ,CAIgB,YAAAC,GACZ,MAAO,wBACX,GAEJ,QAAc,yBAA8B/B,E","sources":["webpack://@dev/inspector-v2/../core/src/FlowGraph/Blocks/Execution/ControlFlow/flowGraphThrottleBlock.ts?"],"sourcesContent":["import type { FlowGraphContext } from \"../../../flowGraphContext\";\r\nimport type { FlowGraphDataConnection } from \"../../../flowGraphDataConnection\";\r\nimport { RichTypeNumber } from \"../../../flowGraphRichTypes\";\r\nimport type { FlowGraphSignalConnection } from \"../../../flowGraphSignalConnection\";\r\nimport { FlowGraphExecutionBlockWithOutSignal } from \"../../../flowGraphExecutionBlockWithOutSignal\";\r\nimport type { IFlowGraphBlockConfiguration } from \"../../../flowGraphBlock\";\r\nimport { RegisterClass } from \"../../../../Misc/typeStore\";\r\nimport { FlowGraphBlockNames } from \"../../flowGraphBlockNames\";\r\n/**\r\n * A block that throttles the execution of its output flow.\r\n */\r\nexport class FlowGraphThrottleBlock extends FlowGraphExecutionBlockWithOutSignal {\r\n    /**\r\n     * Input connection: The duration of the throttle, in seconds.\r\n     */\r\n    public readonly duration: FlowGraphDataConnection<number>;\r\n    /**\r\n     * Input connection: Resets the throttle.\r\n     */\r\n    public readonly reset: FlowGraphSignalConnection;\r\n    /**\r\n     * Output connection: The time remaining before the throttle is triggering again, in seconds.\r\n     */\r\n    public readonly lastRemainingTime: FlowGraphDataConnection<number>;\r\n\r\n    constructor(config?: IFlowGraphBlockConfiguration) {\r\n        super(config);\r\n        this.reset = this._registerSignalInput(\"reset\");\r\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\r\n        this.lastRemainingTime = this.registerDataOutput(\"lastRemainingTime\", RichTypeNumber, NaN);\r\n    }\r\n    public _execute(context: FlowGraphContext, callingSignal: FlowGraphSignalConnection): void {\r\n        if (callingSignal === this.reset) {\r\n            this.lastRemainingTime.setValue(NaN, context);\r\n            context._setExecutionVariable(this, \"lastRemainingTime\", NaN);\r\n            context._setExecutionVariable(this, \"timestamp\", 0);\r\n            return;\r\n        }\r\n        // in seconds\r\n        const durationValue = this.duration.getValue(context);\r\n        if (durationValue <= 0 || isNaN(durationValue) || !isFinite(durationValue)) {\r\n            return this._reportError(context, \"Invalid duration in Throttle block\");\r\n        }\r\n        const lastRemainingTime = context._getExecutionVariable(this, \"lastRemainingTime\", NaN);\r\n        // Using Date.now() to get ms since epoch. not using performance.now() because its precision is not needed here\r\n        const currentTime = Date.now();\r\n        if (isNaN(lastRemainingTime)) {\r\n            this.lastRemainingTime.setValue(0, context);\r\n            context._setExecutionVariable(this, \"lastRemainingTime\", 0);\r\n            context._setExecutionVariable(this, \"timestamp\", currentTime);\r\n            // according to glTF interactivity specs\r\n            return this.out._activateSignal(context);\r\n        } else {\r\n            const elapsedTime = currentTime - context._getExecutionVariable(this, \"timestamp\", 0);\r\n            // duration is in seconds, so we need to multiply by 1000\r\n            const durationInMs = durationValue * 1000;\r\n            if (durationInMs <= elapsedTime) {\r\n                this.lastRemainingTime.setValue(0, context);\r\n                context._setExecutionVariable(this, \"lastRemainingTime\", 0);\r\n                context._setExecutionVariable(this, \"timestamp\", currentTime);\r\n                return this.out._activateSignal(context);\r\n            } else {\r\n                const remainingTime = durationInMs - elapsedTime;\r\n                // output is in seconds\r\n                this.lastRemainingTime.setValue(remainingTime / 1000, context);\r\n                context._setExecutionVariable(this, \"lastRemainingTime\", remainingTime);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @returns class name of the block.\r\n     */\r\n    public override getClassName(): string {\r\n        return FlowGraphBlockNames.Throttle;\r\n    }\r\n}\r\nRegisterClass(FlowGraphBlockNames.Throttle, FlowGraphThrottleBlock);\r\n"],"names":["FlowGraphThrottleBlock","constructor","config","super","this","reset","_registerSignalInput","duration","registerDataInput","lastRemainingTime","registerDataOutput","NaN","_execute","context","callingSignal","setValue","_setExecutionVariable","durationValue","getValue","isNaN","isFinite","_reportError","_getExecutionVariable","currentTime","Date","now","out","_activateSignal","elapsedTime","durationInMs","remainingTime","getClassName"],"ignoreList":[],"sourceRoot":""}