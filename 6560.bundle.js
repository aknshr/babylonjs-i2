"use strict";(self.webpackChunk_dev_inspector_v2=self.webpackChunk_dev_inspector_v2||[]).push([[6560],{34179:(e,t,s)=>{s.d(t,{EXT_mesh_gpu_instancing:()=>c});var o=s(31273),r=s(83031),n=s(69884),a=s(96734);s(19729);const i="EXT_mesh_gpu_instancing";class c{constructor(e){this.name=i,this._loader=e,this.enabled=this._loader.isExtensionUsed(i)}dispose(){this._loader=null}loadNodeAsync(e,t,s){return n.BT.LoadExtensionAsync(e,t,this.name,(async(e,a)=>{this._loader._disableInstancedMesh++;const i=this._loader.loadNodeAsync(`/nodes/${t.index}`,t,s);if(this._loader._disableInstancedMesh--,!t._primitiveBabylonMeshes)return await i;const c=new Array;let l=0;const A=t=>{if(null==a.attributes[t])return void c.push(Promise.resolve(null));const s=n.l2.Get(`${e}/attributes/${t}`,this._loader.gltf.accessors,a.attributes[t]);if(c.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),0===l)l=s.count;else if(l!==s.count)throw new Error(`${e}/attributes: Instance buffer accessors do not have the same count.`)};return A("TRANSLATION"),A("ROTATION"),A("SCALE"),A("_COLOR_0"),await i.then((async e=>{const[s,n,a,i]=await Promise.all(c),A=new Float32Array(16*l);o.AA.Vector3[0].copyFromFloats(0,0,0),o.AA.Quaternion[0].copyFromFloats(0,0,0,1),o.AA.Vector3[1].copyFromFloats(1,1,1);for(let e=0;e<l;++e)s&&o.Pq.FromArrayToRef(s,3*e,o.AA.Vector3[0]),n&&o.PT.FromArrayToRef(n,4*e,o.AA.Quaternion[0]),a&&o.Pq.FromArrayToRef(a,3*e,o.AA.Vector3[1]),o.uq.ComposeToRef(o.AA.Vector3[1],o.AA.Quaternion[0],o.AA.Vector3[0],o.AA.Matrix[0]),o.AA.Matrix[0].copyToArray(A,16*e);for(const e of t._primitiveBabylonMeshes)e.thinInstanceSetBuffer("matrix",A,16,!0),i&&(i.length===3*l?e.thinInstanceSetBuffer("color",i,3,!0):i.length===4*l?e.thinInstanceSetBuffer("color",i,4,!0):r.V.Warn("Unexpected size of _COLOR_0 attribute for mesh "+e.name));return e}))}))}}(0,a.Hg)(i),(0,a.Ye)(i,!0,(e=>new c(e)))}}]);
//# sourceMappingURL=6560.bundle.js.map